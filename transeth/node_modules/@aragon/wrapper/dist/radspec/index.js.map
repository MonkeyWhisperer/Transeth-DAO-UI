{"version":3,"sources":["../../src/radspec/index.js"],"names":["tryEvaluatingRadspec","intent","wrapper","apps","pipe","toPromise","app","find","proxyAddress","to","appsToSearch","foundMethod","reduce","found","method","data","abi","evaluatedNotice","notice","network","radspec","evaluate","transaction","ethNode","web3","currentProvider","currency","nativeCurrency","err","console","error","description","tryDescribingUpdateAppIntent","upgradeIntentParams","appId","appAddress","repoAddress","ens","resolve","repo","version","latestVersion","tryDescribingUpgradeOrganizationBasket","intents","upgradedKnownAppIds","map","filter","knownAppIds","includes","length","from"],"mappings":"qOA6duB;y8CAtdvB;;;;;;GAOO,cAAeA,CAAAA,oBAAf,CAAqCC,MAArC,CAA6CC,OAA7C,CAAsD,MACrDC,CAAAA,IAAI,CAAG,KAAMD,CAAAA,OAAO,CAACC,IAAR,CAAaC,IAAb,CAAkB,sBAAlB,EAA2BC,SAA3B,EADwC,CAErDC,GAAG,CAAGH,IAAI,CAACI,IAAL,CAAUD,GAAG,EAAI,0BAAeA,GAAG,CAACE,YAAnB,CAAiCP,MAAM,CAACQ,EAAxC,CAAjB,CAF+C,CAMrDC,YAAY,CAAGJ,GAAG,CAAG,CAACA,GAAD,CAAH,CAAWH,IANwB,CAOrDQ,WAAW,CAAGD,YAAY,CAACE,MAAb,CAAoB,CAACC,KAAD,CAAQP,GAAR,GAAgB,CACtD,GAAIO,KAAJ,CAAa,MAAOA,CAAAA,KAAP,CAEb,KAAMC,CAAAA,MAAM,CAAG,gCAAsBR,GAAtB,CAA2BL,MAAM,CAACc,IAAlC,CAAf,CACA,GAAID,MAAJ,CACE,MAAO,CACLA,MADK,CAEL;AACA;AACA;AACAE,GAAG,CAAEF,MAAM,CAACE,GAAP,CAAa,CAACF,MAAM,CAACE,GAAR,CAAb,CAA4BV,GAAG,CAACU,GALhC,CAQV,CAbmB,QAPuC,CAsBrD,CAAEA,GAAF,CAAOF,MAAP,EAAkBH,WAAW,EAAI,EAtBoB,CAwB3D,GAAIM,CAAAA,eAAJ,CACA,GAAIH,MAAM,EAAIA,MAAM,CAACI,MAArB,CACE,GAAI,CACF,KAAMC,CAAAA,OAAO,CAAG,KAAMjB,CAAAA,OAAO,CAACiB,OAAR,CAAgBf,IAAhB,CAAqB,sBAArB,EAA8BC,SAA9B,EAAtB,CACAY,eAAe,CAAG,KAAMG,CAAAA,OAAO,CAACC,QAAR,CACtBP,MAAM,CAACI,MADe,CAEtB,CACEF,GADF,CAEEM,WAAW,CAAErB,MAFf,CAFsB,CAMtB,CACEsB,OAAO,CAAErB,OAAO,CAACsB,IAAR,CAAaC,eADxB,CAEEC,QAAQ,CAAEP,OAAO,CAACQ,cAFpB,CANsB,CAWzB,CAAC,MAAOC,GAAP,CAAY,CACZC,OAAO,CAACC,KAAR,CAAe,gEAA+D7B,MAAM,CAACc,IAAK,EAA1F,CAA6Fa,GAA7F,CACD,CAGH,sCACK3B,MADL,MAEE8B,WAAW,CAAEd,eAFf,EAID,CAED;;;;;;GAOO,cAAee,CAAAA,4BAAf,CAA6C/B,MAA7C,CAAqDC,OAArD,CAA8D,CACnE,KAAM+B,CAAAA,mBAAmB,CAAG,CAAC,KAAM,8CAAiC,CAAChC,MAAD,CAAjC,CAA2CC,OAA3C,CAAP,EAA4D,CAA5D,CAA5B,CACA,GAAI,CAAC+B,mBAAL,CAA0B,OAFyC,KAI7D,CAAEC,KAAF,CAASC,UAAT,EAAwBF,mBAJqC,CAM7DG,WAAW,CAAG,KAAMlC,CAAAA,OAAO,CAACmC,GAAR,CAAYC,OAAZ,CAAoBJ,KAApB,CANyC,CAO7DK,IAAI,CAAG,wBAAcH,WAAd,CAA2BlC,OAAO,CAACsB,IAAnC,CAPsD,CAQ7D,CAAEgB,OAAO,CAAEC,aAAX,EAA6B,KAAM,0CAAgCF,IAAhC,CAAsCJ,UAAtC,CAR0B,CAKnE;AAKA,sCACKlC,MADL,MAEE8B,WAAW,CAAG,WAAUG,KAAM,sBAAqBO,aAAc,EAFnE,EAID,CAED;;;;;;GAOO,cAAeC,CAAAA,sCAAf,CAAuDC,OAAvD,CAAgEzC,OAAhE,CAAyE,CAC9E,KAAM0C,CAAAA,mBAAmB,CAAG,CAAC,KAAM,8CAAiCD,OAAjC,CAA0CzC,OAA1C,CAAP,EACzB2C,GADyB,CACrB,CAAC,CAAEX,KAAF,CAAD,GAAeA,KADM,CAE1B;AAF0B,CAGzBY,MAHyB,CAIxBZ,KAAK,EAAIa,kBAAYC,QAAZ,CAAqBd,KAArB,CAJe,CAA5B,CAOA,GACE;AACAS,OAAO,CAACM,MAAR,GAAmBL,mBAAmB,CAACK,MAAvC,EACA;AACAF,kBAAYE,MAAZ,GAAuBL,mBAAmB,CAACK,MAJ7C,CAME,MAAO,CACLlB,WAAW,CAAE,2CADR,CAELmB,IAAI,CAAEP,OAAO,CAAC,CAAD,CAAP,CAAWO,IAFZ,CAGLzC,EAAE,CAAEkC,OAAO,CAAC,CAAD,CAAP,CAAWlC,EAHV,CAMV","sourcesContent":["import { first } from 'rxjs/operators'\nimport * as radspec from 'radspec'\nimport { getRepoLatestVersionForContract, makeRepoProxy } from '../core/apm/repo'\nimport { addressesEqual } from '../utils'\nimport { findAppMethodFromData, knownAppIds } from '../utils/apps'\nimport { filterAndDecodeAppUpgradeIntents } from '../utils/intents'\n\n/**\n * Attempt to describe intent via radspec.\n *\n * @param  {Object} intent transaction intent\n * @param  {Object} wrapper\n * @return {Promise<Object>} Decorated intent with description, if one could be made\n */\nexport async function tryEvaluatingRadspec (intent, wrapper) {\n  const apps = await wrapper.apps.pipe(first()).toPromise()\n  const app = apps.find(app => addressesEqual(app.proxyAddress, intent.to))\n\n  // If the intent matches an installed app, use only that app to search for a\n  // method match, otherwise fallback to searching all installed apps\n  const appsToSearch = app ? [app] : apps\n  const foundMethod = appsToSearch.reduce((found, app) => {\n    if (found) { return found }\n\n    const method = findAppMethodFromData(app, intent.data)\n    if (method) {\n      return {\n        method,\n        // This is not very nice, but some apps don't have ABIs attached to their function\n        // declarations and so we have to fall back to using their full app ABI\n        // TODO: define a more concrete schema around the artifact.json's `function.abi`\n        abi: method.abi ? [method.abi] : app.abi\n      }\n    }\n  }, undefined)\n\n  const { abi, method } = foundMethod || {}\n\n  let evaluatedNotice\n  if (method && method.notice) {\n    try {\n      const network = await wrapper.network.pipe(first()).toPromise()\n      evaluatedNotice = await radspec.evaluate(\n        method.notice,\n        {\n          abi,\n          transaction: intent\n        },\n        {\n          ethNode: wrapper.web3.currentProvider,\n          currency: network.nativeCurrency\n        }\n      )\n    } catch (err) {\n      console.error(`Could not evaluate a description for given transaction data: ${intent.data}`, err)\n    }\n  }\n\n  return {\n    ...intent,\n    description: evaluatedNotice\n  }\n}\n\n/**\n * Attempt to describe a setApp() intent. Only describes the APP_BASE namespace.\n *\n * @param  {Object} intent transaction intent\n * @param  {Object} wrapper\n * @return {Promise<Object>} Decorated intent with description, if one could be made\n */\nexport async function tryDescribingUpdateAppIntent (intent, wrapper) {\n  const upgradeIntentParams = (await filterAndDecodeAppUpgradeIntents([intent], wrapper))[0]\n  if (!upgradeIntentParams) return\n\n  const { appId, appAddress } = upgradeIntentParams\n  // Fetch aragonPM information\n  const repoAddress = await wrapper.ens.resolve(appId)\n  const repo = makeRepoProxy(repoAddress, wrapper.web3)\n  const { version: latestVersion } = await getRepoLatestVersionForContract(repo, appAddress)\n\n  return {\n    ...intent,\n    description: `Upgrade ${appId} app instances to v${latestVersion}`\n  }\n}\n\n/**\n * Attempt to parse a complete organization upgrade intent\n *\n * @param  {Array<Object>} intents intent basket\n * @param  {Object} wrapper\n * @return {Promise<Object>} Decorated intent with description, if one could be made\n */\nexport async function tryDescribingUpgradeOrganizationBasket (intents, wrapper) {\n  const upgradedKnownAppIds = (await filterAndDecodeAppUpgradeIntents(intents, wrapper))\n    .map(({ appId }) => appId)\n    // Take intersection with knownAppIds\n    .filter(\n      appId => knownAppIds.includes(appId)\n    )\n\n  if (\n    // All intents are for upgrading known apps\n    intents.length === upgradedKnownAppIds.length &&\n    // All known apps are being upgraded\n    knownAppIds.length === upgradedKnownAppIds.length\n  ) {\n    return {\n      description: 'Upgrade organization to Aragon 0.8 Camino',\n      from: intents[0].from,\n      to: intents[0].to\n    }\n  }\n}\n\nexport { postprocessRadspecDescription } from './postprocess'\n"],"file":"index.js"}