"use strict";var _interopRequireDefault=require("@babel/runtime/helpers/interopRequireDefault");Object.defineProperty(exports,"__esModule",{value:!0// force cache invalidation
}),Object.defineProperty(exports,"postprocessRadspecDescription",{enumerable:!0,get:function(){return _postprocess.postprocessRadspecDescription}}),exports.tryDescribingUpdateAppIntent=tryDescribingUpdateAppIntent,exports.tryDescribingUpgradeOrganizationBasket=tryDescribingUpgradeOrganizationBasket,exports.tryEvaluatingRadspec=tryEvaluatingRadspec;var _defineProperty2=_interopRequireDefault(require("@babel/runtime/helpers/defineProperty")),_operators=require("rxjs/operators"),radspec=_interopRequireWildcard(require("radspec")),_repo=require("../core/apm/repo"),_utils=require("../utils"),_apps=require("../utils/apps"),_intents=require("../utils/intents"),_postprocess=require("./postprocess");function _getRequireWildcardCache(nodeInterop){if("function"!=typeof WeakMap)return null;var cacheBabelInterop=new WeakMap,cacheNodeInterop=new WeakMap;return(_getRequireWildcardCache=function(nodeInterop){return nodeInterop?cacheNodeInterop:cacheBabelInterop})(nodeInterop)}function _interopRequireWildcard(obj,nodeInterop){if(!nodeInterop&&obj&&obj.__esModule)return obj;if(null===obj||"object"!=typeof obj&&"function"!=typeof obj)return{default:obj};var cache=_getRequireWildcardCache(nodeInterop);if(cache&&cache.has(obj))return cache.get(obj);var newObj={},hasPropertyDescriptor=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var key in obj)if("default"!=key&&Object.prototype.hasOwnProperty.call(obj,key)){var desc=hasPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):null;desc&&(desc.get||desc.set)?Object.defineProperty(newObj,key,desc):newObj[key]=obj[key]}return newObj.default=obj,cache&&cache.set(obj,newObj),newObj}function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);enumerableOnly&&(symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable})),keys.push.apply(keys,symbols)}return keys}function _objectSpread(target){for(var source,i=1;i<arguments.length;i++)source=null==arguments[i]?{}:arguments[i],i%2?ownKeys(Object(source),!0).forEach(function(key){(0,_defineProperty2.default)(target,key,source[key])}):Object.getOwnPropertyDescriptors?Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)):ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key))});return target}/**
 * Attempt to describe intent via radspec.
 *
 * @param  {Object} intent transaction intent
 * @param  {Object} wrapper
 * @return {Promise<Object>} Decorated intent with description, if one could be made
 */async function tryEvaluatingRadspec(intent,wrapper){const apps=await wrapper.apps.pipe((0,_operators.first)()).toPromise(),app=apps.find(app=>(0,_utils.addressesEqual)(app.proxyAddress,intent.to)),appsToSearch=app?[app]:apps,foundMethod=appsToSearch.reduce((found,app)=>{if(found)return found;const method=(0,_apps.findAppMethodFromData)(app,intent.data);if(method)return{method,// This is not very nice, but some apps don't have ABIs attached to their function
// declarations and so we have to fall back to using their full app ABI
// TODO: define a more concrete schema around the artifact.json's `function.abi`
abi:method.abi?[method.abi]:app.abi}},void 0),{abi,method}=foundMethod||{};let evaluatedNotice;if(method&&method.notice)try{const network=await wrapper.network.pipe((0,_operators.first)()).toPromise();evaluatedNotice=await radspec.evaluate(method.notice,{abi,transaction:intent},{ethNode:wrapper.web3.currentProvider,currency:network.nativeCurrency})}catch(err){console.error(`Could not evaluate a description for given transaction data: ${intent.data}`,err)}return _objectSpread(_objectSpread({},intent),{},{description:evaluatedNotice})}/**
 * Attempt to describe a setApp() intent. Only describes the APP_BASE namespace.
 *
 * @param  {Object} intent transaction intent
 * @param  {Object} wrapper
 * @return {Promise<Object>} Decorated intent with description, if one could be made
 */async function tryDescribingUpdateAppIntent(intent,wrapper){const upgradeIntentParams=(await(0,_intents.filterAndDecodeAppUpgradeIntents)([intent],wrapper))[0];if(!upgradeIntentParams)return;const{appId,appAddress}=upgradeIntentParams,repoAddress=await wrapper.ens.resolve(appId),repo=(0,_repo.makeRepoProxy)(repoAddress,wrapper.web3),{version:latestVersion}=await(0,_repo.getRepoLatestVersionForContract)(repo,appAddress);// Fetch aragonPM information
return _objectSpread(_objectSpread({},intent),{},{description:`Upgrade ${appId} app instances to v${latestVersion}`})}/**
 * Attempt to parse a complete organization upgrade intent
 *
 * @param  {Array<Object>} intents intent basket
 * @param  {Object} wrapper
 * @return {Promise<Object>} Decorated intent with description, if one could be made
 */async function tryDescribingUpgradeOrganizationBasket(intents,wrapper){const upgradedKnownAppIds=(await(0,_intents.filterAndDecodeAppUpgradeIntents)(intents,wrapper)).map(_ref=>{let{appId}=_ref;return appId})// Take intersection with knownAppIds
.filter(appId=>_apps.knownAppIds.includes(appId));if(// All intents are for upgrading known apps
intents.length===upgradedKnownAppIds.length&&// All known apps are being upgraded
_apps.knownAppIds.length===upgradedKnownAppIds.length)return{description:"Upgrade organization to Aragon 0.8 Camino",from:intents[0].from,to:intents[0].to}}
//# sourceMappingURL=index.js.map