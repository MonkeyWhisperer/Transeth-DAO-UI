{"version":3,"sources":["../../../src/rpc/handlers/trigger.test.js"],"names":["test","afterEach","always","sinon","restore","t","plan","triggerContextMock","event","returnValues","data","appContextPoolStub","get","stub","withArgs","APP_CONTEXTS","TRIGGER","returns","result","params","address","appContextPool","emitIndex","subscribe","value","deepEqual","fail","newEventName","newEventData","emit","true","calledOnceWith","throwsAsync","message"],"mappings":"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","sourcesContent":["import test from 'ava'\nimport sinon from 'sinon'\nimport { of } from 'rxjs'\n\nimport { APP_CONTEXTS } from '../../apps'\nimport trigger from './trigger'\n\ntest.afterEach.always(() => {\n  sinon.restore()\n})\n\ntest(\"should return an observable for the app's triggers\", async (t) => {\n  t.plan(3)\n\n  // arrange\n  const appAddress = '0xABCD'\n  const triggerContextMock = of(\n    {\n      event: 'event1',\n      returnValues: {\n        data: 'data1'\n      }\n    },\n    {\n      event: 'event2',\n      returnValues: {\n        data: 'data2'\n      }\n    },\n    {\n      event: 'event3',\n      returnValues: {\n        data: 'data3'\n      }\n    }\n  )\n  const requestStub = {\n    params: ['observe']\n  }\n  const proxyStub = {\n    address: appAddress\n  }\n  const appContextPoolStub = {\n    get: sinon\n      .stub()\n      .withArgs(appAddress, APP_CONTEXTS.TRIGGER)\n      .returns(triggerContextMock)\n  }\n  const wrapperStub = {\n    appContextPool: appContextPoolStub\n  }\n\n  // act\n  const result = trigger(requestStub, proxyStub, wrapperStub)\n\n  // assert\n  let emitIndex = 0\n  result.subscribe(value => {\n    if (emitIndex === 0) {\n      t.deepEqual(value, {\n        event: 'event1',\n        returnValues: {\n          data: 'data1'\n        }\n      })\n    } else if (emitIndex === 1) {\n      t.deepEqual(value, {\n        event: 'event2',\n        returnValues: {\n          data: 'data2'\n        }\n      })\n    } else if (emitIndex === 2) {\n      t.deepEqual(value, {\n        event: 'event3',\n        returnValues: {\n          data: 'data3'\n        }\n      })\n    } else {\n      t.fail('too many emissions')\n    }\n\n    emitIndex++\n  })\n})\n\ntest('should emit trigger', async (t) => {\n  t.plan(1)\n\n  // arrange\n  const appAddress = '0xABCD'\n  const newEventName = 'newEvent'\n  const newEventData = 'newData'\n  const requestStub = {\n    params: ['emit', newEventName, newEventData]\n  }\n  const proxyStub = {\n    address: appAddress\n  }\n  const appContextPoolStub = {\n    emit: sinon.stub()\n  }\n  const wrapperStub = {\n    appContextPool: appContextPoolStub\n  }\n\n  // act\n  trigger(requestStub, proxyStub, wrapperStub)\n\n  // assert\n  t.true(appContextPoolStub.emit.calledOnceWith(\n    appAddress,\n    APP_CONTEXTS.TRIGGER,\n    {\n      event: newEventName,\n      returnValues: newEventData\n    }\n  ))\n})\n\ntest('should error on invalid trigger request', async (t) => {\n  t.plan(1)\n\n  // arrange\n  const appAddress = '0xABCD'\n  const requestStub = {\n    params: ['notHandled']\n  }\n  const proxyStub = {\n    address: appAddress\n  }\n\n  // assert\n  await t.throwsAsync(\n    trigger(requestStub, proxyStub),\n    { message: 'Invalid trigger operation' }\n  )\n})\n"],"file":"trigger.test.js"}