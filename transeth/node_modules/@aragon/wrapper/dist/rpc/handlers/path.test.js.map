{"version":3,"sources":["../../../src/rpc/handlers/path.test.js"],"names":["test","afterEach","always","sinon","restore","t","plan","pathContextMock","appContextPoolStub","get","stub","withArgs","APP_CONTEXTS","PATH","returns","result","params","address","appContextPool","emitIndex","subscribe","value","deepEqual","fail","newPath","mockResponseSymbol","Symbol","wrapperStub","requestAppPath","response","true","calledOnceWith","is","throwsAsync","message"],"mappings":"8RAOAA,aAAKC,SAAL,CAAeC,MAAf,CAAsB,IAAM,CAC1BC,eAAMC,OAAN,EACD,CAFD,C,CAIA,iBAAK,4DAAL,CAAmE,KAAOC,CAAAA,CAAP,EAAa,CAC9EA,CAAC,CAACC,IAAF,CAAO,CAAP,CAD8E,CAG9E;AAH8E,KAKxEC,CAAAA,eAAe,CAAG,aAAG,GAAH,CAAQ,QAAR,CAAkB,QAAlB,CALsD,CAYxEC,kBAAkB,CAAG,CACzBC,GAAG,CAAEN,eACFO,IADE,GAEFC,QAFE,UAEmBC,mBAAaC,IAFhC,EAGFC,OAHE,CAGMP,eAHN,CADoB,CAZmD,CAuBxEQ,MAAM,CAAG,kBAjBK,CAClBC,MAAM,CAAE,CAAC,SAAD,CADU,CAiBL,CAdG,CAChBC,OAAO,SADS,CAcH,CALK,CAClBC,cAAc,CAAEV,kBADE,CAKL,CAvB+D,CAyB9E;AACA,GAAIW,CAAAA,SAAS,CAAG,CAAhB,CACAJ,MAAM,CAACK,SAAP,CAAiBC,KAAK,EAAI,CACN,CAAd,GAAAF,SADoB,CAEtBd,CAAC,CAACiB,SAAF,CAAYD,KAAZ,CAAmB,GAAnB,CAFsB,CAGC,CAAd,GAAAF,SAHa,CAItBd,CAAC,CAACiB,SAAF,CAAYD,KAAZ,CAAmB,QAAnB,CAJsB,CAKC,CAAd,GAAAF,SALa,CAMtBd,CAAC,CAACiB,SAAF,CAAYD,KAAZ,CAAmB,QAAnB,CANsB,CAQtBhB,CAAC,CAACkB,IAAF,CAAO,oBAAP,CARsB,CAWxBJ,SAAS,EACV,CAZD,CAaD,CAxCD,C,CA0CA,iBAAK,mCAAL,CAA0C,KAAOd,CAAAA,CAAP,EAAa,CACrDA,CAAC,CAACC,IAAF,CAAO,CAAP,CADqD,CAGrD;AAHqD,KAK/CkB,CAAAA,OAAO,CAAG,MALqC,CAY/CC,kBAAkB,CAAGC,MAAM,CAAC,UAAD,CAZoB,CAa/CC,WAAW,CAAG,CAClBC,cAAc,CAAEzB,eAAMO,IAAN,GAAaI,OAAb,CAAqBW,kBAArB,CADE,CAbiC,CAkB/CI,QAAQ,CAAG,kBAZG,CAClBb,MAAM,CAAE,CAAC,QAAD,CAAWQ,OAAX,CADU,CAYH,CATC,CAChBP,OAAO,SADS,CASD,CAA6BU,WAA7B,CAlBoC,CAoBrD;AACAtB,CAAC,CAACyB,IAAF,CAAOH,WAAW,CAACC,cAAZ,CAA2BG,cAA3B,UAAsDP,OAAtD,CAAP,CArBqD,CAsBrDnB,CAAC,CAAC2B,EAAF,CAAKH,QAAL,CAAeJ,kBAAf,CACD,CAvBD,C,CAyBA,iBAAK,sCAAL,CAA6C,KAAOpB,CAAAA,CAAP,EAAa,CACxDA,CAAC,CAACC,IAAF,CAAO,CAAP,CADwD,CAYxD;AACA,KAAMD,CAAAA,CAAC,CAAC4B,WAAF,CACJ,kBATkB,CAClBjB,MAAM,CAAE,CAAC,YAAD,CADU,CASlB,CANgB,CAChBC,OAAO,SADS,CAMhB,CADI,CAEJ,CAAEiB,OAAO,CAAE,wBAAX,CAFI,CAIP,CAjBD,C","sourcesContent":["import test from 'ava'\nimport sinon from 'sinon'\nimport { of } from 'rxjs'\n\nimport { APP_CONTEXTS } from '../../apps'\nimport path from './path'\n\ntest.afterEach.always(() => {\n  sinon.restore()\n})\n\ntest(\"should return an observable for the app's paths on observe\", async (t) => {\n  t.plan(3)\n\n  // arrange\n  const appAddress = '0xABCD'\n  const pathContextMock = of('/', '/page1', '/page2')\n  const requestStub = {\n    params: ['observe']\n  }\n  const proxyStub = {\n    address: appAddress\n  }\n  const appContextPoolStub = {\n    get: sinon\n      .stub()\n      .withArgs(appAddress, APP_CONTEXTS.PATH)\n      .returns(pathContextMock)\n  }\n  const wrapperStub = {\n    appContextPool: appContextPoolStub\n  }\n\n  // act\n  const result = path(requestStub, proxyStub, wrapperStub)\n\n  // assert\n  let emitIndex = 0\n  result.subscribe(value => {\n    if (emitIndex === 0) {\n      t.deepEqual(value, '/')\n    } else if (emitIndex === 1) {\n      t.deepEqual(value, '/page1')\n    } else if (emitIndex === 2) {\n      t.deepEqual(value, '/page2')\n    } else {\n      t.fail('too many emissions')\n    }\n\n    emitIndex++\n  })\n})\n\ntest('should request app path on modify', async (t) => {\n  t.plan(2)\n\n  // arrange\n  const appAddress = '0xABCD'\n  const newPath = '/new'\n  const requestStub = {\n    params: ['modify', newPath]\n  }\n  const proxyStub = {\n    address: appAddress\n  }\n  const mockResponseSymbol = Symbol('response')\n  const wrapperStub = {\n    requestAppPath: sinon.stub().returns(mockResponseSymbol)\n  }\n\n  // act\n  const response = path(requestStub, proxyStub, wrapperStub)\n\n  // assert\n  t.true(wrapperStub.requestAppPath.calledOnceWith(appAddress, newPath))\n  t.is(response, mockResponseSymbol)\n})\n\ntest('should error on invalid path request', async (t) => {\n  t.plan(1)\n\n  // arrange\n  const appAddress = '0xABCD'\n  const requestStub = {\n    params: ['notHandled']\n  }\n  const proxyStub = {\n    address: appAddress\n  }\n\n  // assert\n  await t.throwsAsync(\n    path(requestStub, proxyStub),\n    { message: 'Invalid path operation' }\n  )\n})\n"],"file":"path.test.js"}