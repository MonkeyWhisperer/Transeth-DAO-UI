"use strict";var _interopRequireDefault=require("@babel/runtime/helpers/interopRequireDefault"),_ava=_interopRequireDefault(require("ava")),_sinon=_interopRequireDefault(require("sinon")),_rxjs=require("rxjs"),_apps=require("../../apps"),_trigger=_interopRequireDefault(require("./trigger"));_ava.default.afterEach.always(()=>{_sinon.default.restore()}),(0,_ava.default)("should return an observable for the app's triggers",async t=>{t.plan(3);// arrange
const triggerContextMock=(0,_rxjs.of)({event:"event1",returnValues:{data:"data1"}},{event:"event2",returnValues:{data:"data2"}},{event:"event3",returnValues:{data:"data3"}}),appContextPoolStub={get:_sinon.default.stub().withArgs("0xABCD",_apps.APP_CONTEXTS.TRIGGER).returns(triggerContextMock)},result=(0,_trigger.default)({params:["observe"]},{address:"0xABCD"},{appContextPool:appContextPoolStub});// assert
let emitIndex=0;result.subscribe(value=>{0===emitIndex?t.deepEqual(value,{event:"event1",returnValues:{data:"data1"}}):1===emitIndex?t.deepEqual(value,{event:"event2",returnValues:{data:"data2"}}):2===emitIndex?t.deepEqual(value,{event:"event3",returnValues:{data:"data3"}}):t.fail("too many emissions"),emitIndex++})}),(0,_ava.default)("should emit trigger",async t=>{t.plan(1);// arrange
const newEventName="newEvent",newEventData="newData",appContextPoolStub={emit:_sinon.default.stub()};// act
// assert
(0,_trigger.default)({params:["emit",newEventName,newEventData]},{address:"0xABCD"},{appContextPool:appContextPoolStub}),t.true(appContextPoolStub.emit.calledOnceWith("0xABCD",_apps.APP_CONTEXTS.TRIGGER,{event:newEventName,returnValues:newEventData}))}),(0,_ava.default)("should error on invalid trigger request",async t=>{t.plan(1);// assert
await t.throwsAsync((0,_trigger.default)({params:["notHandled"]},{address:"0xABCD"}),{message:"Invalid trigger operation"})});
//# sourceMappingURL=trigger.test.js.map