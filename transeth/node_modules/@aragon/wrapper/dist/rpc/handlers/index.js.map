{"version":3,"sources":["../../../src/rpc/handlers/index.js"],"names":["createResponse","request","id","error","value","kind","payload","signals","COMPLETE","Error","createRequestHandler","request$","requestType","handler","filteredRequest$","pipe","method","proxy","wrapper","response","combineRequestHandlers","handlers"],"mappings":"oJA6duB;+gHAzdhB,QAASA,CAAAA,cAAT,CAAyB,CAAEC,OAAO,CAAE,CAAEC,EAAF,CAAX,CAAzB,CAA8C,CAAEC,KAAF,CAASC,KAAK,CAAG,IAAjB,CAAuBC,IAAvB,CAA9C,CAA6E,OACrE,GAAT,GAAAA,IAD8E,CAEzE,CAAEH,EAAF,CAAMI,OAAO,CAAEC,sBAAQC,QAAvB,CAFyE,CAKrE,GAAT,GAAAH,IAL8E,CAMzE,CAAEH,EAAF,CAAMI,OAAO,CAAEH,KAAK,EAAI,GAAIM,CAAAA,KAA5B,CANyE,CAS3E,CAAEP,EAAF,CAAMI,OAAO,CAAEF,KAAf,CACR,CAEM,QAASM,CAAAA,oBAAT,CAA+BC,QAA/B,CAAyCC,WAAzC,CAAsDC,OAAtD,CAA+D,CACpE;AACA,KAAMC,CAAAA,gBAAgB,CAAGH,QAAQ,CAACI,IAAT,CACvB,sBAAO,CAAC,CAAEd,OAAF,CAAD,GAAiBA,OAAO,CAACe,MAAR,GAAmBJ,WAA3C,CADuB,CAAzB,CAIA;AACA,MAAOE,CAAAA,gBAAgB,CAACC,IAAjB,CACL;;;;;OAMA,wBACE,CAAC,CAAEd,OAAF,CAAWgB,KAAX,CAAkBC,OAAlB,CAAD,GACS,eAAKL,OAAO,CAACZ,OAAD,CAAUgB,KAAV,CAAiBC,OAAjB,CAAZ,EAAuCH,IAAvC,CAA4C,4BAA5C,CAFX,CAIEf,cAJF,CAPK,CAaL;AACA,sBAAQmB,QAAD,EAAcA,QAAQ,CAACb,OAAT,SAArB,CAdK,CAgBR,CAEM,QAASc,CAAAA,sBAAT,CAAiC,GAAGC,QAApC,CAA8C,CACnD,MAAO,gBACL,GAAGA,QADE,CAGR,CAED","sourcesContent":["import { from, merge } from 'rxjs'\nimport { filter, mergeMap, materialize } from 'rxjs/operators'\nimport { signals } from '@aragon/rpc-messenger'\n\nexport function createResponse ({ request: { id } }, { error, value = null, kind }) {\n  if (kind === 'C') {\n    return { id, payload: signals.COMPLETE }\n  }\n\n  if (kind === 'E') {\n    return { id, payload: error || new Error() }\n  }\n\n  return { id, payload: value }\n}\n\nexport function createRequestHandler (request$, requestType, handler) {\n  // Filter request types to match provided params\n  const filteredRequest$ = request$.pipe(\n    filter(({ request }) => request.method === requestType)\n  )\n\n  // Send request to handler and return response\n  return filteredRequest$.pipe(\n    /**\n     * Turn the promise returned by the handler into an observable and materialize it, i.e:\n     * - if the observable emits, emit a Notification of kind 'N' (next) with a value property\n     * - if the observable rejects, emit a Notification of kind 'E' with an error property\n     * - if the observable completes, emit a Notification of kind 'C' (complete)\n     */\n    mergeMap(\n      ({ request, proxy, wrapper }) => {\n        return from(handler(request, proxy, wrapper)).pipe(materialize())\n      },\n      createResponse\n    ),\n    // TODO: instead of filtering, log if a payload is undefined\n    filter((response) => response.payload !== undefined)\n  )\n}\n\nexport function combineRequestHandlers (...handlers) {\n  return merge(\n    ...handlers\n  )\n}\n\n// Export request handlers\nexport { default as accounts } from './accounts'\nexport { default as cache } from './cache'\nexport { default as describeScript } from './describe-script'\nexport { default as describeTransaction } from './describe-transaction'\nexport { default as getApps } from './get-apps'\nexport { default as network } from './network'\nexport { default as path } from './path'\nexport { default as guiStyle } from './gui-style'\nexport { default as trigger } from './trigger'\nexport { default as web3Eth } from './web3-eth'\n\nexport { default as intent } from './intent'\nexport { default as call } from './call'\nexport { default as signMessage } from './sign-message'\nexport { default as events } from './events'\nexport { default as pastEvents } from './past-events'\n\nexport { intent as externalIntent } from './external'\nexport { call as externalCall } from './external'\nexport { events as externalEvents } from './external'\nexport { pastEvents as externalPastEvents } from './external'\n\nexport { default as addressIdentity } from './address-identity'\nexport { default as appIdentifier } from './app-identifier'\nexport { default as searchIdentities } from './search-identities'\n"],"file":"index.js"}