"use strict";var _interopRequireDefault=require("@babel/runtime/helpers/interopRequireDefault"),_ava=_interopRequireDefault(require("ava")),_proxyquire=_interopRequireDefault(require("proxyquire")),_sinon=_interopRequireDefault(require("sinon")),_events=require("events"),configurationKeys=_interopRequireWildcard(require("../../configuration/keys")),eventsUtils=_interopRequireWildcard(require("../../utils/events"));function _getRequireWildcardCache(nodeInterop){if("function"!=typeof WeakMap)return null;var cacheBabelInterop=new WeakMap,cacheNodeInterop=new WeakMap;return(_getRequireWildcardCache=function(nodeInterop){return nodeInterop?cacheNodeInterop:cacheBabelInterop})(nodeInterop)}function _interopRequireWildcard(obj,nodeInterop){if(!nodeInterop&&obj&&obj.__esModule)return obj;if(null===obj||"object"!=typeof obj&&"function"!=typeof obj)return{default:obj};var cache=_getRequireWildcardCache(nodeInterop);if(cache&&cache.has(obj))return cache.get(obj);var newObj={},hasPropertyDescriptor=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var key in obj)if("default"!=key&&Object.prototype.hasOwnProperty.call(obj,key)){var desc=hasPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):null;desc&&(desc.get||desc.set)?Object.defineProperty(newObj,key,desc):newObj[key]=obj[key]}return newObj.default=obj,cache&&cache.set(obj,newObj),newObj}_ava.default.beforeEach(t=>{const configurationStub={getConfiguration:_sinon.default.stub()},utilsStub={events:eventsUtils},external=(0,_proxyquire.default)("./external",{"../../configuration":configurationStub,"../../utils":utilsStub});t.context={external,configurationStub,utilsStub}}),_ava.default.afterEach.always(()=>{_sinon.default.restore()}),(0,_ava.default)("should return the correct tx path from external tx intent",async t=>{const{external}=t.context,targetAddr="0x123",targetMethodAbiFragment=[{name:"foo"}],targetParams=[8],mockPath=[{to:"0x123",data:"0x456"}];t.plan(3);// arrange
const wrapperStub={getExternalTransactionPath:_sinon.default.stub().returns(mockPath),performTransactionPath:_sinon.default.stub().returns(Promise.resolve())},requestStub={params:[targetAddr,targetMethodAbiFragment,...targetParams]},result=external.intent(requestStub,null,wrapperStub);// assert
await t.notThrowsAsync(result),t.true(wrapperStub.getExternalTransactionPath.calledOnceWith(targetAddr,targetMethodAbiFragment,targetParams)),t.true(wrapperStub.performTransactionPath.calledOnceWith(mockPath,{external:!0// force cache invalidation
}))}),(0,_ava.default)("should return an observable from the contract events",async t=>{const{external}=t.context;t.plan(2);// arrange
const eventEmitter=new _events.EventEmitter,eventsStub=_sinon.default.stub().returns(eventEmitter),web3Stub={eth:{Contract:_sinon.default.stub().returns({events:{allEvents:eventsStub}})}},events=external.events({params:["addr","ji","allEvents",{fromBlock:8}]},{},{web3:web3Stub});// assert
t.true(eventsStub.calledOnceWith({fromBlock:8})),events.subscribe(value=>{t.deepEqual(value,{event:"pay_fee",amount:5})}),eventEmitter.emit("data",{event:"pay_fee",amount:5})}),(0,_ava.default)("should default fetching contract events from app's initialization block",async t=>{const{external}=t.context,initBlock=10;t.plan(2);// arrange
const eventEmitter=new _events.EventEmitter,eventsStub=_sinon.default.stub().returns(eventEmitter),web3Stub={eth:{Contract:_sinon.default.stub().returns({events:{allEvents:eventsStub}})}},events=external.events({params:["addr","ji","allEvents",{}]},{initializationBlock:initBlock},{web3:web3Stub});// assert
t.true(eventsStub.calledOnceWith({fromBlock:initBlock})),events.subscribe(value=>{t.deepEqual(value,{event:"pay_fee",amount:5})}),eventEmitter.emit("data",{event:"pay_fee",amount:5})}),(0,_ava.default)("should handle events for aragonAPIv1",async t=>{const{external}=t.context,fromBlock=10;t.plan(2);// arrange
const eventEmitter=new _events.EventEmitter,eventsStub=_sinon.default.stub().returns(eventEmitter),web3Stub={eth:{Contract:_sinon.default.stub().returns({events:{allEvents:eventsStub}})}},events=external.events({params:["addr","ji",fromBlock]},{},{web3:web3Stub});// assert
t.true(eventsStub.calledOnceWith({fromBlock})),events.subscribe(value=>{t.deepEqual(value,{event:"pay_fee",amount:5})}),eventEmitter.emit("data",{event:"pay_fee",amount:5})}),(0,_ava.default)("should handle events without fromBlock for aragonAPIv1",async t=>{const{external}=t.context,initBlock=10;t.plan(2);// arrange
const eventEmitter=new _events.EventEmitter,eventsStub=_sinon.default.stub().returns(eventEmitter),web3Stub={eth:{Contract:_sinon.default.stub().returns({events:{allEvents:eventsStub}})}},events=external.events({params:["addr","ji"]},{initializationBlock:initBlock},{web3:web3Stub});// assert
t.true(eventsStub.calledOnceWith({fromBlock:initBlock})),events.subscribe(value=>{t.deepEqual(value,{event:"pay_fee",amount:5})}),eventEmitter.emit("data",{event:"pay_fee",amount:5})}),(0,_ava.default)("should return an observable from the contract's past events",async t=>{const{external}=t.context;t.plan(2);// arrange
const contract={getPastEvents:_sinon.default.stub().returns([{event:"pay_fee",amount:5}])},web3Stub={eth:{Contract:_sinon.default.stub().withArgs("addr","ji").returns(contract)}},result=external.pastEvents({params:["addr","ji","allEvents",{fromBlock:8}]},{},{web3:web3Stub});// assert
t.true(contract.getPastEvents.calledOnceWith("allEvents",{fromBlock:8})),result.subscribe(value=>{t.deepEqual(value,{event:"pay_fee",amount:5})})}),(0,_ava.default)("should default fetching past events starting from app's initialization block",async t=>{const{external}=t.context,initBlock=10;t.plan(2);// arrange
const contract={getPastEvents:_sinon.default.stub().returns([{event:"pay_fee",amount:5}])},web3Stub={eth:{Contract:_sinon.default.stub().withArgs("addr","ji").returns(contract)}},result=external.pastEvents({params:["addr","ji","allEvents",{}]},{initializationBlock:initBlock},{web3:web3Stub});// assert
t.true(contract.getPastEvents.calledOnceWith("allEvents",{fromBlock:initBlock})),result.subscribe(value=>{t.deepEqual(value,{event:"pay_fee",amount:5})})}),(0,_ava.default)("should handle past events for aragonAPIv1",async t=>{const{external}=t.context,initBlock=10,toBlock=18;t.plan(2);// arrange
const contract={getPastEvents:_sinon.default.stub().returns([{event:"pay_fee",amount:5}])},web3Stub={eth:{Contract:_sinon.default.stub().withArgs("addr","ji").returns(contract)}},result=external.pastEvents({params:["addr","ji",{toBlock}]},{initializationBlock:initBlock},{web3:web3Stub});// assert
t.true(contract.getPastEvents.calledOnceWith("allEvents",{fromBlock:initBlock,toBlock})),result.subscribe(value=>{t.deepEqual(value,{event:"pay_fee",amount:5})})}),(0,_ava.default)("should not apply a delay to events if not configured",async t=>{const{external,configurationStub}=t.context;t.plan(2);// arrange
const eventEmitter=new _events.EventEmitter,contract={events:{allEvents:_sinon.default.stub().returns(eventEmitter)}},web3Stub={eth:{Contract:_sinon.default.stub().returns(contract)}};configurationStub.getConfiguration.withArgs(configurationKeys.SUBSCRIPTION_EVENT_DELAY).returns(0);const events=external.events({params:["addr","ji",8]},{},{web3:web3Stub}),startTime=Date.now();// assert
events.subscribe(value=>{// Hard to say exactly how much time this will take, but 20ms seems safe
// (this should be immediate)
t.deepEqual(value,{event:"pay_fee",amount:5}),t.true(20>Date.now()-startTime)}),eventEmitter.emit("data",{event:"pay_fee",amount:5})}),(0,_ava.default)("should apply a delay to events if configured",async t=>{const{external,configurationStub}=t.context,delayTime=1e3;t.plan(2);// arrange
const eventEmitter=new _events.EventEmitter,contract={events:{allEvents:_sinon.default.stub().returns(eventEmitter)}},web3Stub={eth:{Contract:_sinon.default.stub().returns(contract)}};configurationStub.getConfiguration.withArgs(configurationKeys.SUBSCRIPTION_EVENT_DELAY).returns(delayTime);const events=external.events({params:["addr","ji",8]},{},{web3:web3Stub});// assert
// Since we've added the delay, we need to tell ava to wait until we're done subscribing
return new Promise(resolve=>{const startTime=Date.now();events.subscribe(value=>{t.deepEqual(value,{event:"pay_fee",amount:5}),t.true(Date.now()-startTime>delayTime),resolve()}),eventEmitter.emit("data",{event:"pay_fee",amount:5})})});
//# sourceMappingURL=external.test.js.map