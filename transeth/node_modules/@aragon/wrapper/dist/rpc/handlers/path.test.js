"use strict";var _interopRequireDefault=require("@babel/runtime/helpers/interopRequireDefault"),_ava=_interopRequireDefault(require("ava")),_sinon=_interopRequireDefault(require("sinon")),_rxjs=require("rxjs"),_apps=require("../../apps"),_path=_interopRequireDefault(require("./path"));_ava.default.afterEach.always(()=>{_sinon.default.restore()}),(0,_ava.default)("should return an observable for the app's paths on observe",async t=>{t.plan(3);// arrange
const pathContextMock=(0,_rxjs.of)("/","/page1","/page2"),appContextPoolStub={get:_sinon.default.stub().withArgs("0xABCD",_apps.APP_CONTEXTS.PATH).returns(pathContextMock)},result=(0,_path.default)({params:["observe"]},{address:"0xABCD"},{appContextPool:appContextPoolStub});// assert
let emitIndex=0;result.subscribe(value=>{0===emitIndex?t.deepEqual(value,"/"):1===emitIndex?t.deepEqual(value,"/page1"):2===emitIndex?t.deepEqual(value,"/page2"):t.fail("too many emissions"),emitIndex++})}),(0,_ava.default)("should request app path on modify",async t=>{t.plan(2);// arrange
const newPath="/new",mockResponseSymbol=Symbol("response"),wrapperStub={requestAppPath:_sinon.default.stub().returns(mockResponseSymbol)},response=(0,_path.default)({params:["modify",newPath]},{address:"0xABCD"},wrapperStub);// assert
t.true(wrapperStub.requestAppPath.calledOnceWith("0xABCD",newPath)),t.is(response,mockResponseSymbol)}),(0,_ava.default)("should error on invalid path request",async t=>{t.plan(1);// assert
await t.throwsAsync((0,_path.default)({params:["notHandled"]},{address:"0xABCD"}),{message:"Invalid path operation"})});
//# sourceMappingURL=path.test.js.map