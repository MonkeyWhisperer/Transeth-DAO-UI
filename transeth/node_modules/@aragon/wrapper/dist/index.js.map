{"version":3,"sources":["../src/index.js"],"names":["detectProvider","web3","currentProvider","Aragon","constructor","daoAddress","options","defaultOptions","defaultGasPriceFn","provider","cache","forceLocalStorage","prefix","events","subscriptionDelayTime","Object","assign","configurationKeys","FORCE_LOCAL_STORAGE","SUBSCRIPTION_EVENT_DELAY","Number","isFinite","subscriptionEventDelay","Web3","ens","apm","ensRegistryAddress","ipfs","apmIpfsOptions","fetchTimeout","ipfsGateway","gateway","kernelProxy","cachePrefix","Cache","appContextPool","AppContextPool","init","aclAddress","call","_","Error","updateInitializationBlock","initAccounts","accounts","initAcl","acl","initIdentityProviders","initApps","initForwarders","initAppIdentifiers","initNetwork","network","initGuiStyle","guiStyle","pathIntents","Subject","transactions","signatures","fetchFromWeb3","providedAccounts","ReplaySubject","concat","eth","getAccounts","setAccounts","aclProxy","initializationBlock","ACL_CACHE_KEY","currentBlock","getBlockNumber","cacheBlockHeight","Math","max","cachedAclState","get","permissions","cachedPermissions","blockNumber","cachedBlockNumber","pastEventsOptions","toBlock","fromBlock","pastEvents$","pastEvents","pipe","event","returnValues","currentEvents$","fetchedPermissions$","eventData","app","appPermissions","key","role","allowedEntitiesSet","Set","dotprop","allowed","add","entity","delete","set","Array","from","manager","connect","cachedPermissions$","isApp","kernelAddress","isKernelAddress","address","applicationInfoCache","AsyncRequestCache","cacheKey","appId","codeAddress","split","fetchLatestRepoContentForContract","resolve","proxyContractValueCache","proxyAddress","Promise","all","then","values","appProxy","appProxyForwarder","catch","isForwarder","installedApps$","keys","oldProxies","newProxies","length","oldSet","intersection","filter","newProxy","has","size","proxyAddresses","appsWithoutKernel","map","proxyValues","request","appProxies","updatedApps$","namespace","setAppEvent","apps","setAppId","updated","updatedApps","apps$","appsWithInfo$","appInfo","isForwarderOverride","isArray","abi","some","type","name","installedRepoCache","Map","repo$","reduce","installedRepos","contractAddress","repos","newRepoAppIds","updatedRepoAppIds","forEach","repo","push","newRepos","repoProxy","repoAddress","err","console","error","update$","newRepo$","repoAddress$","version$","initialVersions","versionId","eventVersionId","timestamp","getBlock","versionIndex","findIndex","versionInfo","versions","newVersionInfo","newVersions","repoUpdate","updatedAppId","update","updatedRepoInfo","updatedRepoAppId","installedRepoInfo","baseRepoInfo","fetchVersionInfo","version","content","latestVersion","currentVersion","reverse","find","currentVersionInfoRequest","latestVersionInfoRequest","updatedRepo","repoIndex","nextRepos","asyncScheduler","leading","trailing","forwarders","appIdentifiers","BehaviorSubject","identifiers","identifier","setAppIdentifier","next","defaultIdentityProviders","LocalIdentityProvider","identityProviders","identityProviderRegistrar","identityIntents","modifyAddressIdentity","metadata","modify","reject","resolveAddressIdentity","searchIdentities","searchTerm","search","requestAddressIdentityModification","providerName","removeLocalIdentities","addresses","localProvider","remove","getLocalIdentities","getAll","appearance","theme","setGuiStyle","id","getChainId","net","getNetworkType","requestAppPath","appAddress","path","getApp","setAppPath","emit","APP_CONTEXTS","PATH","runApp","toPromise","sandboxMessengerProvider","messenger","Messenger","request$","requests","proxy","wrapper","handlerSubscription","handlers","combineRequestHandlers","createRequestHandler","describeScript","describeTransaction","getApps","trigger","web3Eth","intent","signMessage","externalCall","externalEvents","externalIntent","externalPastEvents","appIdentifier","addressIdentity","subscribe","response","sendResponse","payload","shutdown","unsubscribe","shutdownAndClearCache","promise","startsWith","message","requestingApp","performTransactionPath","transactionPath","external","transaction","performACLIntent","method","params","getACLTransactionPath","getTransactionPath","destination","methodSignature","finalForwarder","account","calculateTransactionPath","describeTransactionPath","getExternalTransactionPath","methodAbiFragment","installedApp","tx","getTransactionPathForIntentBasket","intentBasket","checkMode","intentsToCheck","intentPaths","pathsMatch","sender","directTransactions","decoratedTransactions","applyTransactionGas","createForwarderTransaction","forwarderPath","slice","to","nextForwarder","lastStep","encodedLastStep","getPermissionManager","roleHash","aclAddr","allowDeprecated","roles","inputNames","inputs","input","appIndex","indexOf","roleIndex","decodeTransactionPath","script","segment","data","forwardedEvmScript","children","step","decoratedStep","description","processed","annotatedDescription","canForward","forwarder","Contract","methods","getDefaultGasPrice","gasLimit","isForwarding","pretransaction","estimatedGasLimit","estimateGas","gas","recommendedGasLimit","gasPrice","directTransaction","finalForwarderProvided","forwardersWithPermission","destinationPermissions","roleSig","bytes","allowedEntities","ANY_ENTITY","calculateForwardingPath","transactionWithFee","queue","forwarderWithPermission","nextQueue","shift","previousForwarder"],"mappings":"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","sourcesContent":["// Externals\nimport { asyncScheduler, concat, from, merge, of, BehaviorSubject, ReplaySubject, Subject } from 'rxjs'\nimport {\n  concatMap,\n  debounceTime,\n  distinctUntilChanged,\n  endWith,\n  filter,\n  first,\n  map,\n  mergeAll,\n  mergeMap,\n  publishReplay,\n  scan,\n  startWith,\n  switchMap,\n  throttleTime,\n  withLatestFrom\n} from 'rxjs/operators'\nimport Web3 from 'web3'\nimport { isAddress } from 'web3-utils'\nimport dotprop from 'dot-prop'\n\n// RPC\nimport Messenger from '@aragon/rpc-messenger'\nimport * as handlers from './rpc/handlers'\n\nimport AppContextPool, { APP_CONTEXTS } from './apps'\nimport Cache from './cache'\nimport apm, { getApmInternalAppInfo } from './core/apm'\nimport { makeRepoProxy, getAllRepoVersions, getRepoVersionById } from './core/apm/repo'\nimport {\n  getAragonOsInternalAppInfo,\n  isAragonOsInternalApp\n} from './core/aragonOS'\nimport { isKernelAppCodeNamespace } from './core/aragonOS/kernel'\nimport { setConfiguration } from './configuration'\nimport * as configurationKeys from './configuration/keys'\nimport ens from './ens'\nimport { LocalIdentityProvider } from './identity'\nimport { getAbi } from './interfaces'\nimport {\n  postprocessRadspecDescription,\n  tryDescribingUpdateAppIntent,\n  tryDescribingUpgradeOrganizationBasket,\n  tryEvaluatingRadspec\n} from './radspec'\nimport {\n  ANY_ENTITY,\n  addressesEqual,\n  getCacheKey,\n  includesAddress,\n  makeAddressMapProxy,\n  makeProxy,\n  makeProxyFromAppABI,\n  AsyncRequestCache\n} from './utils'\nimport { findMethodAbiFragment } from './utils/abi'\nimport { findAppMethodFromSignature } from './utils/apps'\nimport { decodeCallScript, encodeCallScript, isCallScript } from './utils/callscript'\nimport { isValidForwardCall, parseForwardCall } from './utils/forwarding'\nimport { doIntentPathsMatch } from './utils/intents'\nimport {\n  applyForwardingFeePretransaction,\n  createDirectTransaction,\n  createDirectTransactionForApp,\n  createForwarderTransactionBuilder,\n  getRecommendedGasLimit\n} from './utils/transactions'\n\n// Try to get an injected web3 provider, return a public one otherwise.\nexport const detectProvider = () =>\n  typeof web3 !== 'undefined'\n    ? web3.currentProvider // eslint-disable-line\n    : 'wss://rinkeby.eth.aragon.network/ws'\n\n/**\n * An Aragon wrapper.\n *\n * @param {string} daoAddress\n *        The address of the DAO.\n * @param {Object} options\n *        Wrapper options.\n * @param {Object} options.apm\n *        Options for fetching information from aragonPM\n * @param {string} options.apm.ensRegistryAddress\n *        ENS registry for aragonPM\n * @param {Object} [options.apm.ipfs]\n *        IPFS provider config for aragonPM\n * @param {string} [options.apm.ipfs.gateway]\n *        IPFS gateway to fetch aragonPM artifacts from\n * @param {number} [options.apm.ipfs.fetchTimeout]\n *        Timeout for retrieving aragonPM artifacts from IPFS before failing\n * @param {Object} [options.cache]\n *        Options for the internal cache\n * @param {boolean} [options.cache.forceLocalStorage=false]\n *        Downgrade to localStorage even if IndexedDB is available\n * @param {Object} [options.events]\n *        Options for handling Ethereum events\n * @param {boolean} [options.events.subscriptionEventDelay]\n *        Time in ms to delay a new event from a contract subscription\n * @param {Function} [options.defaultGasPriceFn=function]\n *        A factory function to provide the default gas price for transactions.\n *        It can return a promise of number string or a number string. The function\n *        has access to a recommended gas limit which can be used for custom\n *        calculations. This function can also be used to get a good gas price\n *        estimation from a 3rd party resource.\n * @param {string|Object} [options.provider=web3.currentProvider]\n *        The Web3 provider to use for blockchain communication. Defaults to `web3.currentProvider`\n *        if web3 is injected, otherwise will fallback to wss://rinkeby.eth.aragon.network/ws\n */\nexport default class Aragon {\n  constructor (daoAddress, options = {}) {\n    const defaultOptions = {\n      defaultGasPriceFn: () => {},\n      provider: detectProvider(),\n      cache: {\n        forceLocalStorage: false,\n        prefix: null\n      },\n      events: {\n        subscriptionDelayTime: 0\n      }\n    }\n    options = Object.assign(defaultOptions, options)\n\n    // Set up desired configuration\n    setConfiguration(\n      configurationKeys.FORCE_LOCAL_STORAGE,\n      !!(options.cache && options.cache.forceLocalStorage)\n    )\n    setConfiguration(\n      configurationKeys.SUBSCRIPTION_EVENT_DELAY,\n      Number.isFinite(options.events && options.events.subscriptionEventDelay)\n        ? options.events.subscriptionEventDelay\n        : 0\n    )\n\n    // Set up Web3\n    this.web3 = new Web3(options.provider)\n\n    // Set up ENS\n    this.ens = ens(options.provider, options.apm.ensRegistryAddress)\n\n    // Set up APM utilities\n    const { ipfs: apmIpfsOptions = {} } = options.apm\n    this.apm = apm(\n      this.web3,\n      {\n        fetchTimeout: apmIpfsOptions.fetchTimeout,\n        ipfsGateway: apmIpfsOptions.gateway\n      }\n    )\n\n    // Set up the kernel proxy\n    this.kernelProxy = makeProxy(daoAddress, 'Kernel', this.web3)\n\n    // Set up cache\n    const cachePrefix = options.cache.prefix ? `${options.cache.prefix}:${daoAddress}` : daoAddress\n    this.cache = new Cache(cachePrefix)\n\n    // Set up app contexts\n    this.appContextPool = new AppContextPool()\n\n    this.defaultGasPriceFn = options.defaultGasPriceFn\n  }\n\n  /**\n   * Initialise the wrapper.\n   *\n   * @param {Object} [options] Options\n   * @param {Object} [options.accounts] `initAccount()` options (see below)\n   * @param {Object} [options.acl] `initACL()` options (see below)\n   * @param {Object} [options.guiStyle] `initGuiStyle()` options (see below)\n   * @return {Promise<void>}\n   * @throws {Error} Will throw an error if the `daoAddress` is detected to not be a Kernel instance\n   */\n  async init (options = {}) {\n    let aclAddress\n\n    try {\n      // Check if address is kernel\n      // web3 throws if it's an empty address ('0x')\n      aclAddress = await this.kernelProxy.call('acl')\n    } catch (_) {\n      throw Error(`Provided daoAddress is not a DAO`)\n    }\n\n    await this.cache.init()\n    await this.kernelProxy.updateInitializationBlock()\n    await this.initAccounts(options.accounts)\n    await this.initAcl(Object.assign({ aclAddress }, options.acl))\n    await this.initIdentityProviders()\n    this.initApps()\n    this.initForwarders()\n    this.initAppIdentifiers()\n    this.initNetwork(options.network)\n    this.initGuiStyle(options.guiStyle)\n    this.pathIntents = new Subject()\n    this.transactions = new Subject()\n    this.signatures = new Subject()\n  }\n\n  /**\n   * Initialise the accounts observable.\n   *\n   * @param {Object} [options] Options\n   * @param {boolean} [options.fetchFromWeb3] Whether or not accounts should also be fetched from\n   *                                          the provided Web3 instance\n   * @param {Array<string>} [options.providedAccounts] Array of accounts that the user controls\n   * @return {Promise<void>}\n   */\n  async initAccounts ({ fetchFromWeb3, providedAccounts = [] } = {}) {\n    this.accounts = new ReplaySubject(1)\n    const accounts = fetchFromWeb3\n      ? providedAccounts.concat(await this.web3.eth.getAccounts())\n      : providedAccounts\n\n    this.setAccounts(accounts)\n  }\n\n  /**\n   * Initialise the ACL (Access Control List).\n   *\n   * @return {Promise<void>}\n   */\n  async initAcl ({ aclAddress } = {}) {\n    if (!aclAddress) {\n      aclAddress = await this.kernelProxy.call('acl')\n    }\n\n    // Set up ACL proxy\n    this.aclProxy = makeProxy(aclAddress, 'ACL', this.web3, { initializationBlock: this.kernelProxy.initializationBlock })\n\n    const SET_PERMISSION_EVENT = 'SetPermission'\n    const CHANGE_PERMISSION_MANAGER_EVENT = 'ChangePermissionManager'\n\n    const ACL_CACHE_KEY = getCacheKey(aclAddress, 'acl')\n\n    const REORG_SAFETY_BLOCK_AGE = 100\n\n    const currentBlock = await this.web3.eth.getBlockNumber()\n    const cacheBlockHeight = Math.max(currentBlock - REORG_SAFETY_BLOCK_AGE, 0) // clamp to 0 for safety\n\n    // Check if we have cached ACL for this address\n    // Cache object for an ACL: { permissions, blockNumber }\n    const cachedAclState = await this.cache.get(ACL_CACHE_KEY, {})\n    const { permissions: cachedPermissions, blockNumber: cachedBlockNumber } = cachedAclState\n\n    const pastEventsOptions = {\n      toBlock: cacheBlockHeight,\n      // When using cache, fetch events from the next block after cache\n      fromBlock: cachedPermissions ? cachedBlockNumber + 1 : undefined\n    }\n    const pastEvents$ = this.aclProxy.pastEvents(null, pastEventsOptions).pipe(\n      mergeMap((pastEvents) => from(pastEvents)),\n      // Custom cache event\n      endWith({\n        event: ACL_CACHE_KEY,\n        returnValues: {}\n      })\n    )\n    const currentEvents$ = this.aclProxy.events(null, { fromBlock: cacheBlockHeight + 1 }).pipe(\n      startWith({\n        event: 'starting current events',\n        returnValues: {}\n      })\n    )\n\n    // Permissions Object:\n    // { app -> role -> { manager, allowedEntities -> [ entities with permission ] } }\n    const fetchedPermissions$ = concat(pastEvents$, currentEvents$).pipe(\n      scan(([permissions], event) => {\n        const eventData = event.returnValues\n\n        if (eventData.app) {\n          // NOTE: dotprop.get() doesn't work through proxies, so we manually access permissions\n          const appPermissions = permissions[eventData.app] || {}\n\n          if (event.event === SET_PERMISSION_EVENT) {\n            const key = `${eventData.role}.allowedEntities`\n\n            // Converts to and from a set to avoid duplicated entities\n            const allowedEntitiesSet = new Set(dotprop.get(appPermissions, key, []))\n\n            if (eventData.allowed) {\n              allowedEntitiesSet.add(eventData.entity)\n            } else {\n              allowedEntitiesSet.delete(eventData.entity)\n            }\n\n            dotprop.set(appPermissions, key, Array.from(allowedEntitiesSet))\n          }\n\n          if (event.event === CHANGE_PERMISSION_MANAGER_EVENT) {\n            // We only care about the last one. An app permission can have only one manager\n            dotprop.set(appPermissions, `${eventData.role}.manager`, eventData.manager)\n          }\n\n          permissions[eventData.app] = appPermissions\n        }\n\n        return [permissions, event]\n      }, [ makeAddressMapProxy(cachedPermissions || {}) ]),\n\n      // Cache if we're finished syncing up to cache block height\n      map(([permissions, event]) => {\n        if (event.event === ACL_CACHE_KEY) {\n          this.cache.set(\n            ACL_CACHE_KEY,\n            // Make copy for cache\n            { permissions: Object.assign({}, permissions), blockNumber: cacheBlockHeight }\n          )\n        }\n        return permissions\n      }),\n\n      // Throttle so it only continues after 30ms without new values\n      // Avoids DDOSing subscribers as during initialization there may be\n      // hundreds of events processed in a short timespan\n      debounceTime(30),\n      publishReplay(1)\n    )\n    fetchedPermissions$.connect()\n\n    const cachedPermissions$ = cachedPermissions ? of(makeAddressMapProxy(cachedPermissions)) : of()\n    this.permissions = concat(cachedPermissions$, fetchedPermissions$).pipe(publishReplay(1))\n    this.permissions.connect()\n  }\n\n  /**\n   * Check if an object is an app.\n   *\n   * @param  {Object}  app\n   * @return {boolean}\n   */\n  isApp (app) {\n    return app.kernelAddress && this.isKernelAddress(app.kernelAddress)\n  }\n\n  /**\n   * Check if an address is this DAO's kernel.\n   *\n   * @param  {string}  address\n   * @return {boolean}\n   */\n  isKernelAddress (address) {\n    return addressesEqual(address, this.kernelProxy.address)\n  }\n\n  /**\n   * Initialize apps observable.\n   *\n   * @return {void}\n   */\n  initApps () {\n    /******************************\n     *                            *\n     *          CACHING           *\n     *                            *\n     ******************************/\n\n    const applicationInfoCache = new AsyncRequestCache(async (cacheKey) => {\n      const [appId, codeAddress] = cacheKey.split('.')\n      return getAragonOsInternalAppInfo(appId) ||\n        getApmInternalAppInfo(appId) ||\n        this.apm.fetchLatestRepoContentForContract(\n          await this.ens.resolve(appId),\n          codeAddress\n        )\n    })\n\n    const proxyContractValueCache = new AsyncRequestCache((proxyAddress) => {\n      if (this.isKernelAddress(proxyAddress)) {\n        const kernelProxy = makeProxy(proxyAddress, 'ERCProxy', this.web3)\n\n        return Promise.all([\n          // Use Kernel ABI\n          this.kernelProxy.call('KERNEL_APP_ID'),\n          // Use ERC897 proxy ABI\n          // Note that this won't work on old Aragon Core 0.5 Kernels,\n          // as they had not implemented ERC897 yet\n          kernelProxy.call('implementation')\n        ]).then((values) => ({\n          appId: values[0],\n          codeAddress: values[1]\n        }))\n      }\n\n      const appProxy = makeProxy(proxyAddress, 'AppProxy', this.web3)\n      const appProxyForwarder = makeProxy(proxyAddress, 'Forwarder', this.web3)\n\n      return Promise.all([\n        appProxy.call('kernel'),\n        appProxy.call('appId'),\n        appProxy.call('implementation'),\n        // Not all apps implement the forwarding interface\n        appProxyForwarder.call('isForwarder').catch(() => false)\n      ]).then((values) => ({\n        kernelAddress: values[0],\n        appId: values[1],\n        codeAddress: values[2],\n        isForwarder: values[3]\n      }))\n    })\n\n    /******************************\n     *                            *\n     *            APPS            *\n     *                            *\n     ******************************/\n\n    // Get all installed app proxy addresses\n    const installedApps$ = this.permissions.pipe(\n      map(Object.keys),\n      // Dedupe until apps change\n      distinctUntilChanged((oldProxies, newProxies) => {\n        if (oldProxies.length !== newProxies.length) {\n          return false\n        }\n        const oldSet = new Set(oldProxies)\n        const intersection = new Set(newProxies.filter(newProxy => oldSet.has(newProxy)))\n        return intersection.size === oldSet.size\n      }),\n      // Add Kernel as the first \"app\"\n      map((proxyAddresses) => {\n        const appsWithoutKernel = proxyAddresses.filter((address) => !this.isKernelAddress(address))\n        return [this.kernelProxy.address].concat(appsWithoutKernel)\n      }),\n      // Get proxy values\n      // Note that we can safely discard throttled values,\n      // so we use a `switchMap()` instead of a `mergeMap()`\n      switchMap(\n        (proxyAddresses) => Promise.all(\n          proxyAddresses.map(async (proxyAddress) => {\n            let proxyValues\n            try {\n              proxyValues = await proxyContractValueCache.request(proxyAddress)\n            } catch (_) {}\n\n            return {\n              proxyAddress,\n              ...proxyValues\n            }\n          })\n        )\n      ),\n      // Filter to remove any non-apps assigned in permissions\n      map(appProxies => appProxies.filter(\n        (appProxy) => this.isApp(appProxy) || this.isKernelAddress(appProxy.proxyAddress)\n      ))\n    )\n\n    // SetApp events are emitted when apps are installed and upgraded\n    // These may modify the implementation addresses of the proxies (modifying their behaviour), so\n    // we invalidate any caching we've done\n    const updatedApps$ = this.kernelProxy\n      // Only need to subscribe from latest block\n      .events('SetApp', { fromBlock: 'latest' })\n      .pipe(\n        // Only care about changes if they're in the APP_BASE namespace\n        filter(({ returnValues }) => isKernelAppCodeNamespace(returnValues.namespace)),\n\n        // Merge with latest value of installedApps$ so we can return the full list of apps\n        withLatestFrom(\n          installedApps$,\n          function updateApps (setAppEvent, apps) {\n            const { appId: setAppId } = setAppEvent.returnValues\n            return apps.map(async (app) => {\n              if (app.appId !== setAppId) {\n                return app\n              }\n\n              let proxyValues\n              try {\n                proxyValues = await proxyContractValueCache.request(\n                  app.proxyAddress,\n                  true // force cache invalidation\n                )\n              } catch (_) {}\n\n              return {\n                ...app,\n                ...proxyValues,\n                updated: true\n              }\n            })\n          }\n        ),\n        // Emit resolved array of promises, one at a time\n        concatMap(updatedApps => Promise.all(updatedApps))\n      )\n\n    // We merge these two observables, which both return the full list of apps attached with their\n    // proxy values:\n    //   - installedApps$: emits any time the list of installed apps changes\n    //   - updatedApps$:   emits any time SetApp could modify an installed app\n    const apps$ = merge(installedApps$, updatedApps$)\n\n    // Get artifact info for apps\n    const appsWithInfo$ = apps$.pipe(\n      concatMap(\n        (apps) => Promise.all(\n          apps.map(async (app) => {\n            let appInfo\n            if (app.appId && app.codeAddress) {\n              const cacheKey = `${app.appId}.${app.codeAddress}`\n              try {\n                appInfo = await applicationInfoCache.request(cacheKey)\n              } catch (_) { }\n            }\n\n            // This is a hack to fix web3.js and ethers not being able to detect reverts on decoding\n            // `eth_call`s (apps that implement fallbacks may revert if they haven't defined\n            // `isForwarder()`)\n            // Ideally web3.js would throw an error if it receives a revert from an `eth_call`, but\n            // as of v1.2.1, it interprets reverts as `true` :(.\n            //\n            // We check if the app's ABI actually has `isForwarder()` declared, and if not, override\n            // the isForwarder setting to false.\n            let isForwarderOverride = {}\n            if (\n              app.isForwarder &&\n              appInfo &&\n              Array.isArray(appInfo.abi) &&\n              !appInfo.abi.some(({ type, name }) => type === 'function' && name === 'isForwarder')\n            ) {\n              isForwarderOverride = {\n                isForwarder: false\n              }\n            }\n\n            return {\n              ...appInfo,\n              // Override the fetched appInfo with the actual app proxy's values to avoid mismatches\n              ...app,\n              // isForwarder override (see above)\n              ...isForwarderOverride\n            }\n          })\n        )\n      )\n    )\n\n    this.apps = appsWithInfo$.pipe(\n      publishReplay(1)\n    )\n    this.apps.connect()\n\n    /*******************************\n     *                             *\n     *            REPOS            *\n     *                             *\n     ******************************/\n\n    // Initialize installed repos from the list of apps\n    const installedRepoCache = new Map()\n    const repo$ = apps$.pipe(\n      // Map installed apps into a deduped list of their aragonPM repos, with these assumptions:\n      //   - No apps are lying about their appId (malicious apps _could_ masquerade as other\n      //     apps by setting this value themselves)\n      //   - `contractAddress`s will stay the same across all installed apps.\n      //     This is technically not true as apps could set this value themselves\n      //     (e.g. as pinned apps do), but these apps wouldn't be able to upgrade anyway\n      //\n      //  Ultimately returns an array of objects, holding the repo's:\n      //    - appId\n      //    - base contractAddress\n      map((apps) => Object.values(\n        apps\n          .filter(({ appId }) => !isAragonOsInternalApp(appId))\n          .reduce((installedRepos, { appId, codeAddress, updated }) => {\n            installedRepos[appId] = {\n              appId,\n              updated,\n              contractAddress: codeAddress\n            }\n            return installedRepos\n          }, {})\n      )),\n\n      // Filter list of installed repos into:\n      //   - New repos we haven't seen before (to begin subscribing to their version events)\n      //   - Repos we've seen before, to trigger a recalculation of the currently installed version\n      map((repos) => {\n        const newRepoAppIds = []\n        const updatedRepoAppIds = []\n\n        repos.forEach((repo) => {\n          const { appId, updated } = repo\n          if (!installedRepoCache.has(appId)) {\n            newRepoAppIds.push(appId)\n          } else if (updated) {\n            updatedRepoAppIds.push(appId)\n          }\n\n          // Mark repo as seen and cache installed information\n          installedRepoCache.set(appId, repo)\n        })\n\n        return [newRepoAppIds, updatedRepoAppIds]\n      }),\n\n      // Stop if there's no new repos or updated apps\n      filter(([newRepoAppIds, updatedRepoAppIds]) =>\n        newRepoAppIds.length || updatedRepoAppIds.length\n      ),\n\n      // Project new repos into their ids and web3 proxy objects\n      concatMap(async ([newRepoAppIds, updatedRepoAppIds]) => {\n        const newRepos = (await Promise.all(\n          newRepoAppIds.map(async (appId) => {\n            let repoProxy\n\n            try {\n              const repoAddress = await this.ens.resolve(appId)\n              repoProxy = makeRepoProxy(repoAddress, this.web3)\n              await repoProxy.updateInitializationBlock()\n            } catch (err) {\n              console.error(`Could not find repo for ${appId}`, err)\n            }\n\n            return {\n              appId,\n              repoProxy\n            }\n          })\n        ))\n          // Filter out repos we couldn't create proxies for (they were likely due to publishing\n          // invalid aragonPM repos)\n          // Note that we don't need to worry about doing this for the updated repos list; if\n          // we could not create the original repo proxy when we first saw the repo, the updates\n          // won't do anything because we weren't able to fetch enough information (versions list)\n          .filter((newRepos) => newRepos.repoProxy)\n        return [newRepos, updatedRepoAppIds]\n      }),\n\n      // Here's where the fun begins!\n      // It'll be easy to get lost, so remember to take it slowly.\n      // Just remember, with this `mergeMap()`, we'll be subscribing to all the projected (returned)\n      // observables and merging their respective emissions into a single observable.\n      //\n      // The output of this merged observable are update events containing the following:\n      //   - `appId`: mandatory, signifies which repo was updated\n      //   - `repoAddress`: optional, address of the repo contract itself\n      //   - `versions`: optional, new version information\n      mergeMap(([newRepos, updatedRepoAppIds]) => {\n        // Create a new observable to project each new update as its own update emission.\n        const update$ = of(...updatedRepoAppIds).pipe(\n          map((appId) => ({ appId }))\n        )\n\n        // Create a new observable to project each new repo as its own emission.\n        const newRepo$ = of(...newRepos)\n\n        // Create a new observable to project each new repo's address as its own update emission.\n        const repoAddress$ = newRepo$.pipe(\n          map(({ appId, repoProxy }) => ({\n            appId,\n            repoAddress: repoProxy.address\n          }))\n        )\n\n        // Create a new observable that projects each NewVersion event as its own update event\n        // emission.\n        // This one is a bit trickier, due to the higher order observable. Keep reading.\n        const version$ = newRepo$.pipe(\n          // `mergeMap()` to \"flatten\" the async transformation. This async function returns an\n          // observable, which is ultimately the NewVersion stream. More on this, after the break.\n          // Note: we don't care about the ordering, so we use `mergeMap()` instead of `concatMap()`\n          mergeMap(async ({ appId, repoProxy }) => {\n            const initialVersions = [\n              // Immediately query state from the repo contract, to avoid having to wait until all\n              // past events sync (may be long)\n              ...await getAllRepoVersions(repoProxy)\n            ]\n\n            // Return an observable subscribed to NewVersion events, giving us:\n            //   - Timestamps for versions that were published prior to this process running\n            //   - Notifications for newly published versions\n            //\n            // Reduce this with the cached version information to emit version updates for the repo.\n            return repoProxy.events('NewVersion').pipe(\n              // Project each event to a new version info object, one at a time\n              concatMap(async (event) => {\n                const { versionId: eventVersionId } = event.returnValues\n\n                // Adjust from Ethereum time\n                const timestamp = (await this.web3.eth.getBlock(event.blockNumber)).timestamp * 1000\n\n                const versionIndex = initialVersions.findIndex(({ versionId }) => versionId === eventVersionId)\n                const versionInfo =\n                  versionIndex === -1\n                    ? await getRepoVersionById(repoProxy, eventVersionId)\n                    : initialVersions[versionIndex]\n\n                return {\n                  ...versionInfo,\n                  timestamp\n                }\n              }),\n\n              // Trick to immediately emit (e.g. similar to a do/while loop)\n              startWith(null),\n\n              // Reduce newly emitted versions into the full list of versions\n              scan(({ appId, versions }, newVersionInfo) => {\n                let newVersions = versions\n                if (newVersionInfo) {\n                  const versionIndex = versions.findIndex(({ versionId }) => versionId === newVersionInfo.versionId)\n\n                  if (versionIndex === -1) {\n                    newVersions = versions.concat(newVersionInfo)\n                  } else {\n                    newVersions = Array.from(versions)\n                    newVersions[versionIndex] = newVersionInfo\n                  }\n                }\n\n                return {\n                  appId,\n                  versions: newVersions\n                }\n              }, {\n                appId,\n                versions: initialVersions\n              })\n            )\n          }),\n\n          // This bit is interesting.\n          // We've \"flattened\" our async transformation with the `mergeMap()` above, but it still\n          // returns an observable. We need to flatten this observable's emissions into the upper\n          // stream, which is what `mergeAll()` achieves.\n          mergeAll()\n        )\n\n        // Merge all of the repo update events resulting from the apps being updated, and return it\n        // to the upper `mergeMap()` so it can be re-flattened into a single event stream.\n        return merge(repoAddress$, version$, update$)\n      }),\n\n      // Reduce the event stream into a current representation of the installed repos, and which\n      // repo to update next.\n      scan(({ repos }, repoUpdate) => {\n        const { appId: updatedAppId, ...update } = repoUpdate\n        const updatedRepoInfo = {\n          ...repos[updatedAppId],\n          ...update\n        }\n\n        return {\n          repos: {\n            ...repos,\n            [updatedAppId]: updatedRepoInfo\n          },\n          updatedRepoAppId: updatedAppId\n        }\n      }, {\n        repos: {},\n        updatedRepoAppId: null\n      }),\n\n      // Stop if we don't have enough information yet to continue\n      filter(({ repos, updatedRepoAppId }) =>\n        !!updatedRepoAppId && Array.isArray(repos[updatedRepoAppId].versions)\n      ),\n\n      // Grab the full information of the updated repo using its latest values.\n      // With this, we've taken the basic stream of updates for events and mapped them onto their\n      // full repo objects.\n      concatMap(async ({ repos, updatedRepoAppId: appId }) => {\n        const { repoAddress, versions } = repos[appId]\n        const installedRepoInfo = installedRepoCache.get(appId)\n\n        const baseRepoInfo = { appId, repoAddress, versions }\n        const fetchVersionInfo = version => {\n          return applicationInfoCache\n            .request(`${appId}.${version.contractAddress}`)\n            .catch(() => ({}))\n            .then(content => ({\n              content,\n              version: version.version\n            }))\n        }\n\n        const latestVersion = versions[versions.length - 1]\n        const currentVersion = Array.from(versions)\n          // Apply reverse to find the latest version with the currently installed contract address\n          .reverse()\n          .find(version => addressesEqual(version.contractAddress, installedRepoInfo.contractAddress))\n\n        if (!currentVersion) {\n          // The organization has installed an unpublished version of this app\n          // Avoid returning a current version as we don't know what version they're using\n          return {\n            ...baseRepoInfo,\n            currentVersion: null,\n            latestVersion: await fetchVersionInfo(latestVersion)\n          }\n        }\n\n        const currentVersionInfoRequest = fetchVersionInfo(currentVersion)\n        const latestVersionInfoRequest =\n          addressesEqual(currentVersion.contractAddress, latestVersion.contractAddress)\n            ? currentVersionInfoRequest\n            : fetchVersionInfo(latestVersion)\n\n        return {\n          ...baseRepoInfo,\n          currentVersion: await currentVersionInfoRequest,\n          latestVersion: await latestVersionInfoRequest\n        }\n      })\n    )\n\n    this.installedRepos = repo$.pipe(\n      // Finally, we reduce the merged updates from individual repos into one final, expanding array\n      // of the installed repos\n      scan((repos, updatedRepo) => {\n        const repoIndex = repos.findIndex(repo => repo.repoAddress === updatedRepo.repoAddress)\n        if (repoIndex === -1) {\n          return repos.concat(updatedRepo)\n        } else {\n          const nextRepos = Array.from(repos)\n          nextRepos[repoIndex] = updatedRepo\n          return nextRepos\n        }\n      }, []),\n      // Throttle updates, but must keep trailing to ensure we don't drop any updates\n      throttleTime(500, asyncScheduler, { leading: false, trailing: true }),\n      publishReplay(1)\n    )\n    this.installedRepos.connect()\n  }\n\n  /**\n   * Initialise forwarder observable.\n   *\n   * @return {void}\n   */\n  initForwarders () {\n    this.forwarders = this.apps.pipe(\n      map(\n        (apps) => apps.filter((app) => app.isForwarder)\n      ),\n      publishReplay(1)\n    )\n    this.forwarders.connect()\n  }\n\n  /**\n   * Initialise app identifier observable.\n   *\n   * @return {void}\n   */\n  initAppIdentifiers () {\n    this.appIdentifiers = new BehaviorSubject({}).pipe(\n      scan(\n        (identifiers, { address, identifier }) =>\n          Object.assign(identifiers, { [address]: identifier })\n      ),\n      publishReplay(1)\n    )\n    this.appIdentifiers.connect()\n  }\n\n  /**\n   * Set the identifier of an app.\n   *\n   * @param {string} address The proxy address of the app\n   * @param {string} identifier The identifier of the app\n   * @return {void}\n   */\n  setAppIdentifier (address, identifier) {\n    this.appIdentifiers.next({\n      address,\n      identifier\n    })\n  }\n\n  /**\n   * Initialise identity providers.\n   *\n   * @return {Promise<void>}\n   */\n  async initIdentityProviders () {\n    const defaultIdentityProviders = [{\n      name: 'local',\n      provider: new LocalIdentityProvider()\n    }]\n    // TODO: detect other installed providers\n    const detectedIdentityProviders = []\n    const identityProviders = [...defaultIdentityProviders, ...detectedIdentityProviders]\n\n    // Init all providers\n    await Promise.all(identityProviders.map(({ provider }) => {\n      // Most providers should have this defined to a noop function by default, but just in case\n      if (typeof provider.init === 'function') {\n        return provider.init()\n      }\n      return Promise.resolve()\n    }))\n\n    this.identityProviderRegistrar = new Map(\n      identityProviders.map(({ name, provider }) => [name, provider])\n    )\n    // Set up identity modification intent observable\n    this.identityIntents = new Subject()\n  }\n\n  /**\n   * Modify the identity metadata for an address using the highest priority provider.\n   *\n   * @param  {string} address Address to modify\n   * @param  {Object} metadata Modification metadata object\n   * @return {Promise} Resolves if the modification was successful\n   */\n  modifyAddressIdentity (address, metadata) {\n    const providerName = 'local'\n    const provider = this.identityProviderRegistrar.get(providerName)\n    if (provider && typeof provider.modify === 'function') {\n      return provider.modify(address, metadata)\n    }\n    return Promise.reject(new Error(`Provider (${providerName}) not installed`))\n  }\n\n  /**\n   * Resolve the identity metadata for an address using the highest priority provider.\n   *\n   * @param  {string} address Address to resolve\n   * @return {Promise} Resolves with the identity or null if not found\n   */\n  resolveAddressIdentity (address) {\n    const providerName = 'local' // TODO - get provider\n    const provider = this.identityProviderRegistrar.get(providerName)\n    if (provider && typeof provider.resolve === 'function') {\n      return provider.resolve(address)\n    }\n    return Promise.reject(new Error(`Provider (${providerName}) not installed`))\n  }\n\n  /**\n   * Search identities based on a term\n   *\n   * @param  {string} searchTerm\n   * @return {Promise} Resolves with the identity or null if not found\n   */\n  searchIdentities (searchTerm) {\n    const providerName = 'local' // TODO - get provider\n    const provider = this.identityProviderRegistrar.get(providerName)\n    if (provider && typeof provider.search === 'function') {\n      return provider.search(searchTerm)\n    }\n    return Promise.reject(new Error(`Provider (${providerName}) not installed`))\n  }\n\n  /**\n   * Request an identity modification using the highest priority provider.\n   *\n   * Returns a promise which delegates resolution to the handler\n   * which listens and handles `this.identityIntents`\n   *\n   * @param  {string} address Address to modify\n   * @return {Promise} Resolved by the handler of identityIntents\n   */\n  requestAddressIdentityModification (address) {\n    const providerName = 'local' // TODO - get provider\n    if (this.identityProviderRegistrar.has(providerName)) {\n      return new Promise((resolve, reject) => {\n        this.identityIntents.next({\n          address,\n          providerName,\n          resolve,\n          reject (err) {\n            reject(err || new Error('The identity modification was not completed'))\n          }\n        })\n      })\n    }\n\n    return Promise.reject(new Error(`Provider (${providerName}) not installed`))\n  }\n\n  /**\n   * Remove selected local identities\n   *\n   * @param {Array<string>} addresses The addresses to be removed from the local identity provider\n   * @return {Promise}\n   */\n  async removeLocalIdentities (addresses) {\n    const localProvider = this.identityProviderRegistrar.get('local')\n    for (const address of addresses) {\n      await localProvider.remove(address)\n    }\n  }\n\n  /**\n   * Get all local identities for listing functionality\n   *\n   * @return {Promise<Object>}\n   */\n  getLocalIdentities () {\n    return this.identityProviderRegistrar.get('local').getAll()\n  }\n\n  /**\n   * Initialise the GUI style observable.\n   *\n   * @param {Object} style GUI style options\n   * @param {string} style.appearance \"dark\" or \"light\"\n   * @param {Object} [style.theme] The theme object\n   * @return {void}\n   */\n  initGuiStyle ({ appearance, theme } = {}) {\n    this.guiStyle = new BehaviorSubject({\n      appearance: appearance || 'light',\n      theme: theme || null\n    })\n  }\n\n  /**\n   * Set the GUI style (theme and appearance).\n   *\n   * @param {string} appearance \"dark\" or \"light\"\n   * @param {Object} [theme] The theme object.\n   * @return {void}\n   */\n  setGuiStyle (appearance, theme = null) {\n    this.guiStyle.next({\n      appearance,\n      theme\n    })\n  }\n\n  /**\n   * Initialise the network observable.\n   *\n   * @param {Object} network information of node\n   * @return {Promise<void>}\n   */\n  async initNetwork (network) {\n    this.network = new ReplaySubject(1)\n\n    if (network) {\n      this.network.next(network)\n    } else {\n      this.network.next({\n        id: await this.web3.eth.getChainId(),\n        type: await this.web3.eth.net.getNetworkType()\n      })\n    }\n  }\n\n  /**\n   * Request an app's path be changed.\n   *\n   * @param {string} appAddress\n   * @param {string} path\n   * @return {Promise} Succeeds if path request was allowed\n   */\n  async requestAppPath (appAddress, path) {\n    if (typeof path !== 'string') {\n      throw new Error('Path must be a string')\n    }\n\n    if (!await this.getApp(appAddress)) {\n      throw new Error(`Cannot request path for non-installed app: ${appAddress}`)\n    }\n\n    return new Promise((resolve, reject) => {\n      this.pathIntents.next({\n        appAddress,\n        path,\n        resolve,\n        reject (err) {\n          reject(err || new Error('The path was rejected'))\n        }\n      })\n    })\n  }\n\n  /**\n   * Set an app's path.\n   *\n   * @param {string} appAddress\n   * @param {string} path\n   * @return {void}\n   */\n  setAppPath (appAddress, path) {\n    if (typeof path !== 'string') {\n      throw new Error('Path must be a string')\n    }\n\n    this.appContextPool.emit(appAddress, APP_CONTEXTS.PATH, path)\n  }\n\n  /**\n   * Run an app.\n   *\n   * As there may be race conditions with losing messages from cross-context environments,\n   * running an app is split up into two parts:\n   *\n   *   1. Set up any required state for the app. This step is allowed to be asynchronous.\n   *   2. Connect the app to a running context, by associating the context's message provider\n   *      to the app. This step is synchronous.\n   *\n   * @param  {string} proxyAddress\n   *         The address of the app proxy.\n   * @return {Promise<function>}\n   */\n  async runApp (proxyAddress) {\n    // Step 1: Set up required state for the app\n\n    // Only get the first result from the observable, so our running contexts don't get\n    // reinitialized if new apps appear\n    const apps = await this.apps.pipe(first()).toPromise()\n\n    const app = apps.find((app) => addressesEqual(app.proxyAddress, proxyAddress))\n\n    // TODO: handle undefined (no proxy found), otherwise when calling app.proxyAddress next, it will throw\n    const appProxy = makeProxyFromAppABI(app.proxyAddress, app.abi, this.web3)\n\n    await appProxy.updateInitializationBlock()\n\n    // Step 2: Associate app with running context\n    return (sandboxMessengerProvider) => {\n      // Set up messenger\n      const messenger = new Messenger(\n        sandboxMessengerProvider\n      )\n\n      // Wrap requests with the application proxy\n      // Note that we have to do this synchronously with the creation of the message provider,\n      // as we otherwise risk race conditions and may lose messages\n      const request$ = messenger.requests().pipe(\n        map(request => ({ request, proxy: appProxy, wrapper: this })),\n        // Use the same request$ result in each handler\n        // Turns request$ into a subject\n        publishReplay(1)\n      )\n      request$.connect()\n\n      // Register request handlers\n      const handlerSubscription = handlers.combineRequestHandlers(\n        // Generic handlers\n        handlers.createRequestHandler(request$, 'accounts', handlers.accounts),\n        handlers.createRequestHandler(request$, 'cache', handlers.cache),\n        handlers.createRequestHandler(request$, 'describe_script', handlers.describeScript),\n        handlers.createRequestHandler(request$, 'describe_transaction', handlers.describeTransaction),\n        handlers.createRequestHandler(request$, 'get_apps', handlers.getApps),\n        handlers.createRequestHandler(request$, 'network', handlers.network),\n        handlers.createRequestHandler(request$, 'path', handlers.path),\n        handlers.createRequestHandler(request$, 'gui_style', handlers.guiStyle),\n        handlers.createRequestHandler(request$, 'trigger', handlers.trigger),\n        handlers.createRequestHandler(request$, 'web3_eth', handlers.web3Eth),\n\n        // Contract handlers\n        handlers.createRequestHandler(request$, 'intent', handlers.intent),\n        handlers.createRequestHandler(request$, 'call', handlers.call),\n        handlers.createRequestHandler(request$, 'sign_message', handlers.signMessage),\n        handlers.createRequestHandler(request$, 'events', handlers.events),\n        handlers.createRequestHandler(request$, 'past_events', handlers.pastEvents),\n\n        // External contract handlers\n        handlers.createRequestHandler(request$, 'external_call', handlers.externalCall),\n        handlers.createRequestHandler(request$, 'external_events', handlers.externalEvents),\n        handlers.createRequestHandler(request$, 'external_intent', handlers.externalIntent),\n        handlers.createRequestHandler(request$, 'external_past_events', handlers.externalPastEvents),\n\n        // Identity handlers\n        handlers.createRequestHandler(request$, 'identify', handlers.appIdentifier),\n        handlers.createRequestHandler(request$, 'address_identity', handlers.addressIdentity),\n        handlers.createRequestHandler(request$, 'search_identities', handlers.searchIdentities)\n      ).subscribe(\n        (response) => messenger.sendResponse(response.id, response.payload)\n      )\n\n      // The attached unsubscribe isn't automatically bound to the subscription\n      const shutdown = () => handlerSubscription.unsubscribe()\n\n      const shutdownAndClearCache = async () => {\n        shutdown()\n\n        // Remove all cache keys related to this app one by one\n        return Object\n          .keys(await this.cache.getAll())\n          .reduce((promise, cacheKey) => {\n            return promise.then(() =>\n              cacheKey.startsWith(proxyAddress)\n                ? this.cache.remove(cacheKey)\n                : Promise.resolve()\n            )\n          }, Promise.resolve())\n      }\n\n      return {\n        shutdown,\n        shutdownAndClearCache\n      }\n    }\n  }\n\n  /**\n   * Set the available accounts for the current user.\n   *\n   * @param {Array<string>} accounts\n   * @return {void}\n   */\n  setAccounts (accounts) {\n    this.accounts.next(accounts)\n  }\n\n  /**\n   * Get the available accounts for the current user.\n   *\n   * @return {Promise<Array<string>>} An array of addresses\n   */\n  getAccounts () {\n    return this.accounts.pipe(first()).toPromise()\n  }\n\n  /**\n   * Allows apps to sign arbitrary data via a RPC call\n   *\n   * @param {string} message to be signed\n   * @param {string} requestingApp proxy address of requesting app\n   * @return {Promise<string>} signature hash\n   */\n  signMessage (message, requestingApp) {\n    if (typeof message !== 'string') {\n      return Promise.reject(new Error('Message to sign must be a string'))\n    }\n    return new Promise((resolve, reject) => {\n      this.signatures.next({\n        message,\n        requestingApp,\n        resolve,\n        reject (err) {\n          reject(err || new Error('The message was not signed'))\n        }\n      })\n    })\n  }\n\n  /**\n   * @param {Array<Object>} transactionPath An array of Ethereum transactions that describe each\n   *   step in the path\n   * @param {Object} [options]\n   * @param {boolean} [options.external] Whether the transaction path is initiating an action on\n   *   an external destination (not the currently running app)\n   * @return {Promise<string>} Promise that should be resolved with the sent transaction hash\n   */\n  performTransactionPath (transactionPath, { external } = {}) {\n    return new Promise((resolve, reject) => {\n      this.transactions.next({\n        resolve,\n        external: !!external,\n        transaction: transactionPath[0],\n        path: transactionPath,\n        reject (err) {\n          reject(err || new Error('The transaction was not signed'))\n        }\n      })\n    })\n  }\n\n  /**\n   * Performs an action on the ACL using transaction pathing\n   *\n   * @param {string} method\n   * @param {Array<*>} params\n   * @return {Promise<string>} transaction hash\n   */\n  async performACLIntent (method, params) {\n    const path = await this.getACLTransactionPath(method, params)\n    return this.performTransactionPath(path)\n  }\n\n  /**\n   * Looks for app with the provided proxyAddress and returns its app object if found\n   *\n   * @param {string} proxyAddress\n   * @return {Promise<Object>} The app object\n   */\n  getApp (proxyAddress) {\n    return this.apps.pipe(\n      map(apps => apps.find(app => addressesEqual(app.proxyAddress, proxyAddress))),\n      first()\n    ).toPromise()\n  }\n\n  /**\n   * Calculate the transaction path for a transaction to `destination`\n   * that invokes `methodSignature` with `params`.\n   *\n   * @param  {string} destination\n   * @param  {string} methodSignature\n   * @param  {Array<*>} params\n   * @param  {string} [finalForwarder] Address of the final forwarder that can perfom the action\n   * @return {Promise<Array<Object>>} An array of Ethereum transactions that describe each step in the path\n   */\n  async getTransactionPath (destination, methodSignature, params, finalForwarder) {\n    const accounts = await this.getAccounts()\n\n    for (let account of accounts) {\n      const path = await this.calculateTransactionPath(\n        account,\n        destination,\n        methodSignature,\n        params,\n        finalForwarder\n      )\n\n      if (path.length > 0) {\n        try {\n          return this.describeTransactionPath(path)\n        } catch (_) {\n          return path\n        }\n      }\n    }\n\n    return []\n  }\n\n  /**\n   * Calculate the transaction path for a transaction to an external `destination`\n   * (not the currently running app) that invokes a method matching the\n   * `methodAbiFragment` with `params`.\n   *\n   * @param  {string} destination Address of the external contract\n   * @param  {object} methodAbiFragment ABI fragment of method to invoke\n   * @param  {Array<*>} params\n   * @return {Promise<Array<Object>>} An array of Ethereum transactions that describe each step in the path.\n   *   If the destination is a non-installed contract, always results in an array containing a\n   *   single transaction.\n   */\n  async getExternalTransactionPath (destination, methodAbiFragment, params) {\n    if (addressesEqual(destination, this.aclProxy.address)) {\n      try {\n        return this.getACLTransactionPath(methodAbiFragment.name, params)\n      } catch (_) {\n        return []\n      }\n    }\n\n    const installedApp = await this.getApp(destination)\n    if (installedApp) {\n      // Destination is an installed app; need to go through normal transaction pathing\n      return this.getTransactionPath(destination, methodAbiFragment.name, params)\n    }\n\n    // Destination is not an installed app on this org, just create a direct transaction\n    // with the first account\n    const account = (await this.getAccounts())[0]\n\n    try {\n      const tx = await createDirectTransaction(account, destination, methodAbiFragment, params, this.web3)\n      return this.describeTransactionPath([tx])\n    } catch (_) {\n      return []\n    }\n  }\n\n  /**\n   * Calculate the transaction path for a basket of intents.\n   * Expects the `intentBasket` to be an array of tuples holding the following:\n   *   {string}   destination: destination address\n   *   {string}   methodSignature: method to invoke on destination\n   *   {Array<*>} params: method params\n   * These are the same parameters as the ones used for `getTransactionPath()`\n   *\n   * Allows user to specify how many of the intents should be checked to ensure their paths are\n   * compatible. `checkMode` supports:\n   *   'all': All intents will be checked to make sure they use the same forwarding path.\n   *   'single': assumes all intents can use the path found from the first intent\n   *\n   * @param  {Array<Array<string, string, Array<*>>>} intentBasket Intents\n   * @param  {Object} [options]\n   * @param  {string} [options.checkMode] Path checking mode\n   * @return {Promise<Object>} An object containing:\n   *   - `path` (Array<Object>): a multi-step transaction path that eventually invokes this basket.\n   *     Empty if no such path could be found.\n   *   - `transactions` (Array<Object>): array of Ethereum transactions that invokes this basket.\n   *     If a multi-step transaction path was found, returns the first transaction in that path.\n   *     Empty if no such transactions could be found.\n   */\n  async getTransactionPathForIntentBasket (intentBasket, { checkMode = 'all' } = {}) {\n    // Get transaction paths for entire basket\n    const intentsToCheck =\n      checkMode === 'all'\n        ? intentBasket // all -- use all intents\n        : checkMode === 'single'\n          ? [intentBasket[0]] // single -- only use first intent\n          : []\n    const intentPaths = await Promise.all(\n      intentsToCheck.map(\n        ([destination, methodSignature, params]) =>\n          addressesEqual(destination, this.aclProxy.address)\n            ? this.getACLTransactionPath(methodSignature, params)\n            : this.getTransactionPath(destination, methodSignature, params)\n      )\n    )\n\n    // If the paths don't match, we can't send the transactions in this intent basket together\n    const pathsMatch = doIntentPathsMatch(intentPaths)\n    if (pathsMatch) {\n      // Create direct transactions for each intent in the intentBasket\n      const sender = (await this.getAccounts())[0] // TODO: don't assume it's the first account\n      const directTransactions = await Promise.all(\n        intentBasket.map(\n          async ([destination, methodSignature, params]) =>\n            createDirectTransactionForApp(sender, await this.getApp(destination), methodSignature, params, this.web3)\n        )\n      )\n\n      if (intentPaths[0].length === 1) {\n        // Sender has direct access\n        try {\n          const decoratedTransactions = await this.describeTransactionPath(\n            await Promise.all(\n              directTransactions.map(transaction => this.applyTransactionGas(transaction))\n            )\n          )\n\n          return {\n            path: [],\n            transactions: decoratedTransactions\n          }\n        } catch (_) { }\n      } else {\n        // Need to encode calls scripts for each forwarder transaction in the path\n        const createForwarderTransaction = createForwarderTransactionBuilder(sender, {}, this.web3)\n        const forwarderPath = intentPaths[0]\n          // Ignore the last part of the path, which was the original intent\n          .slice(0, -1)\n          // Start from the \"last\" forwarder and move backwards to the sender\n          .reverse()\n          // Just use the forwarders' addresses\n          .map(({ to }) => to)\n          .reduce(\n            (path, nextForwarder) => {\n              const lastStep = path[0]\n              const encodedLastStep = encodeCallScript(Array.isArray(lastStep) ? lastStep : [lastStep])\n              return [createForwarderTransaction(nextForwarder, encodedLastStep), ...path]\n            },\n            // Start the recursive calls script encoding with the direct transactions for the\n            // intent basket\n            [directTransactions]\n          )\n\n        try {\n          // Put the finishing touches: apply gas, and add radspec descriptions\n          forwarderPath[0] = await this.applyTransactionGas(forwarderPath[0], true)\n          return {\n            path: await this.describeTransactionPath(forwarderPath),\n            // When we have a path, we only need to send the first transaction to start it\n            transactions: [forwarderPath[0]]\n          }\n        } catch (_) { }\n      }\n    }\n\n    // Failed to find a path\n    return {\n      path: [],\n      transactions: []\n    }\n  }\n\n  /**\n   * Get the permission manager for an `app`'s and `role`.\n   *\n   * @param {string} appAddress\n   * @param {string} roleHash\n   * @return {Promise<string>} The permission manager\n   */\n  async getPermissionManager (appAddress, roleHash) {\n    const permissions = await this.permissions.pipe(first()).toPromise()\n    const appPermissions = permissions[appAddress]\n\n    return dotprop.get(appPermissions, `${roleHash}.manager`)\n  }\n\n  /**\n   * Calculates transaction path for performing a method on the ACL\n   *\n   * @param {string} methodSignature\n   * @param {Array<*>} params\n   * @return {Promise<Array<Object>>} An array of Ethereum transactions that describe each step in the path\n   */\n  async getACLTransactionPath (methodSignature, params) {\n    const aclAddr = this.aclProxy.address\n    const acl = await this.getApp(aclAddr)\n\n    const method = findAppMethodFromSignature(acl, methodSignature, { allowDeprecated: false })\n    if (!method) {\n      throw new Error(`No method named ${methodSignature} on ACL`)\n    }\n\n    if (method.roles && method.roles.length !== 0) {\n      // This action can be done with regular transaction pathing (it's protected by an ACL role)\n      return this.getTransactionPath(aclAddr, methodSignature, params)\n    } else {\n      // Some ACL functions don't have a role and are instead protected by a manager\n      // Inspect the matched method's ABI to find the position of the 'app' and 'role' parameters\n      // needed to get the permission manager\n      const methodAbiFragment = findMethodAbiFragment(acl.abi, methodSignature)\n      if (!methodAbiFragment) {\n        throw new Error(`Method ${method} not found on ACL ABI`)\n      }\n\n      const inputNames = methodAbiFragment.inputs.map((input) => input.name)\n      const appIndex = inputNames.indexOf('_app')\n      const roleIndex = inputNames.indexOf('_role')\n\n      if (appIndex === -1 || roleIndex === -1) {\n        throw new Error(`Method ${methodSignature} doesn't take _app and _role as input. Permission manager cannot be found.`)\n      }\n\n      const manager = await this.getPermissionManager(params[appIndex], params[roleIndex])\n\n      return this.getTransactionPath(aclAddr, methodSignature, params, manager)\n    }\n  }\n\n  /**\n   * Decodes an EVM callscript and returns the transaction path it describes.\n   *\n   * @param  {string} script\n   * @return {Array<Object>} An array of Ethereum transactions that describe each step in the path\n   */\n  decodeTransactionPath (script) {\n    // In the future we may support more EVMScripts, but for now let's just assume we're only\n    // dealing with call scripts\n    if (!isCallScript(script)) {\n      throw new Error(`Script could not be decoded: ${script}`)\n    }\n\n    const path = decodeCallScript(script)\n    return path.map((segment) => {\n      const { data } = segment\n\n      if (isValidForwardCall(data)) {\n        const forwardedEvmScript = parseForwardCall(data)\n\n        try {\n          segment.children = this.decodeTransactionPath(forwardedEvmScript)\n        } catch (err) {}\n      }\n\n      return segment\n    })\n  }\n\n  /**\n   * Use radspec to create a human-readable description for each transaction in the given `path`\n   *\n   * @param  {Array<Object>} path\n   * @return {Promise<Array<Object>>} The given `path`, with decorated with descriptions at each step\n   */\n  async describeTransactionPath (path) {\n    return Promise.all(path.map(async (step) => {\n      let decoratedStep\n\n      if (Array.isArray(step)) {\n        // Intent basket with multiple transactions in a single callscript\n        // First see if the step can be handled with a specialized descriptor\n        try {\n          decoratedStep = await tryDescribingUpgradeOrganizationBasket(step, this)\n        } catch (err) { }\n\n        // If the step wasn't handled, just individually describe each of the transactions\n        return decoratedStep || this.describeTransactionPath(step)\n      }\n\n      // Single transaction step\n      // First see if the step can be handled with a specialized descriptor\n      try {\n        decoratedStep = await tryDescribingUpdateAppIntent(step, this)\n      } catch (err) { }\n\n      // Finally, if the step wasn't handled yet, evaluate via radspec normally\n      if (!decoratedStep) {\n        try {\n          decoratedStep = await tryEvaluatingRadspec(step, this)\n        } catch (err) { }\n      }\n\n      // Annotate the description, if one was found\n      if (decoratedStep) {\n        if (decoratedStep.description) {\n          try {\n            const processed = await postprocessRadspecDescription(decoratedStep.description, this)\n            decoratedStep.description = processed.description\n            decoratedStep.annotatedDescription = processed.annotatedDescription\n          } catch (err) { }\n        }\n\n        if (decoratedStep.children) {\n          decoratedStep.children = await this.describeTransactionPath(decoratedStep.children)\n        }\n      }\n\n      return decoratedStep || step\n    }))\n  }\n\n  /**\n   * Whether the `sender` can use the `forwarder` to invoke `script`.\n   *\n   * @param  {string} forwarder\n   * @param  {string} sender\n   * @param  {string} script\n   * @return {Promise<bool>}\n   */\n  canForward (forwarder, sender, script) {\n    const canForward = new this.web3.eth.Contract(\n      getAbi('aragon/Forwarder'),\n      forwarder\n    ).methods['canForward']\n\n    return canForward(sender, script).call().catch(() => false)\n  }\n\n  getDefaultGasPrice (gasLimit) {\n    return this.defaultGasPriceFn(gasLimit)\n  }\n\n  /**\n   * Calculates and applies the gas limit and gas price for a transaction\n   *\n   * @param  {Object} transaction\n   * @param  {bool} isForwarding\n   * @return {Promise<Object>} The transaction with the gas limit and gas price added.\n   *                           If the transaction fails from the estimateGas check, the promise will\n   *                           be rejected with the error.\n   */\n  async applyTransactionGas (transaction, isForwarding = false) {\n    // If a pretransaction is required for the main transaction to be performed,\n    // performing web3.eth.estimateGas could fail until the pretransaction is mined\n    // Example: erc20 approve (pretransaction) + deposit to vault (main transaction)\n    if (transaction.pretransaction) {\n      // Calculate gas settings for pretransaction\n      transaction.pretransaction = await this.applyTransactionGas(transaction.pretransaction, false)\n      // Note: for transactions with pretransactions gas limit and price cannot be calculated\n      return transaction\n    }\n\n    // NOTE: estimateGas mutates the argument object and transforms the address to lowercase\n    // so this is a hack to make sure checksums are not destroyed\n    // Also, at the same time it's a hack for checking if the call will revert,\n    // since `eth_call` returns `0x` if the call fails and if the call returns nothing.\n    // So yeah...\n    const estimatedGasLimit = await this.web3.eth.estimateGas({ ...transaction, gas: undefined })\n    const recommendedGasLimit = await getRecommendedGasLimit(this.web3, estimatedGasLimit)\n\n    // If the gas provided in the intent is lower than the estimated gas, use the estimation\n    // when forwarding as it requires more gas and otherwise the transaction would go out of gas\n    if (!transaction.gas || (isForwarding && transaction.gas < recommendedGasLimit)) {\n      transaction.gas = recommendedGasLimit\n    }\n\n    if (!transaction.gasPrice) {\n      transaction.gasPrice = await this.getDefaultGasPrice(transaction.gas)\n    }\n\n    return transaction\n  }\n\n  /**\n   * Calculate the transaction path for a transaction to `destination`\n   * that invokes `methodSignature` with `params`.\n   *\n   * @param  {string} sender\n   * @param  {string} destination\n   * @param  {string} methodSignature\n   * @param  {Array<*>} params\n   * @param  {string} [finalForwarder] Address of the final forwarder that can perfom the action.\n   *                  Needed for actions that aren't in the ACL but whose execution depends on other factors\n   * @return {Promise<Array<Object>>} An array of Ethereum transactions that describe each step in the path\n   */\n  async calculateTransactionPath (sender, destination, methodSignature, params, finalForwarder) {\n    // Get the destination app\n    const app = await this.getApp(destination)\n    if (!app) {\n      throw new Error(`Transaction path destination (${destination}) is not an installed app`)\n    }\n\n    const method = findAppMethodFromSignature(app, methodSignature, { allowDeprecated: false })\n    if (!method) {\n      throw new Error(`No method named ${methodSignature} on ${destination}`)\n    }\n\n    // Create transaction for target action\n    const directTransaction = await createDirectTransactionForApp(sender, app, methodSignature, params, this.web3)\n\n    const finalForwarderProvided = isAddress(finalForwarder)\n\n    // We can already assume the user is able to directly invoke the action if:\n    //   - The method has no ACL requirements and no final forwarder was given, or\n    //   - The final forwarder matches the sender\n    if (\n      (method.roles.length === 0 && !finalForwarderProvided) ||\n      addressesEqual(finalForwarder, sender)\n    ) {\n      try {\n        // `applyTransactionGas` can throw if the transaction will fail\n        return [await this.applyTransactionGas(directTransaction)]\n      } catch (_) {\n        // If the direct transaction fails, we give up as we should have been able to\n        // perform the action directly\n        return []\n      }\n    }\n\n    // Failing this, attempt transaction pathing algorithm with forwarders\n    const forwarders = await this.forwarders.pipe(first()).toPromise().then(\n      (forwarders) => forwarders.map(\n        (forwarder) => forwarder.proxyAddress\n      )\n    )\n\n    let forwardersWithPermission\n    if (finalForwarderProvided) {\n      if (!includesAddress(forwarders, finalForwarder)) {\n        // Final forwarder was given, but did not match any available forwarders, so no path\n        // could be found\n        return []\n      }\n\n      // Only attempt to find path with declared final forwarder; assume the final forwarder\n      // is able to invoke the action\n      forwardersWithPermission = [finalForwarder]\n    } else {\n      // Find entities with the required permissions\n      const permissions = await this.permissions.pipe(first()).toPromise()\n      const destinationPermissions = permissions[destination]\n      const roleSig = app.roles.find(\n        (role) => role.id === method.roles[0]\n      ).bytes\n      const allowedEntities = dotprop.get(\n        destinationPermissions,\n        `${roleSig}.allowedEntities`,\n        []\n      )\n\n      // No one has access, so of course we don't as well\n      if (allowedEntities.length === 0) {\n        return []\n      }\n\n      // User may have permission; attempt direct transaction\n      if (\n        includesAddress(allowedEntities, sender) ||\n        includesAddress(allowedEntities, ANY_ENTITY)\n      ) {\n        try {\n          // `applyTransactionGas` can throw if the transaction will fail\n          return [await this.applyTransactionGas(directTransaction)]\n        } catch (_) {\n          // Don't immediately fail as the permission could have parameters applied that\n          // disallows the user from the current action and forces us to use the full\n          // pathing algorithm\n        }\n      }\n\n      // Find forwarders with permission to perform the action\n      forwardersWithPermission = forwarders.filter(\n        (forwarder) => includesAddress(allowedEntities, forwarder)\n      )\n    }\n\n    return this.calculateForwardingPath(sender, destination, directTransaction, forwardersWithPermission)\n  }\n\n  /**\n   * Calculate the forwarding path for a transaction to `destination`\n   * that invokes `directTransaction`.\n   *\n   * @param  {string} sender\n   * @param  {string} destination\n   * @param  {Object} directTransaction\n   * @param  {string} [forwardersWithPermission]\n   * @return {Array<Object>} An array of Ethereum transactions that describe each step in the path\n   */\n  async calculateForwardingPath (sender, destination, directTransaction, forwardersWithPermission) {\n    // No forwarders can perform the requested action\n    if (forwardersWithPermission.length === 0) {\n      return []\n    }\n\n    // TODO: handle pretransactions specified in the intent\n    // This is difficult to do generically, as some pretransactions\n    // (e.g. token approvals) only work if they're for a specific target\n    delete directTransaction.pretransaction\n\n    const createForwarderTransaction = createForwarderTransactionBuilder(sender, directTransaction, this.web3)\n\n    // Check if one of the forwarders that has permission to perform an action\n    // with `sig` on `address` can forward for us directly\n    for (const forwarder of forwardersWithPermission) {\n      const script = encodeCallScript([directTransaction])\n      if (await this.canForward(forwarder, sender, script)) {\n        const transaction = createForwarderTransaction(forwarder, script)\n        try {\n          const transactionWithFee = await applyForwardingFeePretransaction(transaction, this.web3)\n          // `applyTransactionGas` can throw if the transaction will fail\n          // If that happens, we give up as we should've been able to perform the action with this\n          // forwarder\n          return [await this.applyTransactionGas(transactionWithFee, true), directTransaction]\n        } catch (err) {\n          return []\n        }\n      }\n    }\n\n    // Get a list of all forwarders (excluding the forwarders with direct permission)\n    const forwarders = await this.forwarders.pipe(first()).toPromise().then(\n      (forwarders) => forwarders\n        .map((forwarder) => forwarder.proxyAddress)\n        .filter((forwarder) => !includesAddress(forwardersWithPermission, forwarder))\n    )\n\n    // Set up the path finding queue\n    // The queue takes the form of Array<[Array<EthereumTransaction>, Array<String>]>\n    // In other words: it is an array of tuples, where the first index of the tuple\n    // is the current path and the second index of the tuple is the\n    // queue (a list of unexplored forwarder addresses) for that path\n    const queue = forwardersWithPermission.map((forwarderWithPermission) => {\n      return [\n        [\n          createForwarderTransaction(forwarderWithPermission, encodeCallScript([directTransaction])),\n          directTransaction\n        ], forwarders\n      ]\n    })\n\n    // Find the shortest path via a breadth-first search of forwarder paths.\n    // We do a breadth-first instead of depth-first search because:\n    //   - We assume that most forwarding paths will be quite short, so it should be faster\n    //     to check in \"stages\" rather than exhaust single paths\n    //   - We don't currently protect against cycles in the path, and so exhausting single\n    //     paths can be wasteful if they result in dead ends\n    // TODO(onbjerg): Should we find and return multiple paths?\n    do {\n      const [path, [forwarder, ...nextQueue]] = queue.shift()\n\n      // Skip if no forwarder or the path is longer than 5\n      if (!forwarder || path.length > 5) continue\n\n      // Get the previous forwarder address\n      const previousForwarder = path[0].to\n\n      // Encode the previous transaction into an EVM callscript\n      const script = encodeCallScript([path[0]])\n\n      if (await this.canForward(previousForwarder, forwarder, script)) {\n        if (await this.canForward(forwarder, sender, script)) {\n          // The previous forwarder can forward a transaction for this forwarder,\n          // and this forwarder can forward for our address, so we have found a path\n          const transaction = createForwarderTransaction(forwarder, script)\n\n          // Only apply pretransactions and gas to the first transaction in the path\n          // as it's the only one that will be executed by the user\n          try {\n            const transactionWithFee = await applyForwardingFeePretransaction(transaction, this.web3)\n            // `applyTransactionGas` can throw if the transaction will fail\n            // If that happens, we give up as we should've been able to perform the action with this\n            // forwarding path\n            return [await this.applyTransactionGas(transactionWithFee, true), ...path]\n          } catch (err) {\n            return []\n          }\n        } else {\n          // The previous forwarder can forward a transaction for this forwarder,\n          // but this forwarder can not forward for our address, so we add it as a\n          // possible path in the queue for later exploration.\n          queue.push([\n            [createForwarderTransaction(forwarder, script), ...path],\n            // Avoid including the current forwarder as a candidate for the next step\n            // in the path. Note that this is naive and may result in repeating cycles,\n            // but the maximum path length would prevent against infinite loops\n            forwarders.filter((nextForwarder) => nextForwarder !== forwarder)\n          ])\n        }\n      }\n\n      // We add the current path on the back of the queue again, but we shorten\n      // the list of possible forwarders.\n      queue.push([path, nextQueue])\n    } while (queue.length)\n\n    return []\n  }\n}\n\n// Re-export some web3 utilities\nexport { apm, getRecommendedGasLimit }\nexport { resolve as ensResolve } from './ens'\n\n// Re-export the AddressIdentityProvider abstract base class\nexport { AddressIdentityProvider } from './identity'\n\n// Re-export the Aragon RPC providers\nexport { providers } from '@aragon/rpc-messenger'\n"],"file":"index.js"}