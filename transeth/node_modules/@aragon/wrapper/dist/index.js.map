{"version":3,"file":"index.js","names":["detectProvider","web3","currentProvider","Aragon","constructor","daoAddress","options","defaultOptions","defaultGasPriceFn","provider","cache","forceLocalStorage","prefix","events","subscriptionDelayTime","Object","assign","setConfiguration","configurationKeys","FORCE_LOCAL_STORAGE","SUBSCRIPTION_EVENT_DELAY","Number","isFinite","subscriptionEventDelay","PAST_EVENTS_BLOCK_SIZE","blockSizeLimit","Web3","ens","apm","ensRegistryAddress","ipfs","apmIpfsOptions","fetchTimeout","ipfsGateway","gateway","kernelProxy","makeProxy","cachePrefix","Cache","appContextPool","AppContextPool","init","aclAddress","call","_","Error","updateInitializationBlock","initAccounts","accounts","initAcl","acl","initIdentityProviders","initApps","initForwarders","initAppIdentifiers","initNetwork","network","initGuiStyle","guiStyle","pathIntents","Subject","transactions","signatures","fetchFromWeb3","providedAccounts","ReplaySubject","concat","eth","getAccounts","setAccounts","aclProxy","initializationBlock","ACL_CACHE_KEY","getCacheKey","currentBlock","getBlockNumber","cacheBlockHeight","Math","max","cachedAclState","get","permissions","cachedPermissions","blockNumber","cachedBlockNumber","pastEventsOptions","toBlock","fromBlock","pastEvents$","pastEvents","pipe","mergeMap","from","endWith","event","returnValues","currentEvents$","startWith","fetchedPermissions$","scan","eventData","app","appPermissions","key","role","allowedEntitiesSet","Set","dotprop","allowed","add","entity","delete","set","Array","manager","makeAddressMapProxy","map","debounceTime","publishReplay","connect","cachedPermissions$","of","isApp","kernelAddress","isKernelAddress","address","addressesEqual","applicationInfoCache","AsyncRequestCache","cacheKey","appId","codeAddress","split","getAragonOsInternalAppInfo","getApmInternalAppInfo","fetchLatestRepoContentForContract","resolve","proxyContractValueCache","proxyAddress","Promise","all","then","values","appProxy","appProxyForwarder","catch","isForwarder","installedApps$","keys","distinctUntilChanged","oldProxies","newProxies","length","oldSet","intersection","filter","newProxy","has","size","proxyAddresses","appsWithoutKernel","switchMap","proxyValues","request","appProxies","updatedApps$","isKernelAppCodeNamespace","namespace","withLatestFrom","setAppEvent","apps","setAppId","updated","concatMap","updatedApps","apps$","merge","appsWithInfo$","appInfo","isForwarderOverride","isArray","abi","some","type","name","installedRepoCache","Map","repo$","isAragonOsInternalApp","reduce","installedRepos","contractAddress","repos","newRepoAppIds","updatedRepoAppIds","forEach","repo","push","newRepos","repoProxy","repoAddress","makeRepoProxy","err","console","error","update$","newRepo$","repoAddress$","version$","initialVersions","getAllRepoVersions","versionId","eventVersionId","timestamp","getBlock","versionIndex","findIndex","versionInfo","getRepoVersionById","newVersionInfo","versions","newVersions","mergeAll","repoUpdate","updatedAppId","update","updatedRepoInfo","updatedRepoAppId","installedRepoInfo","baseRepoInfo","fetchVersionInfo","version","content","latestVersion","currentVersion","reverse","find","currentVersionInfoRequest","latestVersionInfoRequest","updatedRepo","repoIndex","nextRepos","throttleTime","asyncScheduler","leading","trailing","forwarders","appIdentifiers","BehaviorSubject","identifiers","identifier","setAppIdentifier","next","defaultIdentityProviders","LocalIdentityProvider","identityProviders","identityProviderRegistrar","identityIntents","modifyAddressIdentity","metadata","modify","reject","resolveAddressIdentity","searchIdentities","searchTerm","search","requestAddressIdentityModification","providerName","removeLocalIdentities","addresses","localProvider","remove","getLocalIdentities","getAll","appearance","theme","setGuiStyle","id","getChainId","net","getNetworkType","requestAppPath","appAddress","path","getApp","setAppPath","emit","APP_CONTEXTS","PATH","runApp","first","toPromise","makeProxyFromAppABI","sandboxMessengerProvider","messenger","Messenger","request$","requests","proxy","wrapper","handlerSubscription","handlers","combineRequestHandlers","createRequestHandler","describeScript","describeTransaction","getApps","trigger","web3Eth","intent","signMessage","externalCall","externalEvents","externalIntent","externalPastEvents","appIdentifier","addressIdentity","subscribe","response","sendResponse","payload","shutdown","unsubscribe","shutdownAndClearCache","promise","startsWith","message","requestingApp","performTransactionPath","transactionPath","external","transaction","performACLIntent","method","params","getACLTransactionPath","getTransactionPath","destination","methodSignature","finalForwarder","account","calculateTransactionPath","describeTransactionPath","getExternalTransactionPath","methodAbiFragment","installedApp","tx","createDirectTransaction","getTransactionPathForIntentBasket","intentBasket","checkMode","intentsToCheck","intentPaths","pathsMatch","doIntentPathsMatch","sender","directTransactions","createDirectTransactionForApp","decoratedTransactions","applyTransactionGas","createForwarderTransaction","createForwarderTransactionBuilder","forwarderPath","slice","to","nextForwarder","lastStep","encodedLastStep","encodeCallScript","getPermissionManager","roleHash","aclAddr","findAppMethodFromSignature","allowDeprecated","roles","findMethodAbiFragment","inputNames","inputs","input","appIndex","indexOf","roleIndex","decodeTransactionPath","script","isCallScript","decodeCallScript","segment","data","isValidForwardCall","forwardedEvmScript","parseForwardCall","children","step","decoratedStep","tryDescribingUpgradeOrganizationBasket","tryDescribingUpdateAppIntent","tryEvaluatingRadspec","description","processed","postprocessRadspecDescription","annotatedDescription","canForward","forwarder","Contract","getAbi","methods","getDefaultGasPrice","gasLimit","isForwarding","pretransaction","estimatedGasLimit","estimateGas","gas","recommendedGasLimit","getRecommendedGasLimit","gasPrice","directTransaction","finalForwarderProvided","isAddress","forwardersWithPermission","includesAddress","destinationPermissions","roleSig","bytes","allowedEntities","ANY_ENTITY","calculateForwardingPath","transactionWithFee","applyForwardingFeePretransaction","queue","forwarderWithPermission","nextQueue","shift","previousForwarder"],"sources":["../src/index.js"],"sourcesContent":["// Externals\nimport { asyncScheduler, concat, from, merge, of, BehaviorSubject, ReplaySubject, Subject } from 'rxjs'\nimport {\n  concatMap,\n  debounceTime,\n  distinctUntilChanged,\n  endWith,\n  filter,\n  first,\n  map,\n  mergeAll,\n  mergeMap,\n  publishReplay,\n  scan,\n  startWith,\n  switchMap,\n  throttleTime,\n  withLatestFrom\n} from 'rxjs/operators'\nimport Web3 from 'web3'\nimport { isAddress } from 'web3-utils'\nimport dotprop from 'dot-prop'\n\n// RPC\nimport Messenger from '@aragon/rpc-messenger'\nimport * as handlers from './rpc/handlers'\n\nimport AppContextPool, { APP_CONTEXTS } from './apps'\nimport Cache from './cache'\nimport apm, { getApmInternalAppInfo } from './core/apm'\nimport { makeRepoProxy, getAllRepoVersions, getRepoVersionById } from './core/apm/repo'\nimport {\n  getAragonOsInternalAppInfo,\n  isAragonOsInternalApp\n} from './core/aragonOS'\nimport { isKernelAppCodeNamespace } from './core/aragonOS/kernel'\nimport { setConfiguration } from './configuration'\nimport * as configurationKeys from './configuration/keys'\nimport ens from './ens'\nimport { LocalIdentityProvider } from './identity'\nimport { getAbi } from './interfaces'\nimport {\n  postprocessRadspecDescription,\n  tryDescribingUpdateAppIntent,\n  tryDescribingUpgradeOrganizationBasket,\n  tryEvaluatingRadspec\n} from './radspec'\nimport {\n  ANY_ENTITY,\n  addressesEqual,\n  getCacheKey,\n  includesAddress,\n  makeAddressMapProxy,\n  makeProxy,\n  makeProxyFromAppABI,\n  AsyncRequestCache\n} from './utils'\nimport { findMethodAbiFragment } from './utils/abi'\nimport { findAppMethodFromSignature } from './utils/apps'\nimport { decodeCallScript, encodeCallScript, isCallScript } from './utils/callscript'\nimport { isValidForwardCall, parseForwardCall } from './utils/forwarding'\nimport { doIntentPathsMatch } from './utils/intents'\nimport {\n  applyForwardingFeePretransaction,\n  createDirectTransaction,\n  createDirectTransactionForApp,\n  createForwarderTransactionBuilder,\n  getRecommendedGasLimit\n} from './utils/transactions'\n\n// Try to get an injected web3 provider, return a public one otherwise.\nexport const detectProvider = () =>\n  typeof web3 !== 'undefined'\n    ? web3.currentProvider // eslint-disable-line\n    : 'wss://rinkeby.eth.aragon.network/ws'\n\n/**\n * An Aragon wrapper.\n *\n * @param {string} daoAddress\n *        The address of the DAO.\n * @param {Object} options\n *        Wrapper options.\n * @param {Object} options.apm\n *        Options for fetching information from aragonPM\n * @param {string} options.apm.ensRegistryAddress\n *        ENS registry for aragonPM\n * @param {Object} [options.apm.ipfs]\n *        IPFS provider config for aragonPM\n * @param {string} [options.apm.ipfs.gateway]\n *        IPFS gateway to fetch aragonPM artifacts from\n * @param {number} [options.apm.ipfs.fetchTimeout]\n *        Timeout for retrieving aragonPM artifacts from IPFS before failing\n * @param {Object} [options.cache]\n *        Options for the internal cache\n * @param {boolean} [options.cache.forceLocalStorage=false]\n *        Downgrade to localStorage even if IndexedDB is available\n * @param {Object} [options.events]\n *        Options for handling Ethereum events\n * @param {boolean} [options.events.subscriptionEventDelay]\n *        Time in ms to delay a new event from a contract subscription\n * @param {Object} [options.events.blockSizeLimit]\n *        Optional max amount of blocks to fetch from past events\n * @param {Function} [options.defaultGasPriceFn=function]\n *        A factory function to provide the default gas price for transactions.\n *        It can return a promise of number string or a number string. The function\n *        has access to a recommended gas limit which can be used for custom\n *        calculations. This function can also be used to get a good gas price\n *        estimation from a 3rd party resource.\n * @param {string|Object} [options.provider=web3.currentProvider]\n *        The Web3 provider to use for blockchain communication. Defaults to `web3.currentProvider`\n *        if web3 is injected, otherwise will fallback to wss://rinkeby.eth.aragon.network/ws\n */\nexport default class Aragon {\n  constructor (daoAddress, options = {}) {\n    const defaultOptions = {\n      defaultGasPriceFn: () => {},\n      provider: detectProvider(),\n      cache: {\n        forceLocalStorage: false,\n        prefix: null\n      },\n      events: {\n        subscriptionDelayTime: 0\n      }\n    }\n    options = Object.assign(defaultOptions, options)\n\n    // Set up desired configuration\n    setConfiguration(\n      configurationKeys.FORCE_LOCAL_STORAGE,\n      !!(options.cache && options.cache.forceLocalStorage)\n    )\n\n    setConfiguration(\n      configurationKeys.SUBSCRIPTION_EVENT_DELAY,\n      Number.isFinite(options.events && options.events.subscriptionEventDelay)\n        ? options.events.subscriptionEventDelay\n        : 0\n    )\n\n    setConfiguration(\n      configurationKeys.PAST_EVENTS_BLOCK_SIZE,\n      (options.events && options.events.blockSizeLimit) ? options.events.blockSizeLimit : false\n    )\n\n    // Set up Web3\n    this.web3 = new Web3(options.provider)\n\n    // Set up ENS\n    this.ens = ens(options.provider, options.apm.ensRegistryAddress)\n\n    // Set up APM utilities\n    const { ipfs: apmIpfsOptions = {} } = options.apm\n    this.apm = apm(\n      this.web3,\n      {\n        fetchTimeout: apmIpfsOptions.fetchTimeout,\n        ipfsGateway: apmIpfsOptions.gateway\n      }\n    )\n\n    // Set up the kernel proxy\n    this.kernelProxy = makeProxy(daoAddress, 'Kernel', this.web3)\n\n    // Set up cache\n    const cachePrefix = options.cache.prefix ? `${options.cache.prefix}:${daoAddress}` : daoAddress\n    this.cache = new Cache(cachePrefix)\n\n    // Set up app contexts\n    this.appContextPool = new AppContextPool()\n\n    this.defaultGasPriceFn = options.defaultGasPriceFn\n  }\n\n  /**\n   * Initialise the wrapper.\n   *\n   * @param {Object} [options] Options\n   * @param {Object} [options.accounts] `initAccount()` options (see below)\n   * @param {Object} [options.acl] `initACL()` options (see below)\n   * @param {Object} [options.guiStyle] `initGuiStyle()` options (see below)\n   * @return {Promise<void>}\n   * @throws {Error} Will throw an error if the `daoAddress` is detected to not be a Kernel instance\n   */\n  async init (options = {}) {\n    let aclAddress\n\n    try {\n      // Check if address is kernel\n      // web3 throws if it's an empty address ('0x')\n      aclAddress = await this.kernelProxy.call('acl')\n    } catch (_) {\n      throw Error(`Provided daoAddress is not a DAO`)\n    }\n\n    await this.cache.init()\n    await this.kernelProxy.updateInitializationBlock()\n    await this.initAccounts(options.accounts)\n    await this.initAcl(Object.assign({ aclAddress }, options.acl))\n    await this.initIdentityProviders()\n    this.initApps()\n    this.initForwarders()\n    this.initAppIdentifiers()\n    this.initNetwork(options.network)\n    this.initGuiStyle(options.guiStyle)\n    this.pathIntents = new Subject()\n    this.transactions = new Subject()\n    this.signatures = new Subject()\n  }\n\n  /**\n   * Initialise the accounts observable.\n   *\n   * @param {Object} [options] Options\n   * @param {boolean} [options.fetchFromWeb3] Whether or not accounts should also be fetched from\n   *                                          the provided Web3 instance\n   * @param {Array<string>} [options.providedAccounts] Array of accounts that the user controls\n   * @return {Promise<void>}\n   */\n  async initAccounts ({ fetchFromWeb3, providedAccounts = [] } = {}) {\n    this.accounts = new ReplaySubject(1)\n    const accounts = fetchFromWeb3\n      ? providedAccounts.concat(await this.web3.eth.getAccounts())\n      : providedAccounts\n\n    this.setAccounts(accounts)\n  }\n\n  /**\n   * Initialise the ACL (Access Control List).\n   *\n   * @return {Promise<void>}\n   */\n  async initAcl ({ aclAddress } = {}) {\n    if (!aclAddress) {\n      aclAddress = await this.kernelProxy.call('acl')\n    }\n\n    // Set up ACL proxy\n    this.aclProxy = makeProxy(aclAddress, 'ACL', this.web3, { initializationBlock: this.kernelProxy.initializationBlock })\n\n    const SET_PERMISSION_EVENT = 'SetPermission'\n    const CHANGE_PERMISSION_MANAGER_EVENT = 'ChangePermissionManager'\n\n    const ACL_CACHE_KEY = getCacheKey(aclAddress, 'acl')\n\n    const REORG_SAFETY_BLOCK_AGE = 100\n\n    const currentBlock = await this.web3.eth.getBlockNumber()\n    const cacheBlockHeight = Math.max(currentBlock - REORG_SAFETY_BLOCK_AGE, 0) // clamp to 0 for safety\n\n    // Check if we have cached ACL for this address\n    // Cache object for an ACL: { permissions, blockNumber }\n    const cachedAclState = await this.cache.get(ACL_CACHE_KEY, {})\n    const { permissions: cachedPermissions, blockNumber: cachedBlockNumber } = cachedAclState\n\n    const pastEventsOptions = {\n      toBlock: cacheBlockHeight,\n      // When using cache, fetch events from the next block after cache\n      fromBlock: cachedPermissions ? cachedBlockNumber + 1 : undefined\n    }\n    const pastEvents$ = this.aclProxy.pastEvents(null, pastEventsOptions).pipe(\n      mergeMap((pastEvents) => from(pastEvents)),\n      // Custom cache event\n      endWith({\n        event: ACL_CACHE_KEY,\n        returnValues: {}\n      })\n    )\n    const currentEvents$ = this.aclProxy.events(null, { fromBlock: cacheBlockHeight + 1 }).pipe(\n      startWith({\n        event: 'starting current events',\n        returnValues: {}\n      })\n    )\n\n    // Permissions Object:\n    // { app -> role -> { manager, allowedEntities -> [ entities with permission ] } }\n    const fetchedPermissions$ = concat(pastEvents$, currentEvents$).pipe(\n      scan(([permissions], event) => {\n        const eventData = event.returnValues\n\n        if (eventData.app) {\n          // NOTE: dotprop.get() doesn't work through proxies, so we manually access permissions\n          const appPermissions = permissions[eventData.app] || {}\n\n          if (event.event === SET_PERMISSION_EVENT) {\n            const key = `${eventData.role}.allowedEntities`\n\n            // Converts to and from a set to avoid duplicated entities\n            const allowedEntitiesSet = new Set(dotprop.get(appPermissions, key, []))\n\n            if (eventData.allowed) {\n              allowedEntitiesSet.add(eventData.entity)\n            } else {\n              allowedEntitiesSet.delete(eventData.entity)\n            }\n\n            dotprop.set(appPermissions, key, Array.from(allowedEntitiesSet))\n          }\n\n          if (event.event === CHANGE_PERMISSION_MANAGER_EVENT) {\n            // We only care about the last one. An app permission can have only one manager\n            dotprop.set(appPermissions, `${eventData.role}.manager`, eventData.manager)\n          }\n\n          permissions[eventData.app] = appPermissions\n        }\n\n        return [permissions, event]\n      }, [ makeAddressMapProxy(cachedPermissions || {}) ]),\n\n      // Cache if we're finished syncing up to cache block height\n      map(([permissions, event]) => {\n        if (event.event === ACL_CACHE_KEY) {\n          this.cache.set(\n            ACL_CACHE_KEY,\n            // Make copy for cache\n            { permissions: Object.assign({}, permissions), blockNumber: cacheBlockHeight }\n          )\n        }\n        return permissions\n      }),\n\n      // Throttle so it only continues after 30ms without new values\n      // Avoids DDOSing subscribers as during initialization there may be\n      // hundreds of events processed in a short timespan\n      debounceTime(30),\n      publishReplay(1)\n    )\n    fetchedPermissions$.connect()\n\n    const cachedPermissions$ = cachedPermissions ? of(makeAddressMapProxy(cachedPermissions)) : of()\n    this.permissions = concat(cachedPermissions$, fetchedPermissions$).pipe(publishReplay(1))\n    this.permissions.connect()\n  }\n\n  /**\n   * Check if an object is an app.\n   *\n   * @param  {Object}  app\n   * @return {boolean}\n   */\n  isApp (app) {\n    return app.kernelAddress && this.isKernelAddress(app.kernelAddress)\n  }\n\n  /**\n   * Check if an address is this DAO's kernel.\n   *\n   * @param  {string}  address\n   * @return {boolean}\n   */\n  isKernelAddress (address) {\n    return addressesEqual(address, this.kernelProxy.address)\n  }\n\n  /**\n   * Initialize apps observable.\n   *\n   * @return {void}\n   */\n  initApps () {\n    /******************************\n     *                            *\n     *          CACHING           *\n     *                            *\n     ******************************/\n\n    const applicationInfoCache = new AsyncRequestCache(async (cacheKey) => {\n      const [appId, codeAddress] = cacheKey.split('.')\n      return getAragonOsInternalAppInfo(appId) ||\n        getApmInternalAppInfo(appId) ||\n        this.apm.fetchLatestRepoContentForContract(\n          await this.ens.resolve(appId),\n          codeAddress\n        )\n    })\n\n    const proxyContractValueCache = new AsyncRequestCache((proxyAddress) => {\n      if (this.isKernelAddress(proxyAddress)) {\n        const kernelProxy = makeProxy(proxyAddress, 'ERCProxy', this.web3)\n\n        return Promise.all([\n          // Use Kernel ABI\n          this.kernelProxy.call('KERNEL_APP_ID'),\n          // Use ERC897 proxy ABI\n          // Note that this won't work on old Aragon Core 0.5 Kernels,\n          // as they had not implemented ERC897 yet\n          kernelProxy.call('implementation')\n        ]).then((values) => ({\n          appId: values[0],\n          codeAddress: values[1]\n        }))\n      }\n\n      const appProxy = makeProxy(proxyAddress, 'AppProxy', this.web3)\n      const appProxyForwarder = makeProxy(proxyAddress, 'Forwarder', this.web3)\n\n      return Promise.all([\n        appProxy.call('kernel'),\n        appProxy.call('appId'),\n        appProxy.call('implementation'),\n        // Not all apps implement the forwarding interface\n        appProxyForwarder.call('isForwarder').catch(() => false)\n      ]).then((values) => ({\n        kernelAddress: values[0],\n        appId: values[1],\n        codeAddress: values[2],\n        isForwarder: values[3]\n      }))\n    })\n\n    /******************************\n     *                            *\n     *            APPS            *\n     *                            *\n     ******************************/\n\n    // Get all installed app proxy addresses\n    const installedApps$ = this.permissions.pipe(\n      map(Object.keys),\n      // Dedupe until apps change\n      distinctUntilChanged((oldProxies, newProxies) => {\n        if (oldProxies.length !== newProxies.length) {\n          return false\n        }\n        const oldSet = new Set(oldProxies)\n        const intersection = new Set(newProxies.filter(newProxy => oldSet.has(newProxy)))\n        return intersection.size === oldSet.size\n      }),\n      // Add Kernel as the first \"app\"\n      map((proxyAddresses) => {\n        const appsWithoutKernel = proxyAddresses.filter((address) => !this.isKernelAddress(address))\n        return [this.kernelProxy.address].concat(appsWithoutKernel)\n      }),\n      // Get proxy values\n      // Note that we can safely discard throttled values,\n      // so we use a `switchMap()` instead of a `mergeMap()`\n      switchMap(\n        (proxyAddresses) => Promise.all(\n          proxyAddresses.map(async (proxyAddress) => {\n            let proxyValues\n            try {\n              proxyValues = await proxyContractValueCache.request(proxyAddress)\n            } catch (_) {}\n\n            return {\n              proxyAddress,\n              ...proxyValues\n            }\n          })\n        )\n      ),\n      // Filter to remove any non-apps assigned in permissions\n      map(appProxies => appProxies.filter(\n        (appProxy) => this.isApp(appProxy) || this.isKernelAddress(appProxy.proxyAddress)\n      ))\n    )\n\n    // SetApp events are emitted when apps are installed and upgraded\n    // These may modify the implementation addresses of the proxies (modifying their behaviour), so\n    // we invalidate any caching we've done\n    const updatedApps$ = this.kernelProxy\n      // Only need to subscribe from latest block\n      .events('SetApp', { fromBlock: 'latest' })\n      .pipe(\n        // Only care about changes if they're in the APP_BASE namespace\n        filter(({ returnValues }) => isKernelAppCodeNamespace(returnValues.namespace)),\n\n        // Merge with latest value of installedApps$ so we can return the full list of apps\n        withLatestFrom(\n          installedApps$,\n          function updateApps (setAppEvent, apps) {\n            const { appId: setAppId } = setAppEvent.returnValues\n            return apps.map(async (app) => {\n              if (app.appId !== setAppId) {\n                return app\n              }\n\n              let proxyValues\n              try {\n                proxyValues = await proxyContractValueCache.request(\n                  app.proxyAddress,\n                  true // force cache invalidation\n                )\n              } catch (_) {}\n\n              return {\n                ...app,\n                ...proxyValues,\n                updated: true\n              }\n            })\n          }\n        ),\n        // Emit resolved array of promises, one at a time\n        concatMap(updatedApps => Promise.all(updatedApps))\n      )\n\n    // We merge these two observables, which both return the full list of apps attached with their\n    // proxy values:\n    //   - installedApps$: emits any time the list of installed apps changes\n    //   - updatedApps$:   emits any time SetApp could modify an installed app\n    const apps$ = merge(installedApps$, updatedApps$)\n\n    // Get artifact info for apps\n    const appsWithInfo$ = apps$.pipe(\n      concatMap(\n        (apps) => Promise.all(\n          apps.map(async (app) => {\n            let appInfo\n            if (app.appId && app.codeAddress) {\n              const cacheKey = `${app.appId}.${app.codeAddress}`\n              try {\n                appInfo = await applicationInfoCache.request(cacheKey)\n              } catch (_) { }\n            }\n\n            // This is a hack to fix web3.js and ethers not being able to detect reverts on decoding\n            // `eth_call`s (apps that implement fallbacks may revert if they haven't defined\n            // `isForwarder()`)\n            // Ideally web3.js would throw an error if it receives a revert from an `eth_call`, but\n            // as of v1.2.1, it interprets reverts as `true` :(.\n            //\n            // We check if the app's ABI actually has `isForwarder()` declared, and if not, override\n            // the isForwarder setting to false.\n            let isForwarderOverride = {}\n            if (\n              app.isForwarder &&\n              appInfo &&\n              Array.isArray(appInfo.abi) &&\n              !appInfo.abi.some(({ type, name }) => type === 'function' && name === 'isForwarder')\n            ) {\n              isForwarderOverride = {\n                isForwarder: false\n              }\n            }\n\n            return {\n              ...appInfo,\n              // Override the fetched appInfo with the actual app proxy's values to avoid mismatches\n              ...app,\n              // isForwarder override (see above)\n              ...isForwarderOverride\n            }\n          })\n        )\n      )\n    )\n\n    this.apps = appsWithInfo$.pipe(\n      publishReplay(1)\n    )\n    this.apps.connect()\n\n    /*******************************\n     *                             *\n     *            REPOS            *\n     *                             *\n     ******************************/\n\n    // Initialize installed repos from the list of apps\n    const installedRepoCache = new Map()\n    const repo$ = apps$.pipe(\n      // Map installed apps into a deduped list of their aragonPM repos, with these assumptions:\n      //   - No apps are lying about their appId (malicious apps _could_ masquerade as other\n      //     apps by setting this value themselves)\n      //   - `contractAddress`s will stay the same across all installed apps.\n      //     This is technically not true as apps could set this value themselves\n      //     (e.g. as pinned apps do), but these apps wouldn't be able to upgrade anyway\n      //\n      //  Ultimately returns an array of objects, holding the repo's:\n      //    - appId\n      //    - base contractAddress\n      map((apps) => Object.values(\n        apps\n          .filter(({ appId }) => !isAragonOsInternalApp(appId))\n          .reduce((installedRepos, { appId, codeAddress, updated }) => {\n            installedRepos[appId] = {\n              appId,\n              updated,\n              contractAddress: codeAddress\n            }\n            return installedRepos\n          }, {})\n      )),\n\n      // Filter list of installed repos into:\n      //   - New repos we haven't seen before (to begin subscribing to their version events)\n      //   - Repos we've seen before, to trigger a recalculation of the currently installed version\n      map((repos) => {\n        const newRepoAppIds = []\n        const updatedRepoAppIds = []\n\n        repos.forEach((repo) => {\n          const { appId, updated } = repo\n          if (!installedRepoCache.has(appId)) {\n            newRepoAppIds.push(appId)\n          } else if (updated) {\n            updatedRepoAppIds.push(appId)\n          }\n\n          // Mark repo as seen and cache installed information\n          installedRepoCache.set(appId, repo)\n        })\n\n        return [newRepoAppIds, updatedRepoAppIds]\n      }),\n\n      // Stop if there's no new repos or updated apps\n      filter(([newRepoAppIds, updatedRepoAppIds]) =>\n        newRepoAppIds.length || updatedRepoAppIds.length\n      ),\n\n      // Project new repos into their ids and web3 proxy objects\n      concatMap(async ([newRepoAppIds, updatedRepoAppIds]) => {\n        const newRepos = (await Promise.all(\n          newRepoAppIds.map(async (appId) => {\n            let repoProxy\n\n            try {\n              const repoAddress = await this.ens.resolve(appId)\n              repoProxy = makeRepoProxy(repoAddress, this.web3)\n              await repoProxy.updateInitializationBlock()\n            } catch (err) {\n              console.error(`Could not find repo for ${appId}`, err)\n            }\n\n            return {\n              appId,\n              repoProxy\n            }\n          })\n        ))\n          // Filter out repos we couldn't create proxies for (they were likely due to publishing\n          // invalid aragonPM repos)\n          // Note that we don't need to worry about doing this for the updated repos list; if\n          // we could not create the original repo proxy when we first saw the repo, the updates\n          // won't do anything because we weren't able to fetch enough information (versions list)\n          .filter((newRepos) => newRepos.repoProxy)\n        return [newRepos, updatedRepoAppIds]\n      }),\n\n      // Here's where the fun begins!\n      // It'll be easy to get lost, so remember to take it slowly.\n      // Just remember, with this `mergeMap()`, we'll be subscribing to all the projected (returned)\n      // observables and merging their respective emissions into a single observable.\n      //\n      // The output of this merged observable are update events containing the following:\n      //   - `appId`: mandatory, signifies which repo was updated\n      //   - `repoAddress`: optional, address of the repo contract itself\n      //   - `versions`: optional, new version information\n      mergeMap(([newRepos, updatedRepoAppIds]) => {\n        // Create a new observable to project each new update as its own update emission.\n        const update$ = of(...updatedRepoAppIds).pipe(\n          map((appId) => ({ appId }))\n        )\n\n        // Create a new observable to project each new repo as its own emission.\n        const newRepo$ = of(...newRepos)\n\n        // Create a new observable to project each new repo's address as its own update emission.\n        const repoAddress$ = newRepo$.pipe(\n          map(({ appId, repoProxy }) => ({\n            appId,\n            repoAddress: repoProxy.address\n          }))\n        )\n\n        // Create a new observable that projects each NewVersion event as its own update event\n        // emission.\n        // This one is a bit trickier, due to the higher order observable. Keep reading.\n        const version$ = newRepo$.pipe(\n          // `mergeMap()` to \"flatten\" the async transformation. This async function returns an\n          // observable, which is ultimately the NewVersion stream. More on this, after the break.\n          // Note: we don't care about the ordering, so we use `mergeMap()` instead of `concatMap()`\n          mergeMap(async ({ appId, repoProxy }) => {\n            const initialVersions = [\n              // Immediately query state from the repo contract, to avoid having to wait until all\n              // past events sync (may be long)\n              ...await getAllRepoVersions(repoProxy)\n            ]\n\n            // Return an observable subscribed to NewVersion events, giving us:\n            //   - Timestamps for versions that were published prior to this process running\n            //   - Notifications for newly published versions\n            //\n            // Reduce this with the cached version information to emit version updates for the repo.\n            return repoProxy.events('NewVersion').pipe(\n              // Project each event to a new version info object, one at a time\n              concatMap(async (event) => {\n                const { versionId: eventVersionId } = event.returnValues\n\n                // Adjust from Ethereum time\n                const timestamp = (await this.web3.eth.getBlock(event.blockNumber)).timestamp * 1000\n\n                const versionIndex = initialVersions.findIndex(({ versionId }) => versionId === eventVersionId)\n                const versionInfo =\n                  versionIndex === -1\n                    ? await getRepoVersionById(repoProxy, eventVersionId)\n                    : initialVersions[versionIndex]\n\n                return {\n                  ...versionInfo,\n                  timestamp\n                }\n              }),\n\n              // Trick to immediately emit (e.g. similar to a do/while loop)\n              startWith(null),\n\n              // Reduce newly emitted versions into the full list of versions\n              scan(({ appId, versions }, newVersionInfo) => {\n                let newVersions = versions\n                if (newVersionInfo) {\n                  const versionIndex = versions.findIndex(({ versionId }) => versionId === newVersionInfo.versionId)\n\n                  if (versionIndex === -1) {\n                    newVersions = versions.concat(newVersionInfo)\n                  } else {\n                    newVersions = Array.from(versions)\n                    newVersions[versionIndex] = newVersionInfo\n                  }\n                }\n\n                return {\n                  appId,\n                  versions: newVersions\n                }\n              }, {\n                appId,\n                versions: initialVersions\n              })\n            )\n          }),\n\n          // This bit is interesting.\n          // We've \"flattened\" our async transformation with the `mergeMap()` above, but it still\n          // returns an observable. We need to flatten this observable's emissions into the upper\n          // stream, which is what `mergeAll()` achieves.\n          mergeAll()\n        )\n\n        // Merge all of the repo update events resulting from the apps being updated, and return it\n        // to the upper `mergeMap()` so it can be re-flattened into a single event stream.\n        return merge(repoAddress$, version$, update$)\n      }),\n\n      // Reduce the event stream into a current representation of the installed repos, and which\n      // repo to update next.\n      scan(({ repos }, repoUpdate) => {\n        const { appId: updatedAppId, ...update } = repoUpdate\n        const updatedRepoInfo = {\n          ...repos[updatedAppId],\n          ...update\n        }\n\n        return {\n          repos: {\n            ...repos,\n            [updatedAppId]: updatedRepoInfo\n          },\n          updatedRepoAppId: updatedAppId\n        }\n      }, {\n        repos: {},\n        updatedRepoAppId: null\n      }),\n\n      // Stop if we don't have enough information yet to continue\n      filter(({ repos, updatedRepoAppId }) =>\n        !!updatedRepoAppId && Array.isArray(repos[updatedRepoAppId].versions)\n      ),\n\n      // Grab the full information of the updated repo using its latest values.\n      // With this, we've taken the basic stream of updates for events and mapped them onto their\n      // full repo objects.\n      concatMap(async ({ repos, updatedRepoAppId: appId }) => {\n        const { repoAddress, versions } = repos[appId]\n        const installedRepoInfo = installedRepoCache.get(appId)\n\n        const baseRepoInfo = { appId, repoAddress, versions }\n        const fetchVersionInfo = version => {\n          return applicationInfoCache\n            .request(`${appId}.${version.contractAddress}`)\n            .catch(() => ({}))\n            .then(content => ({\n              content,\n              version: version.version\n            }))\n        }\n\n        const latestVersion = versions[versions.length - 1]\n        const currentVersion = Array.from(versions)\n          // Apply reverse to find the latest version with the currently installed contract address\n          .reverse()\n          .find(version => addressesEqual(version.contractAddress, installedRepoInfo.contractAddress))\n\n        if (!currentVersion) {\n          // The organization has installed an unpublished version of this app\n          // Avoid returning a current version as we don't know what version they're using\n          return {\n            ...baseRepoInfo,\n            currentVersion: null,\n            latestVersion: await fetchVersionInfo(latestVersion)\n          }\n        }\n\n        const currentVersionInfoRequest = fetchVersionInfo(currentVersion)\n        const latestVersionInfoRequest =\n          addressesEqual(currentVersion.contractAddress, latestVersion.contractAddress)\n            ? currentVersionInfoRequest\n            : fetchVersionInfo(latestVersion)\n\n        return {\n          ...baseRepoInfo,\n          currentVersion: await currentVersionInfoRequest,\n          latestVersion: await latestVersionInfoRequest\n        }\n      })\n    )\n\n    this.installedRepos = repo$.pipe(\n      // Finally, we reduce the merged updates from individual repos into one final, expanding array\n      // of the installed repos\n      scan((repos, updatedRepo) => {\n        const repoIndex = repos.findIndex(repo => repo.repoAddress === updatedRepo.repoAddress)\n        if (repoIndex === -1) {\n          return repos.concat(updatedRepo)\n        } else {\n          const nextRepos = Array.from(repos)\n          nextRepos[repoIndex] = updatedRepo\n          return nextRepos\n        }\n      }, []),\n      // Throttle updates, but must keep trailing to ensure we don't drop any updates\n      throttleTime(500, asyncScheduler, { leading: false, trailing: true }),\n      publishReplay(1)\n    )\n    this.installedRepos.connect()\n  }\n\n  /**\n   * Initialise forwarder observable.\n   *\n   * @return {void}\n   */\n  initForwarders () {\n    this.forwarders = this.apps.pipe(\n      map(\n        (apps) => apps.filter((app) => app.isForwarder)\n      ),\n      publishReplay(1)\n    )\n    this.forwarders.connect()\n  }\n\n  /**\n   * Initialise app identifier observable.\n   *\n   * @return {void}\n   */\n  initAppIdentifiers () {\n    this.appIdentifiers = new BehaviorSubject({}).pipe(\n      scan(\n        (identifiers, { address, identifier }) =>\n          Object.assign(identifiers, { [address]: identifier })\n      ),\n      publishReplay(1)\n    )\n    this.appIdentifiers.connect()\n  }\n\n  /**\n   * Set the identifier of an app.\n   *\n   * @param {string} address The proxy address of the app\n   * @param {string} identifier The identifier of the app\n   * @return {void}\n   */\n  setAppIdentifier (address, identifier) {\n    this.appIdentifiers.next({\n      address,\n      identifier\n    })\n  }\n\n  /**\n   * Initialise identity providers.\n   *\n   * @return {Promise<void>}\n   */\n  async initIdentityProviders () {\n    const defaultIdentityProviders = [{\n      name: 'local',\n      provider: new LocalIdentityProvider()\n    }]\n    // TODO: detect other installed providers\n    const detectedIdentityProviders = []\n    const identityProviders = [...defaultIdentityProviders, ...detectedIdentityProviders]\n\n    // Init all providers\n    await Promise.all(identityProviders.map(({ provider }) => {\n      // Most providers should have this defined to a noop function by default, but just in case\n      if (typeof provider.init === 'function') {\n        return provider.init()\n      }\n      return Promise.resolve()\n    }))\n\n    this.identityProviderRegistrar = new Map(\n      identityProviders.map(({ name, provider }) => [name, provider])\n    )\n    // Set up identity modification intent observable\n    this.identityIntents = new Subject()\n  }\n\n  /**\n   * Modify the identity metadata for an address using the highest priority provider.\n   *\n   * @param  {string} address Address to modify\n   * @param  {Object} metadata Modification metadata object\n   * @return {Promise} Resolves if the modification was successful\n   */\n  modifyAddressIdentity (address, metadata) {\n    const providerName = 'local'\n    const provider = this.identityProviderRegistrar.get(providerName)\n    if (provider && typeof provider.modify === 'function') {\n      return provider.modify(address, metadata)\n    }\n    return Promise.reject(new Error(`Provider (${providerName}) not installed`))\n  }\n\n  /**\n   * Resolve the identity metadata for an address using the highest priority provider.\n   *\n   * @param  {string} address Address to resolve\n   * @return {Promise} Resolves with the identity or null if not found\n   */\n  resolveAddressIdentity (address) {\n    const providerName = 'local' // TODO - get provider\n    const provider = this.identityProviderRegistrar.get(providerName)\n    if (provider && typeof provider.resolve === 'function') {\n      return provider.resolve(address)\n    }\n    return Promise.reject(new Error(`Provider (${providerName}) not installed`))\n  }\n\n  /**\n   * Search identities based on a term\n   *\n   * @param  {string} searchTerm\n   * @return {Promise} Resolves with the identity or null if not found\n   */\n  searchIdentities (searchTerm) {\n    const providerName = 'local' // TODO - get provider\n    const provider = this.identityProviderRegistrar.get(providerName)\n    if (provider && typeof provider.search === 'function') {\n      return provider.search(searchTerm)\n    }\n    return Promise.reject(new Error(`Provider (${providerName}) not installed`))\n  }\n\n  /**\n   * Request an identity modification using the highest priority provider.\n   *\n   * Returns a promise which delegates resolution to the handler\n   * which listens and handles `this.identityIntents`\n   *\n   * @param  {string} address Address to modify\n   * @return {Promise} Resolved by the handler of identityIntents\n   */\n  requestAddressIdentityModification (address) {\n    const providerName = 'local' // TODO - get provider\n    if (this.identityProviderRegistrar.has(providerName)) {\n      return new Promise((resolve, reject) => {\n        this.identityIntents.next({\n          address,\n          providerName,\n          resolve,\n          reject (err) {\n            reject(err || new Error('The identity modification was not completed'))\n          }\n        })\n      })\n    }\n\n    return Promise.reject(new Error(`Provider (${providerName}) not installed`))\n  }\n\n  /**\n   * Remove selected local identities\n   *\n   * @param {Array<string>} addresses The addresses to be removed from the local identity provider\n   * @return {Promise}\n   */\n  async removeLocalIdentities (addresses) {\n    const localProvider = this.identityProviderRegistrar.get('local')\n    for (const address of addresses) {\n      await localProvider.remove(address)\n    }\n  }\n\n  /**\n   * Get all local identities for listing functionality\n   *\n   * @return {Promise<Object>}\n   */\n  getLocalIdentities () {\n    return this.identityProviderRegistrar.get('local').getAll()\n  }\n\n  /**\n   * Initialise the GUI style observable.\n   *\n   * @param {Object} style GUI style options\n   * @param {string} style.appearance \"dark\" or \"light\"\n   * @param {Object} [style.theme] The theme object\n   * @return {void}\n   */\n  initGuiStyle ({ appearance, theme } = {}) {\n    this.guiStyle = new BehaviorSubject({\n      appearance: appearance || 'light',\n      theme: theme || null\n    })\n  }\n\n  /**\n   * Set the GUI style (theme and appearance).\n   *\n   * @param {string} appearance \"dark\" or \"light\"\n   * @param {Object} [theme] The theme object.\n   * @return {void}\n   */\n  setGuiStyle (appearance, theme = null) {\n    this.guiStyle.next({\n      appearance,\n      theme\n    })\n  }\n\n  /**\n   * Initialise the network observable.\n   *\n   * @param {Object} network information of node\n   * @return {Promise<void>}\n   */\n  async initNetwork (network) {\n    this.network = new ReplaySubject(1)\n\n    if (network) {\n      this.network.next(network)\n    } else {\n      this.network.next({\n        id: await this.web3.eth.getChainId(),\n        type: await this.web3.eth.net.getNetworkType()\n      })\n    }\n  }\n\n  /**\n   * Request an app's path be changed.\n   *\n   * @param {string} appAddress\n   * @param {string} path\n   * @return {Promise} Succeeds if path request was allowed\n   */\n  async requestAppPath (appAddress, path) {\n    if (typeof path !== 'string') {\n      throw new Error('Path must be a string')\n    }\n\n    if (!await this.getApp(appAddress)) {\n      throw new Error(`Cannot request path for non-installed app: ${appAddress}`)\n    }\n\n    return new Promise((resolve, reject) => {\n      this.pathIntents.next({\n        appAddress,\n        path,\n        resolve,\n        reject (err) {\n          reject(err || new Error('The path was rejected'))\n        }\n      })\n    })\n  }\n\n  /**\n   * Set an app's path.\n   *\n   * @param {string} appAddress\n   * @param {string} path\n   * @return {void}\n   */\n  setAppPath (appAddress, path) {\n    if (typeof path !== 'string') {\n      throw new Error('Path must be a string')\n    }\n\n    this.appContextPool.emit(appAddress, APP_CONTEXTS.PATH, path)\n  }\n\n  /**\n   * Run an app.\n   *\n   * As there may be race conditions with losing messages from cross-context environments,\n   * running an app is split up into two parts:\n   *\n   *   1. Set up any required state for the app. This step is allowed to be asynchronous.\n   *   2. Connect the app to a running context, by associating the context's message provider\n   *      to the app. This step is synchronous.\n   *\n   * @param  {string} proxyAddress\n   *         The address of the app proxy.\n   * @return {Promise<function>}\n   */\n  async runApp (proxyAddress) {\n    // Step 1: Set up required state for the app\n\n    // Only get the first result from the observable, so our running contexts don't get\n    // reinitialized if new apps appear\n    const apps = await this.apps.pipe(first()).toPromise()\n\n    const app = apps.find((app) => addressesEqual(app.proxyAddress, proxyAddress))\n\n    // TODO: handle undefined (no proxy found), otherwise when calling app.proxyAddress next, it will throw\n    const appProxy = makeProxyFromAppABI(app.proxyAddress, app.abi, this.web3)\n\n    await appProxy.updateInitializationBlock()\n\n    // Step 2: Associate app with running context\n    return (sandboxMessengerProvider) => {\n      // Set up messenger\n      const messenger = new Messenger(\n        sandboxMessengerProvider\n      )\n\n      // Wrap requests with the application proxy\n      // Note that we have to do this synchronously with the creation of the message provider,\n      // as we otherwise risk race conditions and may lose messages\n      const request$ = messenger.requests().pipe(\n        map(request => ({ request, proxy: appProxy, wrapper: this })),\n        // Use the same request$ result in each handler\n        // Turns request$ into a subject\n        publishReplay(1)\n      )\n      request$.connect()\n\n      // Register request handlers\n      const handlerSubscription = handlers.combineRequestHandlers(\n        // Generic handlers\n        handlers.createRequestHandler(request$, 'accounts', handlers.accounts),\n        handlers.createRequestHandler(request$, 'cache', handlers.cache),\n        handlers.createRequestHandler(request$, 'describe_script', handlers.describeScript),\n        handlers.createRequestHandler(request$, 'describe_transaction', handlers.describeTransaction),\n        handlers.createRequestHandler(request$, 'get_apps', handlers.getApps),\n        handlers.createRequestHandler(request$, 'network', handlers.network),\n        handlers.createRequestHandler(request$, 'path', handlers.path),\n        handlers.createRequestHandler(request$, 'gui_style', handlers.guiStyle),\n        handlers.createRequestHandler(request$, 'trigger', handlers.trigger),\n        handlers.createRequestHandler(request$, 'web3_eth', handlers.web3Eth),\n\n        // Contract handlers\n        handlers.createRequestHandler(request$, 'intent', handlers.intent),\n        handlers.createRequestHandler(request$, 'call', handlers.call),\n        handlers.createRequestHandler(request$, 'sign_message', handlers.signMessage),\n        handlers.createRequestHandler(request$, 'events', handlers.events),\n        handlers.createRequestHandler(request$, 'past_events', handlers.pastEvents),\n\n        // External contract handlers\n        handlers.createRequestHandler(request$, 'external_call', handlers.externalCall),\n        handlers.createRequestHandler(request$, 'external_events', handlers.externalEvents),\n        handlers.createRequestHandler(request$, 'external_intent', handlers.externalIntent),\n        handlers.createRequestHandler(request$, 'external_past_events', handlers.externalPastEvents),\n\n        // Identity handlers\n        handlers.createRequestHandler(request$, 'identify', handlers.appIdentifier),\n        handlers.createRequestHandler(request$, 'address_identity', handlers.addressIdentity),\n        handlers.createRequestHandler(request$, 'search_identities', handlers.searchIdentities)\n      ).subscribe(\n        (response) => messenger.sendResponse(response.id, response.payload)\n      )\n\n      // The attached unsubscribe isn't automatically bound to the subscription\n      const shutdown = () => handlerSubscription.unsubscribe()\n\n      const shutdownAndClearCache = async () => {\n        shutdown()\n\n        // Remove all cache keys related to this app one by one\n        return Object\n          .keys(await this.cache.getAll())\n          .reduce((promise, cacheKey) => {\n            return promise.then(() =>\n              cacheKey.startsWith(proxyAddress)\n                ? this.cache.remove(cacheKey)\n                : Promise.resolve()\n            )\n          }, Promise.resolve())\n      }\n\n      return {\n        shutdown,\n        shutdownAndClearCache\n      }\n    }\n  }\n\n  /**\n   * Set the available accounts for the current user.\n   *\n   * @param {Array<string>} accounts\n   * @return {void}\n   */\n  setAccounts (accounts) {\n    this.accounts.next(accounts)\n  }\n\n  /**\n   * Get the available accounts for the current user.\n   *\n   * @return {Promise<Array<string>>} An array of addresses\n   */\n  getAccounts () {\n    return this.accounts.pipe(first()).toPromise()\n  }\n\n  /**\n   * Allows apps to sign arbitrary data via a RPC call\n   *\n   * @param {string} message to be signed\n   * @param {string} requestingApp proxy address of requesting app\n   * @return {Promise<string>} signature hash\n   */\n  signMessage (message, requestingApp) {\n    if (typeof message !== 'string') {\n      return Promise.reject(new Error('Message to sign must be a string'))\n    }\n    return new Promise((resolve, reject) => {\n      this.signatures.next({\n        message,\n        requestingApp,\n        resolve,\n        reject (err) {\n          reject(err || new Error('The message was not signed'))\n        }\n      })\n    })\n  }\n\n  /**\n   * @param {Array<Object>} transactionPath An array of Ethereum transactions that describe each\n   *   step in the path\n   * @param {Object} [options]\n   * @param {boolean} [options.external] Whether the transaction path is initiating an action on\n   *   an external destination (not the currently running app)\n   * @return {Promise<string>} Promise that should be resolved with the sent transaction hash\n   */\n  performTransactionPath (transactionPath, { external } = {}) {\n    return new Promise((resolve, reject) => {\n      this.transactions.next({\n        resolve,\n        external: !!external,\n        transaction: transactionPath[0],\n        path: transactionPath,\n        reject (err) {\n          reject(err || new Error('The transaction was not signed'))\n        }\n      })\n    })\n  }\n\n  /**\n   * Performs an action on the ACL using transaction pathing\n   *\n   * @param {string} method\n   * @param {Array<*>} params\n   * @return {Promise<string>} transaction hash\n   */\n  async performACLIntent (method, params) {\n    const path = await this.getACLTransactionPath(method, params)\n    return this.performTransactionPath(path)\n  }\n\n  /**\n   * Looks for app with the provided proxyAddress and returns its app object if found\n   *\n   * @param {string} proxyAddress\n   * @return {Promise<Object>} The app object\n   */\n  getApp (proxyAddress) {\n    return this.apps.pipe(\n      map(apps => apps.find(app => addressesEqual(app.proxyAddress, proxyAddress))),\n      first()\n    ).toPromise()\n  }\n\n  /**\n   * Calculate the transaction path for a transaction to `destination`\n   * that invokes `methodSignature` with `params`.\n   *\n   * @param  {string} destination\n   * @param  {string} methodSignature\n   * @param  {Array<*>} params\n   * @param  {string} [finalForwarder] Address of the final forwarder that can perfom the action\n   * @return {Promise<Array<Object>>} An array of Ethereum transactions that describe each step in the path\n   */\n  async getTransactionPath (destination, methodSignature, params, finalForwarder) {\n    const accounts = await this.getAccounts()\n\n    for (let account of accounts) {\n      const path = await this.calculateTransactionPath(\n        account,\n        destination,\n        methodSignature,\n        params,\n        finalForwarder\n      )\n\n      if (path.length > 0) {\n        try {\n          return this.describeTransactionPath(path)\n        } catch (_) {\n          return path\n        }\n      }\n    }\n\n    return []\n  }\n\n  /**\n   * Calculate the transaction path for a transaction to an external `destination`\n   * (not the currently running app) that invokes a method matching the\n   * `methodAbiFragment` with `params`.\n   *\n   * @param  {string} destination Address of the external contract\n   * @param  {object} methodAbiFragment ABI fragment of method to invoke\n   * @param  {Array<*>} params\n   * @return {Promise<Array<Object>>} An array of Ethereum transactions that describe each step in the path.\n   *   If the destination is a non-installed contract, always results in an array containing a\n   *   single transaction.\n   */\n  async getExternalTransactionPath (destination, methodAbiFragment, params) {\n    if (addressesEqual(destination, this.aclProxy.address)) {\n      try {\n        return this.getACLTransactionPath(methodAbiFragment.name, params)\n      } catch (_) {\n        return []\n      }\n    }\n\n    const installedApp = await this.getApp(destination)\n    if (installedApp) {\n      // Destination is an installed app; need to go through normal transaction pathing\n      return this.getTransactionPath(destination, methodAbiFragment.name, params)\n    }\n\n    // Destination is not an installed app on this org, just create a direct transaction\n    // with the first account\n    const account = (await this.getAccounts())[0]\n\n    try {\n      const tx = await createDirectTransaction(account, destination, methodAbiFragment, params, this.web3)\n      return this.describeTransactionPath([tx])\n    } catch (_) {\n      return []\n    }\n  }\n\n  /**\n   * Calculate the transaction path for a basket of intents.\n   * Expects the `intentBasket` to be an array of tuples holding the following:\n   *   {string}   destination: destination address\n   *   {string}   methodSignature: method to invoke on destination\n   *   {Array<*>} params: method params\n   * These are the same parameters as the ones used for `getTransactionPath()`\n   *\n   * Allows user to specify how many of the intents should be checked to ensure their paths are\n   * compatible. `checkMode` supports:\n   *   'all': All intents will be checked to make sure they use the same forwarding path.\n   *   'single': assumes all intents can use the path found from the first intent\n   *\n   * @param  {Array<Array<string, string, Array<*>>>} intentBasket Intents\n   * @param  {Object} [options]\n   * @param  {string} [options.checkMode] Path checking mode\n   * @return {Promise<Object>} An object containing:\n   *   - `path` (Array<Object>): a multi-step transaction path that eventually invokes this basket.\n   *     Empty if no such path could be found.\n   *   - `transactions` (Array<Object>): array of Ethereum transactions that invokes this basket.\n   *     If a multi-step transaction path was found, returns the first transaction in that path.\n   *     Empty if no such transactions could be found.\n   */\n  async getTransactionPathForIntentBasket (intentBasket, { checkMode = 'all' } = {}) {\n    // Get transaction paths for entire basket\n    const intentsToCheck =\n      checkMode === 'all'\n        ? intentBasket // all -- use all intents\n        : checkMode === 'single'\n          ? [intentBasket[0]] // single -- only use first intent\n          : []\n    const intentPaths = await Promise.all(\n      intentsToCheck.map(\n        ([destination, methodSignature, params]) =>\n          addressesEqual(destination, this.aclProxy.address)\n            ? this.getACLTransactionPath(methodSignature, params)\n            : this.getTransactionPath(destination, methodSignature, params)\n      )\n    )\n\n    // If the paths don't match, we can't send the transactions in this intent basket together\n    const pathsMatch = doIntentPathsMatch(intentPaths)\n    if (pathsMatch) {\n      // Create direct transactions for each intent in the intentBasket\n      const sender = (await this.getAccounts())[0] // TODO: don't assume it's the first account\n      const directTransactions = await Promise.all(\n        intentBasket.map(\n          async ([destination, methodSignature, params]) =>\n            createDirectTransactionForApp(sender, await this.getApp(destination), methodSignature, params, this.web3)\n        )\n      )\n\n      if (intentPaths[0].length === 1) {\n        // Sender has direct access\n        try {\n          const decoratedTransactions = await this.describeTransactionPath(\n            await Promise.all(\n              directTransactions.map(transaction => this.applyTransactionGas(transaction))\n            )\n          )\n\n          return {\n            path: [],\n            transactions: decoratedTransactions\n          }\n        } catch (_) { }\n      } else {\n        // Need to encode calls scripts for each forwarder transaction in the path\n        const createForwarderTransaction = createForwarderTransactionBuilder(sender, {}, this.web3)\n        const forwarderPath = intentPaths[0]\n          // Ignore the last part of the path, which was the original intent\n          .slice(0, -1)\n          // Start from the \"last\" forwarder and move backwards to the sender\n          .reverse()\n          // Just use the forwarders' addresses\n          .map(({ to }) => to)\n          .reduce(\n            (path, nextForwarder) => {\n              const lastStep = path[0]\n              const encodedLastStep = encodeCallScript(Array.isArray(lastStep) ? lastStep : [lastStep])\n              return [createForwarderTransaction(nextForwarder, encodedLastStep), ...path]\n            },\n            // Start the recursive calls script encoding with the direct transactions for the\n            // intent basket\n            [directTransactions]\n          )\n\n        try {\n          // Put the finishing touches: apply gas, and add radspec descriptions\n          forwarderPath[0] = await this.applyTransactionGas(forwarderPath[0], true)\n          return {\n            path: await this.describeTransactionPath(forwarderPath),\n            // When we have a path, we only need to send the first transaction to start it\n            transactions: [forwarderPath[0]]\n          }\n        } catch (_) { }\n      }\n    }\n\n    // Failed to find a path\n    return {\n      path: [],\n      transactions: []\n    }\n  }\n\n  /**\n   * Get the permission manager for an `app`'s and `role`.\n   *\n   * @param {string} appAddress\n   * @param {string} roleHash\n   * @return {Promise<string>} The permission manager\n   */\n  async getPermissionManager (appAddress, roleHash) {\n    const permissions = await this.permissions.pipe(first()).toPromise()\n    const appPermissions = permissions[appAddress]\n\n    return dotprop.get(appPermissions, `${roleHash}.manager`)\n  }\n\n  /**\n   * Calculates transaction path for performing a method on the ACL\n   *\n   * @param {string} methodSignature\n   * @param {Array<*>} params\n   * @return {Promise<Array<Object>>} An array of Ethereum transactions that describe each step in the path\n   */\n  async getACLTransactionPath (methodSignature, params) {\n    const aclAddr = this.aclProxy.address\n    const acl = await this.getApp(aclAddr)\n\n    const method = findAppMethodFromSignature(acl, methodSignature, { allowDeprecated: false })\n    if (!method) {\n      throw new Error(`No method named ${methodSignature} on ACL`)\n    }\n\n    if (method.roles && method.roles.length !== 0) {\n      // This action can be done with regular transaction pathing (it's protected by an ACL role)\n      return this.getTransactionPath(aclAddr, methodSignature, params)\n    } else {\n      // Some ACL functions don't have a role and are instead protected by a manager\n      // Inspect the matched method's ABI to find the position of the 'app' and 'role' parameters\n      // needed to get the permission manager\n      const methodAbiFragment = findMethodAbiFragment(acl.abi, methodSignature)\n      if (!methodAbiFragment) {\n        throw new Error(`Method ${method} not found on ACL ABI`)\n      }\n\n      const inputNames = methodAbiFragment.inputs.map((input) => input.name)\n      const appIndex = inputNames.indexOf('_app')\n      const roleIndex = inputNames.indexOf('_role')\n\n      if (appIndex === -1 || roleIndex === -1) {\n        throw new Error(`Method ${methodSignature} doesn't take _app and _role as input. Permission manager cannot be found.`)\n      }\n\n      const manager = await this.getPermissionManager(params[appIndex], params[roleIndex])\n\n      return this.getTransactionPath(aclAddr, methodSignature, params, manager)\n    }\n  }\n\n  /**\n   * Decodes an EVM callscript and returns the transaction path it describes.\n   *\n   * @param  {string} script\n   * @return {Array<Object>} An array of Ethereum transactions that describe each step in the path\n   */\n  decodeTransactionPath (script) {\n    // In the future we may support more EVMScripts, but for now let's just assume we're only\n    // dealing with call scripts\n    if (!isCallScript(script)) {\n      throw new Error(`Script could not be decoded: ${script}`)\n    }\n\n    const path = decodeCallScript(script)\n    return path.map((segment) => {\n      const { data } = segment\n\n      if (isValidForwardCall(data)) {\n        const forwardedEvmScript = parseForwardCall(data)\n\n        try {\n          segment.children = this.decodeTransactionPath(forwardedEvmScript)\n        } catch (err) {}\n      }\n\n      return segment\n    })\n  }\n\n  /**\n   * Use radspec to create a human-readable description for each transaction in the given `path`\n   *\n   * @param  {Array<Object>} path\n   * @return {Promise<Array<Object>>} The given `path`, with decorated with descriptions at each step\n   */\n  async describeTransactionPath (path) {\n    return Promise.all(path.map(async (step) => {\n      let decoratedStep\n\n      if (Array.isArray(step)) {\n        // Intent basket with multiple transactions in a single callscript\n        // First see if the step can be handled with a specialized descriptor\n        try {\n          decoratedStep = await tryDescribingUpgradeOrganizationBasket(step, this)\n        } catch (err) { }\n\n        // If the step wasn't handled, just individually describe each of the transactions\n        return decoratedStep || this.describeTransactionPath(step)\n      }\n\n      // Single transaction step\n      // First see if the step can be handled with a specialized descriptor\n      try {\n        decoratedStep = await tryDescribingUpdateAppIntent(step, this)\n      } catch (err) { }\n\n      // Finally, if the step wasn't handled yet, evaluate via radspec normally\n      if (!decoratedStep) {\n        try {\n          decoratedStep = await tryEvaluatingRadspec(step, this)\n        } catch (err) { }\n      }\n\n      // Annotate the description, if one was found\n      if (decoratedStep) {\n        if (decoratedStep.description) {\n          try {\n            const processed = await postprocessRadspecDescription(decoratedStep.description, this)\n            decoratedStep.description = processed.description\n            decoratedStep.annotatedDescription = processed.annotatedDescription\n          } catch (err) { }\n        }\n\n        if (decoratedStep.children) {\n          decoratedStep.children = await this.describeTransactionPath(decoratedStep.children)\n        }\n      }\n\n      return decoratedStep || step\n    }))\n  }\n\n  /**\n   * Whether the `sender` can use the `forwarder` to invoke `script`.\n   *\n   * @param  {string} forwarder\n   * @param  {string} sender\n   * @param  {string} script\n   * @return {Promise<bool>}\n   */\n  canForward (forwarder, sender, script) {\n    const canForward = new this.web3.eth.Contract(\n      getAbi('aragon/Forwarder'),\n      forwarder\n    ).methods['canForward']\n\n    return canForward(sender, script).call().catch(() => false)\n  }\n\n  getDefaultGasPrice (gasLimit) {\n    return this.defaultGasPriceFn(gasLimit)\n  }\n\n  /**\n   * Calculates and applies the gas limit and gas price for a transaction\n   *\n   * @param  {Object} transaction\n   * @param  {bool} isForwarding\n   * @return {Promise<Object>} The transaction with the gas limit and gas price added.\n   *                           If the transaction fails from the estimateGas check, the promise will\n   *                           be rejected with the error.\n   */\n  async applyTransactionGas (transaction, isForwarding = false) {\n    // If a pretransaction is required for the main transaction to be performed,\n    // performing web3.eth.estimateGas could fail until the pretransaction is mined\n    // Example: erc20 approve (pretransaction) + deposit to vault (main transaction)\n    if (transaction.pretransaction) {\n      // Calculate gas settings for pretransaction\n      transaction.pretransaction = await this.applyTransactionGas(transaction.pretransaction, false)\n      // Note: for transactions with pretransactions gas limit and price cannot be calculated\n      return transaction\n    }\n\n    // NOTE: estimateGas mutates the argument object and transforms the address to lowercase\n    // so this is a hack to make sure checksums are not destroyed\n    // Also, at the same time it's a hack for checking if the call will revert,\n    // since `eth_call` returns `0x` if the call fails and if the call returns nothing.\n    // So yeah...\n    const estimatedGasLimit = await this.web3.eth.estimateGas({ ...transaction, gas: undefined })\n    const recommendedGasLimit = await getRecommendedGasLimit(this.web3, estimatedGasLimit)\n\n    // If the gas provided in the intent is lower than the estimated gas, use the estimation\n    // when forwarding as it requires more gas and otherwise the transaction would go out of gas\n    if (!transaction.gas || (isForwarding && transaction.gas < recommendedGasLimit)) {\n      transaction.gas = recommendedGasLimit\n    }\n\n    if (!transaction.gasPrice) {\n      transaction.gasPrice = await this.getDefaultGasPrice(transaction.gas)\n    }\n\n    return transaction\n  }\n\n  /**\n   * Calculate the transaction path for a transaction to `destination`\n   * that invokes `methodSignature` with `params`.\n   *\n   * @param  {string} sender\n   * @param  {string} destination\n   * @param  {string} methodSignature\n   * @param  {Array<*>} params\n   * @param  {string} [finalForwarder] Address of the final forwarder that can perfom the action.\n   *                  Needed for actions that aren't in the ACL but whose execution depends on other factors\n   * @return {Promise<Array<Object>>} An array of Ethereum transactions that describe each step in the path\n   */\n  async calculateTransactionPath (sender, destination, methodSignature, params, finalForwarder) {\n    // Get the destination app\n    const app = await this.getApp(destination)\n    if (!app) {\n      throw new Error(`Transaction path destination (${destination}) is not an installed app`)\n    }\n\n    const method = findAppMethodFromSignature(app, methodSignature, { allowDeprecated: false })\n    if (!method) {\n      throw new Error(`No method named ${methodSignature} on ${destination}`)\n    }\n\n    // Create transaction for target action\n    const directTransaction = await createDirectTransactionForApp(sender, app, methodSignature, params, this.web3)\n\n    const finalForwarderProvided = isAddress(finalForwarder)\n\n    // We can already assume the user is able to directly invoke the action if:\n    //   - The method has no ACL requirements and no final forwarder was given, or\n    //   - The final forwarder matches the sender\n    if (\n      (method.roles.length === 0 && !finalForwarderProvided) ||\n      addressesEqual(finalForwarder, sender)\n    ) {\n      try {\n        // `applyTransactionGas` can throw if the transaction will fail\n        return [await this.applyTransactionGas(directTransaction)]\n      } catch (_) {\n        // If the direct transaction fails, we give up as we should have been able to\n        // perform the action directly\n        return []\n      }\n    }\n\n    // Failing this, attempt transaction pathing algorithm with forwarders\n    const forwarders = await this.forwarders.pipe(first()).toPromise().then(\n      (forwarders) => forwarders.map(\n        (forwarder) => forwarder.proxyAddress\n      )\n    )\n\n    let forwardersWithPermission\n    if (finalForwarderProvided) {\n      if (!includesAddress(forwarders, finalForwarder)) {\n        // Final forwarder was given, but did not match any available forwarders, so no path\n        // could be found\n        return []\n      }\n\n      // Only attempt to find path with declared final forwarder; assume the final forwarder\n      // is able to invoke the action\n      forwardersWithPermission = [finalForwarder]\n    } else {\n      // Find entities with the required permissions\n      const permissions = await this.permissions.pipe(first()).toPromise()\n      const destinationPermissions = permissions[destination]\n      const roleSig = app.roles.find(\n        (role) => role.id === method.roles[0]\n      ).bytes\n      const allowedEntities = dotprop.get(\n        destinationPermissions,\n        `${roleSig}.allowedEntities`,\n        []\n      )\n\n      // No one has access, so of course we don't as well\n      if (allowedEntities.length === 0) {\n        return []\n      }\n\n      // User may have permission; attempt direct transaction\n      if (\n        includesAddress(allowedEntities, sender) ||\n        includesAddress(allowedEntities, ANY_ENTITY)\n      ) {\n        try {\n          // `applyTransactionGas` can throw if the transaction will fail\n          return [await this.applyTransactionGas(directTransaction)]\n        } catch (_) {\n          // Don't immediately fail as the permission could have parameters applied that\n          // disallows the user from the current action and forces us to use the full\n          // pathing algorithm\n        }\n      }\n\n      // Find forwarders with permission to perform the action\n      forwardersWithPermission = forwarders.filter(\n        (forwarder) => includesAddress(allowedEntities, forwarder)\n      )\n    }\n\n    return this.calculateForwardingPath(sender, destination, directTransaction, forwardersWithPermission)\n  }\n\n  /**\n   * Calculate the forwarding path for a transaction to `destination`\n   * that invokes `directTransaction`.\n   *\n   * @param  {string} sender\n   * @param  {string} destination\n   * @param  {Object} directTransaction\n   * @param  {string} [forwardersWithPermission]\n   * @return {Array<Object>} An array of Ethereum transactions that describe each step in the path\n   */\n  async calculateForwardingPath (sender, destination, directTransaction, forwardersWithPermission) {\n    // No forwarders can perform the requested action\n    if (forwardersWithPermission.length === 0) {\n      return []\n    }\n\n    // TODO: handle pretransactions specified in the intent\n    // This is difficult to do generically, as some pretransactions\n    // (e.g. token approvals) only work if they're for a specific target\n    delete directTransaction.pretransaction\n\n    const createForwarderTransaction = createForwarderTransactionBuilder(sender, directTransaction, this.web3)\n\n    // Check if one of the forwarders that has permission to perform an action\n    // with `sig` on `address` can forward for us directly\n    for (const forwarder of forwardersWithPermission) {\n      const script = encodeCallScript([directTransaction])\n      if (await this.canForward(forwarder, sender, script)) {\n        const transaction = createForwarderTransaction(forwarder, script)\n        try {\n          const transactionWithFee = await applyForwardingFeePretransaction(transaction, this.web3)\n          // `applyTransactionGas` can throw if the transaction will fail\n          // If that happens, we give up as we should've been able to perform the action with this\n          // forwarder\n          return [await this.applyTransactionGas(transactionWithFee, true), directTransaction]\n        } catch (err) {\n          return []\n        }\n      }\n    }\n\n    // Get a list of all forwarders (excluding the forwarders with direct permission)\n    const forwarders = await this.forwarders.pipe(first()).toPromise().then(\n      (forwarders) => forwarders\n        .map((forwarder) => forwarder.proxyAddress)\n        .filter((forwarder) => !includesAddress(forwardersWithPermission, forwarder))\n    )\n\n    // Set up the path finding queue\n    // The queue takes the form of Array<[Array<EthereumTransaction>, Array<String>]>\n    // In other words: it is an array of tuples, where the first index of the tuple\n    // is the current path and the second index of the tuple is the\n    // queue (a list of unexplored forwarder addresses) for that path\n    const queue = forwardersWithPermission.map((forwarderWithPermission) => {\n      return [\n        [\n          createForwarderTransaction(forwarderWithPermission, encodeCallScript([directTransaction])),\n          directTransaction\n        ], forwarders\n      ]\n    })\n\n    // Find the shortest path via a breadth-first search of forwarder paths.\n    // We do a breadth-first instead of depth-first search because:\n    //   - We assume that most forwarding paths will be quite short, so it should be faster\n    //     to check in \"stages\" rather than exhaust single paths\n    //   - We don't currently protect against cycles in the path, and so exhausting single\n    //     paths can be wasteful if they result in dead ends\n    // TODO(onbjerg): Should we find and return multiple paths?\n    do {\n      const [path, [forwarder, ...nextQueue]] = queue.shift()\n\n      // Skip if no forwarder or the path is longer than 5\n      if (!forwarder || path.length > 5) continue\n\n      // Get the previous forwarder address\n      const previousForwarder = path[0].to\n\n      // Encode the previous transaction into an EVM callscript\n      const script = encodeCallScript([path[0]])\n\n      if (await this.canForward(previousForwarder, forwarder, script)) {\n        if (await this.canForward(forwarder, sender, script)) {\n          // The previous forwarder can forward a transaction for this forwarder,\n          // and this forwarder can forward for our address, so we have found a path\n          const transaction = createForwarderTransaction(forwarder, script)\n\n          // Only apply pretransactions and gas to the first transaction in the path\n          // as it's the only one that will be executed by the user\n          try {\n            const transactionWithFee = await applyForwardingFeePretransaction(transaction, this.web3)\n            // `applyTransactionGas` can throw if the transaction will fail\n            // If that happens, we give up as we should've been able to perform the action with this\n            // forwarding path\n            return [await this.applyTransactionGas(transactionWithFee, true), ...path]\n          } catch (err) {\n            return []\n          }\n        } else {\n          // The previous forwarder can forward a transaction for this forwarder,\n          // but this forwarder can not forward for our address, so we add it as a\n          // possible path in the queue for later exploration.\n          queue.push([\n            [createForwarderTransaction(forwarder, script), ...path],\n            // Avoid including the current forwarder as a candidate for the next step\n            // in the path. Note that this is naive and may result in repeating cycles,\n            // but the maximum path length would prevent against infinite loops\n            forwarders.filter((nextForwarder) => nextForwarder !== forwarder)\n          ])\n        }\n      }\n\n      // We add the current path on the back of the queue again, but we shorten\n      // the list of possible forwarders.\n      queue.push([path, nextQueue])\n    } while (queue.length)\n\n    return []\n  }\n}\n\n// Re-export some web3 utilities\nexport { apm, getRecommendedGasLimit }\nexport { resolve as ensResolve } from './ens'\n\n// Re-export the AddressIdentityProvider abstract base class\nexport { AddressIdentityProvider } from './identity'\n\n// Re-export the Aragon RPC providers\nexport { providers } from '@aragon/rpc-messenger'\n"],"mappings":"8KAqeuB;ijHA/ZvB;AACO,KAAMA,eAAc,CAAG,IACZ,WAAhB,QAAOC,KAAP,CAEI,qCAFJ,CACIA,IAAI,CAACC,eAAgB;AAFpB,CAKP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,G,sCACe,KAAMC,OAAO,CAC1BC,WAAW,CAAEC,UAAF,CAA4B,IAAdC,QAAc,wDAAJ,EAAI,CACrC,KAAMC,eAAc,CAAG,CACrBC,iBAAiB,CAAE,IAAM,CAAE,CADN,CAErBC,QAAQ,CAAET,cAAc,EAFH,CAGrBU,KAAK,CAAE,CACLC,iBAAiB,GADZ,CAELC,MAAM,CAAE,IAFH,CAHc,CAOrBC,MAAM,CAAE,CACNC,qBAAqB,CAAE,CADjB,CAPa,CAAvB,CAWAR,OAAO,CAAGS,MAAM,CAACC,MAAP,CAAcT,cAAd,CAA8BD,OAA9B,CAZ2B,CAerC,GAAAW,+BAAA,EACEC,iBAAiB,CAACC,mBADpB,CAEE,CAAC,EAAEb,OAAO,CAACI,KAAR,EAAiBJ,OAAO,CAACI,KAAR,CAAcC,iBAAjC,CAFH,CAfqC,CAoBrC,GAAAM,+BAAA,EACEC,iBAAiB,CAACE,wBADpB,CAEEC,MAAM,CAACC,QAAP,CAAgBhB,OAAO,CAACO,MAAR,EAAkBP,OAAO,CAACO,MAAR,CAAeU,sBAAjD,EACIjB,OAAO,CAACO,MAAR,CAAeU,sBADnB,CAEI,CAJN,CApBqC,CA2BrC,GAAAN,+BAAA,EACEC,iBAAiB,CAACM,sBADpB,IAEGlB,OAAO,CAACO,MAAR,EAAkBP,OAAO,CAACO,MAAR,CAAeY,cAFpC,GAEsDnB,OAAO,CAACO,MAAR,CAAeY,cAFrE,CA3BqC,CAiCrC,KAAKxB,IAAL,CAAY,GAAIyB,aAAJ,CAASpB,OAAO,CAACG,QAAjB,CAjCyB,CAoCrC,KAAKkB,GAAL,CAAW,GAAAA,YAAA,EAAIrB,OAAO,CAACG,QAAZ,CAAsBH,OAAO,CAACsB,GAAR,CAAYC,kBAAlC,CApC0B,CAsCrC;AACA,KAAM,CAAEC,IAAI,CAAEC,cAAc,CAAG,EAAzB,EAAgCzB,OAAO,CAACsB,GAA9C,CACA,KAAKA,GAAL,CAAW,GAAAA,YAAA,EACT,KAAK3B,IADI,CAET,CACE+B,YAAY,CAAED,cAAc,CAACC,YAD/B,CAEEC,WAAW,CAAEF,cAAc,CAACG,OAF9B,CAFS,CAxC0B,CAiDrC,KAAKC,WAAL,CAAmB,GAAAC,gBAAA,EAAU/B,UAAV,CAAsB,QAAtB,CAAgC,KAAKJ,IAArC,CAjDkB,CAmDrC;AACA,KAAMoC,YAAW,CAAG/B,OAAO,CAACI,KAAR,CAAcE,MAAd,CAAwB,GAAEN,OAAO,CAACI,KAAR,CAAcE,MAAO,IAAGP,UAAW,EAA7D,CAAiEA,UAArF,CAGA;AAFA,KAAKK,KAAL,CAAa,GAAI4B,eAAJ,CAAUD,WAAV,CArDwB,CAwDrC,KAAKE,cAAL,CAAsB,GAAIC,cAxDW,CA0DrC,KAAKhC,iBAAL,CAAyBF,OAAO,CAACE,iBAClC,CAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KACY,KAAJiC,KAAI,EAAgB,IACpBC,WADoB,CAAdpC,OAAc,wDAAJ,EAAI,CAGxB,GAAI,CACF;AACA;AACAoC,UAAU,CAAG,KAAM,MAAKP,WAAL,CAAiBQ,IAAjB,CAAsB,KAAtB,CACpB,CAAC,MAAOC,CAAP,CAAU,CACV,KAAMC,MAAK,CAAE,kCAAF,CACZ,CAED,KAAM,MAAKnC,KAAL,CAAW+B,IAAX,EAXkB,CAYxB,KAAM,MAAKN,WAAL,CAAiBW,yBAAjB,EAZkB,CAaxB,KAAM,MAAKC,YAAL,CAAkBzC,OAAO,CAAC0C,QAA1B,CAbkB,CAcxB,KAAM,MAAKC,OAAL,CAAalC,MAAM,CAACC,MAAP,CAAc,CAAE0B,UAAF,CAAd,CAA8BpC,OAAO,CAAC4C,GAAtC,CAAb,CAdkB,CAexB,KAAM,MAAKC,qBAAL,EAfkB,CAgBxB,KAAKC,QAAL,EAhBwB,CAiBxB,KAAKC,cAAL,EAjBwB,CAkBxB,KAAKC,kBAAL,EAlBwB,CAmBxB,KAAKC,WAAL,CAAiBjD,OAAO,CAACkD,OAAzB,CAnBwB,CAoBxB,KAAKC,YAAL,CAAkBnD,OAAO,CAACoD,QAA1B,CApBwB,CAqBxB,KAAKC,WAAL,CAAmB,GAAIC,cArBC,CAsBxB,KAAKC,YAAL,CAAoB,GAAID,cAtBA,CAuBxB,KAAKE,UAAL,CAAkB,GAAIF,cACvB,CAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KACoB,KAAZb,aAAY,EAAiD,IAA/C,CAAEgB,aAAF,CAAiBC,gBAAgB,CAAG,EAApC,CAA+C,wDAAJ,EAAI,CACjE,KAAKhB,QAAL,CAAgB,GAAIiB,oBAAJ,CAAkB,CAAlB,CADiD,CAEjE,KAAMjB,SAAQ,CAAGe,aAAa,CAC1BC,gBAAgB,CAACE,MAAjB,CAAwB,KAAM,MAAKjE,IAAL,CAAUkE,GAAV,CAAcC,WAAd,EAA9B,CAD0B,CAE1BJ,gBAFJ,CAIA,KAAKK,WAAL,CAAiBrB,QAAjB,CACD,CAED;AACF;AACA;AACA;AACA,KACe,KAAPC,QAAO,EAAuB,IAArB,CAAEP,UAAF,CAAqB,wDAAJ,EAAI,CAC7BA,UAD6B,GAEhCA,UAAU,CAAG,KAAM,MAAKP,WAAL,CAAiBQ,IAAjB,CAAsB,KAAtB,CAFa,EAMlC,KAAK2B,QAAL,CAAgB,GAAAlC,gBAAA,EAAUM,UAAV,CAAsB,KAAtB,CAA6B,KAAKzC,IAAlC,CAAwC,CAAEsE,mBAAmB,CAAE,KAAKpC,WAAL,CAAiBoC,mBAAxC,CAAxC,CANkB,MAW5BC,cAAa,CAAG,GAAAC,kBAAA,EAAY/B,UAAZ,CAAwB,KAAxB,CAXY,CAe5BgC,YAAY,CAAG,KAAM,MAAKzE,IAAL,CAAUkE,GAAV,CAAcQ,cAAd,EAfO,CAgB5BC,gBAAgB,CAAGC,IAAI,CAACC,GAAL,CAASJ,YAAY,CAHf,GAGN,CAAgD,CAAhD,CAhBS,CAoB5BK,cAAc,CAAG,KAAM,MAAKrE,KAAL,CAAWsE,GAAX,CAAeR,aAAf,CAA8B,EAA9B,CApBK,CAqB5B,CAAES,WAAW,CAAEC,iBAAf,CAAkCC,WAAW,CAAEC,iBAA/C,EAAqEL,cArBzC,CAuB5BM,iBAAiB,CAAG,CACxBC,OAAO,CAAEV,gBADe,CAExB;AACAW,SAAS,CAAEL,iBAAiB,CAAGE,iBAAiB,CAAG,CAAvB,OAHJ,CAvBQ,CA4B5BI,WAAW,CAAG,KAAKlB,QAAL,CAAcmB,UAAd,CAAyB,IAAzB,CAA+BJ,iBAA/B,EAAkDK,IAAlD,CAClB,GAAAC,mBAAA,EAAUF,UAAD,EAAgB,GAAAG,UAAA,EAAKH,UAAL,CAAzB,CADkB,CAElB;AACA,GAAAI,kBAAA,EAAQ,CACNC,KAAK,CAAEtB,aADD,CAENuB,YAAY,CAAE,EAFR,CAAR,CAHkB,CA5Bc,CAoC5BC,cAAc,CAAG,KAAK1B,QAAL,CAAczD,MAAd,CAAqB,IAArB,CAA2B,CAAE0E,SAAS,CAAEX,gBAAgB,CAAG,CAAhC,CAA3B,EAAgEc,IAAhE,CACrB,GAAAO,oBAAA,EAAU,CACRH,KAAK,CAAE,yBADC,CAERC,YAAY,CAAE,EAFN,CAAV,CADqB,CApCW,CA6C5BG,mBAAmB,CAAG,GAAAhC,YAAA,EAAOsB,WAAP,CAAoBQ,cAApB,EAAoCN,IAApC,CAC1B,GAAAS,eAAA,EAAK,MAAgBL,KAAhB,GAA0B,IAAzB,CAACb,WAAD,CAAyB,MAC7B,KAAMmB,UAAS,CAAGN,KAAK,CAACC,YAAxB,CAEA,GAAIK,SAAS,CAACC,GAAd,CAAmB,CACjB;AACA,KAAMC,eAAc,CAAGrB,WAAW,CAACmB,SAAS,CAACC,GAAX,CAAX,EAA8B,EAArD,CAEA,GAAIP,KAAK,CAACA,KAAN,GA7CmB,eA6CvB,CAA0C,MAClCS,IAAG,CAAI,GAAEH,SAAS,CAACI,IAAK,kBADU,CAIlCC,kBAAkB,CAAG,GAAIC,IAAJ,CAAQC,gBAAA,CAAQ3B,GAAR,CAAYsB,cAAZ,CAA4BC,GAA5B,CAAiC,EAAjC,CAAR,CAJa,CAGxC;AAGIH,SAAS,CAACQ,OAN0B,CAOtCH,kBAAkB,CAACI,GAAnB,CAAuBT,SAAS,CAACU,MAAjC,CAPsC,CAStCL,kBAAkB,CAACM,MAAnB,CAA0BX,SAAS,CAACU,MAApC,CATsC,CAYxCH,gBAAA,CAAQK,GAAR,CAAYV,cAAZ,CAA4BC,GAA5B,CAAiCU,KAAK,CAACrB,IAAN,CAAWa,kBAAX,CAAjC,CACD,CAEGX,KAAK,CAACA,KAAN,GA3D8B,yBAwCjB,EAqBfa,gBAAA,CAAQK,GAAR,CAAYV,cAAZ,CAA6B,GAAEF,SAAS,CAACI,IAAK,UAA9C,CAAyDJ,SAAS,CAACc,OAAnE,CArBe,CAwBjBjC,WAAW,CAACmB,SAAS,CAACC,GAAX,CAAX,CAA6BC,cAC9B,CAED,MAAO,CAACrB,WAAD,CAAca,KAAd,CACR,CA/BD,CA+BG,CAAE,GAAAqB,0BAAA,EAAoBjC,iBAAiB,EAAI,EAAzC,CAAF,CA/BH,CAD0B,CAkC1B;AACA,GAAAkC,cAAA,EAAI,OAA0B,IAAzB,CAACnC,WAAD,CAAca,KAAd,CAAyB,OAQ5B,MAPIA,MAAK,CAACA,KAAN,GAAgBtB,aAOpB,EANE,KAAK9D,KAAL,CAAWsG,GAAX,CACExC,aADF,CAEE;AACA,CAAES,WAAW,CAAElE,MAAM,CAACC,MAAP,CAAc,EAAd,CAAkBiE,WAAlB,CAAf,CAA+CE,WAAW,CAAEP,gBAA5D,CAHF,CAMF,CAAOK,WACR,CATD,CAnC0B,CA8C1B;AACA;AACA;AACA,GAAAoC,uBAAA,EAAa,EAAb,CAjD0B,CAkD1B,GAAAC,wBAAA,EAAc,CAAd,CAlD0B,CA7CM,CAiGlCpB,mBAAmB,CAACqB,OAApB,EAjGkC,CAmGlC,KAAMC,mBAAkB,CAAGtC,iBAAiB,CAAG,GAAAuC,QAAA,EAAG,GAAAN,0BAAA,EAAoBjC,iBAApB,CAAH,CAAH,CAAgD,GAAAuC,QAAA,GAA5F,CACA,KAAKxC,WAAL,CAAmB,GAAAf,YAAA,EAAOsD,kBAAP,CAA2BtB,mBAA3B,EAAgDR,IAAhD,CAAqD,GAAA4B,wBAAA,EAAc,CAAd,CAArD,CApGe,CAqGlC,KAAKrC,WAAL,CAAiBsC,OAAjB,EACD,CAED;AACF;AACA;AACA;AACA;AACA,KACEG,KAAK,CAAErB,GAAF,CAAO,CACV,MAAOA,IAAG,CAACsB,aAAJ,EAAqB,KAAKC,eAAL,CAAqBvB,GAAG,CAACsB,aAAzB,CAC7B,CAED;AACF;AACA;AACA;AACA;AACA,KACEC,eAAe,CAAEC,OAAF,CAAW,CACxB,MAAO,GAAAC,qBAAA,EAAeD,OAAf,CAAwB,KAAK1F,WAAL,CAAiB0F,OAAzC,CACR,CAED;AACF;AACA;AACA;AACA,KACEzE,QAAQ,EAAI,CACV;AACJ;AACA;AACA;AACA,oCALc,KAOJ2E,qBAAoB,CAAG,GAAIC,yBAAJ,CAAsB,KAAOC,SAAP,EAAoB,CACrE,KAAM,CAACC,KAAD,CAAQC,WAAR,EAAuBF,QAAQ,CAACG,KAAT,CAAe,GAAf,CAA7B,CACA,MAAO,GAAAC,oCAAA,EAA2BH,KAA3B,GACL,GAAAI,0BAAA,EAAsBJ,KAAtB,CADK,EAEL,KAAKtG,GAAL,CAAS2G,iCAAT,CACE,KAAM,MAAK5G,GAAL,CAAS6G,OAAT,CAAiBN,KAAjB,CADR,CAEEC,WAFF,CAIH,CAR4B,CAPnB,CAiBJM,uBAAuB,CAAG,GAAIT,yBAAJ,CAAuBU,YAAD,EAAkB,CACtE,GAAI,KAAKd,eAAL,CAAqBc,YAArB,CAAJ,CAAwC,CACtC,KAAMvG,YAAW,CAAG,GAAAC,gBAAA,EAAUsG,YAAV,CAAwB,UAAxB,CAAoC,KAAKzI,IAAzC,CAApB,CAEA,MAAO0I,QAAO,CAACC,GAAR,CAAY,CACjB;AACA,KAAKzG,WAAL,CAAiBQ,IAAjB,CAAsB,eAAtB,CAFiB,CAGjB;AACA;AACA;AACAR,WAAW,CAACQ,IAAZ,CAAiB,gBAAjB,CANiB,CAAZ,EAOJkG,IAPI,CAOEC,MAAD,GAAa,CACnBZ,KAAK,CAAEY,MAAM,CAAC,CAAD,CADM,CAEnBX,WAAW,CAAEW,MAAM,CAAC,CAAD,CAFA,CAAb,CAPD,CAWR,CAfqE,KAiBhEC,SAAQ,CAAG,GAAA3G,gBAAA,EAAUsG,YAAV,CAAwB,UAAxB,CAAoC,KAAKzI,IAAzC,CAjBqD,CAkBhE+I,iBAAiB,CAAG,GAAA5G,gBAAA,EAAUsG,YAAV,CAAwB,WAAxB,CAAqC,KAAKzI,IAA1C,CAlB4C,CAoBtE,MAAO0I,QAAO,CAACC,GAAR,CAAY,CACjBG,QAAQ,CAACpG,IAAT,CAAc,QAAd,CADiB,CAEjBoG,QAAQ,CAACpG,IAAT,CAAc,OAAd,CAFiB,CAGjBoG,QAAQ,CAACpG,IAAT,CAAc,gBAAd,CAHiB,CAIjB;AACAqG,iBAAiB,CAACrG,IAAlB,CAAuB,aAAvB,EAAsCsG,KAAtC,CAA4C,MAA5C,CALiB,CAAZ,EAMJJ,IANI,CAMEC,MAAD,GAAa,CACnBnB,aAAa,CAAEmB,MAAM,CAAC,CAAD,CADF,CAEnBZ,KAAK,CAAEY,MAAM,CAAC,CAAD,CAFM,CAGnBX,WAAW,CAAEW,MAAM,CAAC,CAAD,CAHA,CAInBI,WAAW,CAAEJ,MAAM,CAAC,CAAD,CAJA,CAAb,CAND,CAYR,CAhC+B,CAjBtB,CA0DJK,cAAc,CAAG,KAAKlE,WAAL,CAAiBS,IAAjB,CACrB,GAAA0B,cAAA,EAAIrG,MAAM,CAACqI,IAAX,CADqB,CAErB;AACA,GAAAC,+BAAA,EAAqB,CAACC,UAAD,CAAaC,UAAb,GAA4B,CAC/C,GAAID,UAAU,CAACE,MAAX,GAAsBD,UAAU,CAACC,MAArC,CACE,SAF6C,KAIzCC,OAAM,CAAG,GAAI/C,IAAJ,CAAQ4C,UAAR,CAJgC,CAKzCI,YAAY,CAAG,GAAIhD,IAAJ,CAAQ6C,UAAU,CAACI,MAAX,CAAkBC,QAAQ,EAAIH,MAAM,CAACI,GAAP,CAAWD,QAAX,CAA9B,CAAR,CAL0B,CAM/C,MAAOF,aAAY,CAACI,IAAb,GAAsBL,MAAM,CAACK,IACrC,CAPD,CAHqB,CAWrB;AACA,GAAA1C,cAAA,EAAK2C,cAAD,EAAoB,CACtB,KAAMC,kBAAiB,CAAGD,cAAc,CAACJ,MAAf,CAAuB9B,OAAD,EAAa,CAAC,KAAKD,eAAL,CAAqBC,OAArB,CAApC,CAA1B,CACA,MAAO,CAAC,KAAK1F,WAAL,CAAiB0F,OAAlB,EAA2B3D,MAA3B,CAAkC8F,iBAAlC,CACR,CAHD,CAZqB,CAgBrB;AACA;AACA;AACA,GAAAC,oBAAA,EACGF,cAAD,EAAoBpB,OAAO,CAACC,GAAR,CAClBmB,cAAc,CAAC3C,GAAf,CAAmB,KAAOsB,aAAP,EAAwB,CACzC,GAAIwB,YAAJ,CACA,GAAI,CACFA,WAAW,CAAG,KAAMzB,wBAAuB,CAAC0B,OAAxB,CAAgCzB,YAAhC,CACrB,CAAC,MAAO9F,CAAP,CAAU,CAAE,CAEd,sBACE8F,YADF,EAEKwB,WAFL,CAID,CAVD,CADkB,CADtB,CAnBqB,CAkCrB;AACA,GAAA9C,cAAA,EAAIgD,UAAU,EAAIA,UAAU,CAACT,MAAX,CACfZ,QAAD,EAAc,KAAKrB,KAAL,CAAWqB,QAAX,GAAwB,KAAKnB,eAAL,CAAqBmB,QAAQ,CAACL,YAA9B,CADtB,CAAlB,CAnCqB,CA1Db,CAqGJ2B,YAAY,CAAG,KAAKlI,WACxB;AADmB,CAElBtB,MAFkB,CAEX,QAFW,CAED,CAAE0E,SAAS,CAAE,QAAb,CAFC,EAGlBG,IAHkB,CAIjB;AACA,GAAAiE,iBAAA,EAAO,WAAC,CAAE5D,YAAF,CAAD,aAAsB,GAAAuE,gCAAA,EAAyBvE,YAAY,CAACwE,SAAtC,CAAtB,CAAP,CALiB,CAOjB;AACA,GAAAC,yBAAA,EACErB,cADF,CAEE,SAAqBsB,WAArB,CAAkCC,IAAlC,CAAwC,CACtC,KAAM,CAAExC,KAAK,CAAEyC,QAAT,EAAsBF,WAAW,CAAC1E,YAAxC,CACA,MAAO2E,KAAI,CAACtD,GAAL,CAAS,KAAOf,IAAP,EAAe,CAC7B,GAAIA,GAAG,CAAC6B,KAAJ,GAAcyC,QAAlB,CACE,MAAOtE,IAAP,CAGF,GAAI6D,YAAJ,CACA,GAAI,CACFA,WAAW,CAAG,KAAMzB,wBAAuB,CAAC0B,OAAxB,CAClB9D,GAAG,CAACqC,YADc,IAIrB,CAAC,MAAO9F,CAAP,CAAU,CAAE,CAEd,oDACKyD,GADL,EAEK6D,WAFL,MAGEU,OAAO,GAHT,EAKD,CAlBM,CAmBR,CAvBH,CARiB,CAiCjB;AACA,GAAAC,oBAAA,EAAUC,WAAW,EAAInC,OAAO,CAACC,GAAR,CAAYkC,WAAZ,CAAzB,CAlCiB,CArGX,CA8IJC,KAAK,CAAG,GAAAC,WAAA,EAAM7B,cAAN,CAAsBkB,YAAtB,CA9IJ,CAiJJY,aAAa,CAAGF,KAAK,CAACrF,IAAN,CACpB,GAAAmF,oBAAA,EACGH,IAAD,EAAU/B,OAAO,CAACC,GAAR,CACR8B,IAAI,CAACtD,GAAL,CAAS,KAAOf,IAAP,EAAe,CACtB,GAAI6E,QAAJ,CACA,GAAI7E,GAAG,CAAC6B,KAAJ,EAAa7B,GAAG,CAAC8B,WAArB,CAAkC,CAChC,KAAMF,SAAQ,CAAI,GAAE5B,GAAG,CAAC6B,KAAM,IAAG7B,GAAG,CAAC8B,WAAY,EAAjD,CACA,GAAI,CACF+C,OAAO,CAAG,KAAMnD,qBAAoB,CAACoC,OAArB,CAA6BlC,QAA7B,CACjB,CAAC,MAAOrF,CAAP,CAAU,CAAG,CAChB,CAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAIuI,oBAAmB,CAAG,EAA1B,CAYA,MAVE9E,IAAG,CAAC6C,WAAJ,EACAgC,OADA,EAEAjE,KAAK,CAACmE,OAAN,CAAcF,OAAO,CAACG,GAAtB,CAFA,EAGA,CAACH,OAAO,CAACG,GAAR,CAAYC,IAAZ,CAAiB,WAAC,CAAEC,IAAF,CAAQC,IAAR,CAAD,aAA6B,UAAT,GAAAD,IAAI,EAA4B,aAAT,GAAAC,IAA3C,CAAjB,CAOH,GALEL,mBAAmB,CAAG,CACpBjC,WAAW,GADS,CAKxB,+CACKgC,OADL,EAGK7E,GAHL,EAKK8E,mBALL,CAOD,CApCD,CADQ,CADZ,CADoB,CAjJZ,CA6LV,KAAKT,IAAL,CAAYO,aAAa,CAACvF,IAAd,CACV,GAAA4B,wBAAA,EAAc,CAAd,CADU,CA7LF,CAgMV,KAAKoD,IAAL,CAAUnD,OAAV,EAhMU,CAkMV;AACJ;AACA;AACA;AACA,oCAtMc,CAwMV;AAxMU,KAyMJkE,mBAAkB,CAAG,GAAIC,IAzMrB,CA0MJC,KAAK,CAAGZ,KAAK,CAACrF,IAAN,CACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAA0B,cAAA,EAAKsD,IAAD,EAAU3J,MAAM,CAAC+H,MAAP,CACZ4B,IAAI,CACDf,MADH,CACU,WAAC,CAAEzB,KAAF,CAAD,aAAe,CAAC,GAAA0D,+BAAA,EAAsB1D,KAAtB,CAAhB,CADV,EAEG2D,MAFH,CAEU,CAACC,cAAD,SAAqD,IAApC,CAAE5D,KAAF,CAASC,WAAT,CAAsByC,OAAtB,CAAoC,OAM3D,MALAkB,eAAc,CAAC5D,KAAD,CAAd,CAAwB,CACtBA,KADsB,CAEtB0C,OAFsB,CAGtBmB,eAAe,CAAE5D,WAHK,CAKxB,CAAO2D,cACR,CATH,CASK,EATL,CADY,CAAd,CAXY,CAwBZ;AACA;AACA;AACA,GAAA1E,cAAA,EAAK4E,KAAD,EAAW,MACPC,cAAa,CAAG,EADT,CAEPC,iBAAiB,CAAG,EAFb,CAgBb,MAZAF,MAAK,CAACG,OAAN,CAAeC,IAAD,EAAU,CACtB,KAAM,CAAElE,KAAF,CAAS0C,OAAT,EAAqBwB,IAA3B,CACKX,kBAAkB,CAAC5B,GAAnB,CAAuB3B,KAAvB,CAFiB,CAIX0C,OAJW,EAKpBsB,iBAAiB,CAACG,IAAlB,CAAuBnE,KAAvB,CALoB,CAGpB+D,aAAa,CAACI,IAAd,CAAmBnE,KAAnB,CAHoB,CAStBuD,kBAAkB,CAACzE,GAAnB,CAAuBkB,KAAvB,CAA8BkE,IAA9B,CACD,CAVD,CAYA,CAAO,CAACH,aAAD,CAAgBC,iBAAhB,CACR,CAjBD,CA3BY,CA8CZ;AACA,GAAAvC,iBAAA,EAAO,WAAC,CAACsC,aAAD,CAAgBC,iBAAhB,CAAD,aACLD,cAAa,CAACzC,MAAd,EAAwB0C,iBAAiB,CAAC1C,MADrC,CAAP,CA/CY,CAmDZ;AACA,GAAAqB,oBAAA,EAAU,aAA8C,IAAvC,CAACoB,aAAD,CAAgBC,iBAAhB,CAAuC,OACtD,KAAMI,SAAQ,CAAG,CAAC,KAAM3D,QAAO,CAACC,GAAR,CACtBqD,aAAa,CAAC7E,GAAd,CAAkB,KAAOc,MAAP,EAAiB,CACjC,GAAIqE,UAAJ,CAEA,GAAI,CACF,KAAMC,YAAW,CAAG,KAAM,MAAK7K,GAAL,CAAS6G,OAAT,CAAiBN,KAAjB,CAA1B,CACAqE,SAAS,CAAG,GAAAE,mBAAA,EAAcD,WAAd,CAA2B,KAAKvM,IAAhC,CAFV,CAGF,KAAMsM,UAAS,CAACzJ,yBAAV,EACP,CAAC,MAAO4J,GAAP,CAAY,CACZC,OAAO,CAACC,KAAR,CAAe,2BAA0B1E,KAAM,EAA/C,CAAkDwE,GAAlD,CACD,CAED,MAAO,CACLxE,KADK,CAELqE,SAFK,CAIR,CAfD,CADsB,CAkBtB;AACA;AACA;AACA;AACA;AAtBe,EAuBd5C,MAvBc,CAuBN2C,QAAD,EAAcA,QAAQ,CAACC,SAvBhB,CAAjB,CAwBA,MAAO,CAACD,QAAD,CAAWJ,iBAAX,CACR,CA1BD,CApDY,CAgFZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAAvG,mBAAA,EAAS,OAAmC,IAAlC,CAAC2G,QAAD,CAAWJ,iBAAX,CAAkC,OAC1C;AAD0C,KAEpCW,QAAO,CAAG,GAAApF,QAAA,EAAG,GAAGyE,iBAAN,EAAyBxG,IAAzB,CACd,GAAA0B,cAAA,EAAKc,KAAD,GAAY,CAAEA,KAAF,CAAZ,CAAJ,CADc,CAF0B,CAOpC4E,QAAQ,CAAG,GAAArF,QAAA,EAAG,GAAG6E,QAAN,CAPyB,CAUpCS,YAAY,CAAGD,QAAQ,CAACpH,IAAT,CACnB,GAAA0B,cAAA,EAAI,YAAC,CAAEc,KAAF,CAASqE,SAAT,CAAD,cAA2B,CAC7BrE,KAD6B,CAE7BsE,WAAW,CAAED,SAAS,CAAC1E,OAFM,CAA3B,CAAJ,CADmB,CAVqB,CAoBpCmF,QAAQ,CAAGF,QAAQ,CAACpH,IAAT,CACf;AACA;AACA;AACA,GAAAC,mBAAA,EAAS,cAAgC,IAAzB,CAAEuC,KAAF,CAASqE,SAAT,CAAyB,QACvC,KAAMU,gBAAe,CAAG,CACtB;AACA;AACA,IAAG,KAAM,GAAAC,wBAAA,EAAmBX,SAAnB,CAAT,CAHsB,CAAxB,CAMA;AACA;AACA;AACA;AACA;AACA,MAAOA,UAAS,CAAC1L,MAAV,CAAiB,YAAjB,EAA+B6E,IAA/B,CACL;AACA,GAAAmF,oBAAA,EAAU,KAAO/E,MAAP,EAAiB,MACnB,CAAEqH,SAAS,CAAEC,cAAb,EAAgCtH,KAAK,CAACC,YADnB,CAInBsH,SAAS,CAAiE,GAA9D,EAAC,KAAM,MAAKpN,IAAL,CAAUkE,GAAV,CAAcmJ,QAAd,CAAuBxH,KAAK,CAACX,WAA7B,CAAP,EAAkDkI,SAJ3C,CAMnBE,YAAY,CAAGN,eAAe,CAACO,SAAhB,CAA0B,YAAC,CAAEL,SAAF,CAAD,cAAmBA,UAAS,GAAKC,cAAjC,CAA1B,CANI,CAOnBK,WAAW,CACE,CAAC,CAAlB,GAAAF,YAAY,CACR,KAAM,GAAAG,wBAAA,EAAmBnB,SAAnB,CAA8Ba,cAA9B,CADE,CAERH,eAAe,CAACM,YAAD,CAVI,CAGzB;AASA,sCACKE,WADL,MAEEJ,SAFF,EAID,CAhBD,CAFK,CAoBL;AACA,GAAApH,oBAAA,EAAU,IAAV,CArBK,CAuBL;AACA,GAAAE,eAAA,EAAK,QAAsBwH,cAAtB,GAAyC,IAAxC,CAAEzF,KAAF,CAAS0F,QAAT,CAAwC,QACxCC,WAAW,CAAGD,QAD0B,CAE5C,GAAID,cAAJ,CAAoB,CAClB,KAAMJ,aAAY,CAAGK,QAAQ,CAACJ,SAAT,CAAmB,YAAC,CAAEL,SAAF,CAAD,cAAmBA,UAAS,GAAKQ,cAAc,CAACR,SAAhD,CAAnB,CAArB,CAEqB,CAAC,CAAlB,GAAAI,YAHc,CAIhBM,WAAW,CAAGD,QAAQ,CAAC1J,MAAT,CAAgByJ,cAAhB,CAJE,EAMhBE,WAAW,CAAG5G,KAAK,CAACrB,IAAN,CAAWgI,QAAX,CANE,CAOhBC,WAAW,CAACN,YAAD,CAAX,CAA4BI,cAPZ,CASnB,CAED,MAAO,CACLzF,KADK,CAEL0F,QAAQ,CAAEC,WAFL,CAIR,CAjBD,CAiBG,CACD3F,KADC,CAED0F,QAAQ,CAAEX,eAFT,CAjBH,CAxBK,CA8CR,CA1DD,CAJe,CAgEf;AACA;AACA;AACA;AACA,GAAAa,mBAAA,GApEe,CApByB,CAM1C;AAqFA;AACA;AACA,MAAO,GAAA9C,WAAA,EAAM+B,YAAN,CAAoBC,QAApB,CAA8BH,OAA9B,CACR,CA9FD,CAzFY,CAyLZ;AACA;AACA,GAAA1G,eAAA,EAAK,QAAY4H,UAAZ,GAA2B,IAA1B,CAAE/B,KAAF,CAA0B,aACxB,CAAE9D,KAAK,CAAE8F,YAAT,EAAqCD,UADb,CACEE,MADF,uCACaF,UADb,YAExBG,eAAe,gCAChBlC,KAAK,CAACgC,YAAD,CADW,EAEhBC,MAFgB,CAFS,CAO9B,MAAO,CACLjC,KAAK,gCACAA,KADA,MAEH,CAACgC,YAAD,EAAgBE,eAFb,EADA,CAKLC,gBAAgB,CAAEH,YALb,CAOR,CAdD,CAcG,CACDhC,KAAK,CAAE,EADN,CAEDmC,gBAAgB,CAAE,IAFjB,CAdH,CA3LY,CA8MZ;AACA,GAAAxE,iBAAA,EAAO,YAAC,CAAEqC,KAAF,CAASmC,gBAAT,CAAD,cACL,CAAC,CAACA,gBAAF,EAAsBlH,KAAK,CAACmE,OAAN,CAAcY,KAAK,CAACmC,gBAAD,CAAL,CAAwBP,QAAtC,CADjB,CAAP,CA/MY,CAmNZ;AACA;AACA;AACA,GAAA/C,oBAAA,EAAU,cAA8C,IAAvC,CAAEmB,KAAF,CAASmC,gBAAgB,CAAEjG,KAA3B,CAAuC,aAChD,CAAEsE,WAAF,CAAeoB,QAAf,EAA4B5B,KAAK,CAAC9D,KAAD,CADe,CAEhDkG,iBAAiB,CAAG3C,kBAAkB,CAACzG,GAAnB,CAAuBkD,KAAvB,CAF4B,CAIhDmG,YAAY,CAAG,CAAEnG,KAAF,CAASsE,WAAT,CAAsBoB,QAAtB,CAJiC,CAKhDU,gBAAgB,CAAGC,OAAO,EACvBxG,oBAAoB,CACxBoC,OADI,CACK,GAAEjC,KAAM,IAAGqG,OAAO,CAACxC,eAAgB,EADxC,EAEJ9C,KAFI,CAEE,KAAO,EAAP,CAFF,EAGJJ,IAHI,CAGC2F,OAAO,GAAK,CAChBA,OADgB,CAEhBD,OAAO,CAAEA,OAAO,CAACA,OAFD,CAAL,CAHR,CAN6C,CAehDE,aAAa,CAAGb,QAAQ,CAACA,QAAQ,CAACpE,MAAT,CAAkB,CAAnB,CAfwB,CAgBhDkF,cAAc,CAAGzH,KAAK,CAACrB,IAAN,CAAWgI,QAAX,CACrB;AADqB,CAEpBe,OAFoB,GAGpBC,IAHoB,CAGfL,OAAO,EAAI,GAAAzG,qBAAA,EAAeyG,OAAO,CAACxC,eAAvB,CAAwCqC,iBAAiB,CAACrC,eAA1D,CAHI,CAhB+B,CAqBtD,GAAI,CAAC2C,cAAL,CACE;AACA;AACA,sCACKL,YADL,MAEEK,cAAc,CAAE,IAFlB,CAGED,aAAa,CAAE,KAAMH,iBAAgB,CAACG,aAAD,CAHvC,GAxBoD,KA+BhDI,0BAAyB,CAAGP,gBAAgB,CAACI,cAAD,CA/BI,CAgChDI,wBAAwB,CAC5B,GAAAhH,qBAAA,EAAe4G,cAAc,CAAC3C,eAA9B,CAA+C0C,aAAa,CAAC1C,eAA7D,EACI8C,yBADJ,CAEIP,gBAAgB,CAACG,aAAD,CAnCgC,CAqCtD,sCACKJ,YADL,MAEEK,cAAc,CAAE,KAAMG,0BAFxB,CAGEJ,aAAa,CAAE,KAAMK,yBAHvB,EAKD,CA1CD,CAtNY,CA1MJ,CA6cV,KAAKhD,cAAL,CAAsBH,KAAK,CAACjG,IAAN,CACpB;AACA;AACA,GAAAS,eAAA,EAAK,CAAC6F,KAAD,CAAQ+C,WAAR,GAAwB,CAC3B,KAAMC,UAAS,CAAGhD,KAAK,CAACwB,SAAN,CAAgBpB,IAAI,EAAIA,IAAI,CAACI,WAAL,GAAqBuC,WAAW,CAACvC,WAAzD,CAAlB,CACA,GAAkB,CAAC,CAAf,GAAAwC,SAAJ,CACE,MAAOhD,MAAK,CAAC9H,MAAN,CAAa6K,WAAb,CAAP,CADF,IAEO,CACL,KAAME,UAAS,CAAGhI,KAAK,CAACrB,IAAN,CAAWoG,KAAX,CAAlB,CAEA,MADAiD,UAAS,CAACD,SAAD,CAAT,CAAuBD,WACvB,CAAOE,SACR,CACF,CATD,CASG,EATH,CAHoB,CAapB;AACA,GAAAC,uBAAA,EAAa,GAAb,CAAkBC,oBAAlB,CAAkC,CAAEC,OAAO,GAAT,CAAkBC,QAAQ,GAA1B,CAAlC,CAdoB,CAepB,GAAA/H,wBAAA,EAAc,CAAd,CAfoB,CA7cZ,CA8dV,KAAKwE,cAAL,CAAoBvE,OAApB,EACD,CAED;AACF;AACA;AACA;AACA,KACElE,cAAc,EAAI,CAChB,KAAKiM,UAAL,CAAkB,KAAK5E,IAAL,CAAUhF,IAAV,CAChB,GAAA0B,cAAA,EACGsD,IAAD,EAAUA,IAAI,CAACf,MAAL,CAAatD,GAAD,EAASA,GAAG,CAAC6C,WAAzB,CADZ,CADgB,CAIhB,GAAA5B,wBAAA,EAAc,CAAd,CAJgB,CADF,CAOhB,KAAKgI,UAAL,CAAgB/H,OAAhB,EACD,CAED;AACF;AACA;AACA;AACA,KACEjE,kBAAkB,EAAI,CACpB,KAAKiM,cAAL,CAAsB,GAAIC,sBAAJ,CAAoB,EAApB,EAAwB9J,IAAxB,CACpB,GAAAS,eAAA,EACE,CAACsJ,WAAD,cAAc,CAAE5H,OAAF,CAAW6H,UAAX,CAAd,cACE3O,OAAM,CAACC,MAAP,CAAcyO,WAAd,CAA2B,CAAE,CAAC5H,OAAD,EAAW6H,UAAb,CAA3B,CADF,CADF,CADoB,CAKpB,GAAApI,wBAAA,EAAc,CAAd,CALoB,CADF,CAQpB,KAAKiI,cAAL,CAAoBhI,OAApB,EACD,CAED;AACF;AACA;AACA;AACA;AACA;AACA,KACEoI,gBAAgB,CAAE9H,OAAF,CAAW6H,UAAX,CAAuB,CACrC,KAAKH,cAAL,CAAoBK,IAApB,CAAyB,CACvB/H,OADuB,CAEvB6H,UAFuB,CAAzB,CAID,CAED;AACF;AACA;AACA;AACA,KAC6B,KAArBvM,sBAAqB,EAAI,MACvB0M,yBAAwB,CAAG,CAAC,CAChCrE,IAAI,CAAE,OAD0B,CAEhC/K,QAAQ,CAAE,GAAIqP,gCAFkB,CAAD,CADJ,CAOvBC,iBAAiB,CAAG,CAAC,GAAGF,wBAAJ,CAA8B,GADtB,EACR,CAPG,CAK7B;AAIA;AAYA;AAXA,KAAMlH,QAAO,CAACC,GAAR,CAAYmH,iBAAiB,CAAC3I,GAAlB,CAAsB,QAAkB,IAAjB,CAAE3G,QAAF,CAAiB,QACxD;AADwD,MAE3B,UAAzB,QAAOA,SAAQ,CAACgC,IAFoC,CAG/ChC,QAAQ,CAACgC,IAAT,EAH+C,CAKjDkG,OAAO,CAACH,OAAR,EACR,CANiB,CAAZ,CAVuB,CAkB7B,KAAKwH,yBAAL,CAAiC,GAAItE,IAAJ,CAC/BqE,iBAAiB,CAAC3I,GAAlB,CAAsB,YAAC,CAAEoE,IAAF,CAAQ/K,QAAR,CAAD,cAAwB,CAAC+K,IAAD,CAAO/K,QAAP,CAAxB,CAAtB,CAD+B,CAlBJ,CAsB7B,KAAKwP,eAAL,CAAuB,GAAIrM,cAC5B,CAED;AACF;AACA;AACA;AACA;AACA;AACA,KACEsM,qBAAqB,CAAErI,OAAF,CAAWsI,QAAX,CAAqB,MAElC1P,SAAQ,CAAG,KAAKuP,yBAAL,CAA+BhL,GAA/B,SAFuB,OAGpCvE,SAAQ,EAA+B,UAA3B,QAAOA,SAAQ,CAAC2P,MAHQ,CAI/B3P,QAAQ,CAAC2P,MAAT,CAAgBvI,OAAhB,CAAyBsI,QAAzB,CAJ+B,CAMjCxH,OAAO,CAAC0H,MAAR,CAAe,GAAIxN,MAAJ,CAAW,aAAD,OAA0B,iBAApC,CAAf,CACR,CAED;AACF;AACA;AACA;AACA;AACA,KACEyN,sBAAsB,CAAEzI,OAAF,CAAW,MAEzBpH,SAAQ,CAAG,KAAKuP,yBAAL,CAA+BhL,GAA/B,SAFc,CACF;AADE,MAG3BvE,SAAQ,EAAgC,UAA5B,QAAOA,SAAQ,CAAC+H,OAHD,CAItB/H,QAAQ,CAAC+H,OAAT,CAAiBX,OAAjB,CAJsB,CAMxBc,OAAO,CAAC0H,MAAR,CAAe,GAAIxN,MAAJ,CAAW,aAAD,OAA0B,iBAApC,CAAf,CACR,CAED;AACF;AACA;AACA;AACA;AACA,KACE0N,gBAAgB,CAAEC,UAAF,CAAc,MAEtB/P,SAAQ,CAAG,KAAKuP,yBAAL,CAA+BhL,GAA/B,SAFW,CACC;AADD,MAGxBvE,SAAQ,EAA+B,UAA3B,QAAOA,SAAQ,CAACgQ,MAHJ,CAInBhQ,QAAQ,CAACgQ,MAAT,CAAgBD,UAAhB,CAJmB,CAMrB7H,OAAO,CAAC0H,MAAR,CAAe,GAAIxN,MAAJ,CAAW,aAAD,OAA0B,iBAApC,CAAf,CACR,CAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KACE6N,kCAAkC,CAAE7I,OAAF,CAAW,CACd;AADc,MAEvC,MAAKmI,yBAAL,CAA+BnG,GAA/B,SAFuC,CAGlC,GAAIlB,QAAJ,CAAY,CAACH,OAAD,CAAU6H,MAAV,GAAqB,CACtC,KAAKJ,eAAL,CAAqBL,IAArB,CAA0B,CACxB/H,OADwB,CAExB8I,YAAY,CALG,OAGS,CAGxBnI,OAHwB,CAIxB6H,MAAM,CAAE3D,GAAF,CAAO,CACX2D,MAAM,CAAC3D,GAAG,EAAI,GAAI7J,MAAJ,CAAU,6CAAV,CAAR,CACP,CANuB,CAA1B,CAQD,CATM,CAHkC,CAepC8F,OAAO,CAAC0H,MAAR,CAAe,GAAIxN,MAAJ,CAAW,aAAD,OAA0B,iBAApC,CAAf,CACR,CAED;AACF;AACA;AACA;AACA;AACA,KAC6B,KAArB+N,sBAAqB,CAAEC,SAAF,CAAa,CACtC,KAAMC,cAAa,CAAG,KAAKd,yBAAL,CAA+BhL,GAA/B,CAAmC,OAAnC,CAAtB,CACA,IAAK,KAAM6C,QAAX,GAAsBgJ,UAAtB,CACE,KAAMC,cAAa,CAACC,MAAd,CAAqBlJ,OAArB,CAET,CAED;AACF;AACA;AACA;AACA,KACEmJ,kBAAkB,EAAI,CACpB,MAAO,MAAKhB,yBAAL,CAA+BhL,GAA/B,CAAmC,OAAnC,EAA4CiM,MAA5C,EACR,CAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA,KACExN,YAAY,EAA8B,IAA5B,CAAEyN,UAAF,CAAcC,KAAd,CAA4B,wDAAJ,EAAI,CACxC,KAAKzN,QAAL,CAAgB,GAAI8L,sBAAJ,CAAoB,CAClC0B,UAAU,CAAEA,UAAU,EAAI,OADQ,CAElCC,KAAK,CAAEA,KAAK,EAAI,IAFkB,CAApB,CAIjB,CAED;AACF;AACA;AACA;AACA;AACA;AACA,KACEC,WAAW,CAAEF,UAAF,CAA4B,IAAdC,MAAc,wDAAN,IAAM,CACrC,KAAKzN,QAAL,CAAckM,IAAd,CAAmB,CACjBsB,UADiB,CAEjBC,KAFiB,CAAnB,CAID,CAED;AACF;AACA;AACA;AACA;AACA,KACmB,KAAX5N,YAAW,CAAEC,OAAF,CAAW,CAC1B,KAAKA,OAAL,CAAe,GAAIS,oBAAJ,CAAkB,CAAlB,CADW,CAGtBT,OAHsB,CAIxB,KAAKA,OAAL,CAAaoM,IAAb,CAAkBpM,OAAlB,CAJwB,CAMxB,KAAKA,OAAL,CAAaoM,IAAb,CAAkB,CAChByB,EAAE,CAAE,KAAM,MAAKpR,IAAL,CAAUkE,GAAV,CAAcmN,UAAd,EADM,CAEhB/F,IAAI,CAAE,KAAM,MAAKtL,IAAL,CAAUkE,GAAV,CAAcoN,GAAd,CAAkBC,cAAlB,EAFI,CAAlB,CAKH,CAED;AACF;AACA;AACA;AACA;AACA;AACA,KACsB,KAAdC,eAAc,CAAEC,UAAF,CAAcC,IAAd,CAAoB,CACtC,GAAoB,QAAhB,QAAOA,KAAX,CACE,KAAM,IAAI9O,MAAJ,CAAU,uBAAV,CAAN,CAGF,GAAI,EAAC,KAAM,MAAK+O,MAAL,CAAYF,UAAZ,CAAP,CAAJ,CACE,KAAM,IAAI7O,MAAJ,CAAW,8CAA6C6O,UAAW,EAAnE,CAAN,CAGF,MAAO,IAAI/I,QAAJ,CAAY,CAACH,OAAD,CAAU6H,MAAV,GAAqB,CACtC,KAAK1M,WAAL,CAAiBiM,IAAjB,CAAsB,CACpB8B,UADoB,CAEpBC,IAFoB,CAGpBnJ,OAHoB,CAIpB6H,MAAM,CAAE3D,GAAF,CAAO,CACX2D,MAAM,CAAC3D,GAAG,EAAI,GAAI7J,MAAJ,CAAU,uBAAV,CAAR,CACP,CANmB,CAAtB,CAQD,CATM,CAUR,CAED;AACF;AACA;AACA;AACA;AACA;AACA,KACEgP,UAAU,CAAEH,UAAF,CAAcC,IAAd,CAAoB,CAC5B,GAAoB,QAAhB,QAAOA,KAAX,CACE,KAAM,IAAI9O,MAAJ,CAAU,uBAAV,CAAN,CAGF,KAAKN,cAAL,CAAoBuP,IAApB,CAAyBJ,UAAzB,CAAqCK,kBAAA,CAAaC,IAAlD,CAAwDL,IAAxD,CACD,CAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KACc,KAANM,OAAM,CAAEvJ,YAAF,CAAgB,CAC1B;AAEA;AACA;AAJ0B,KAKpBgC,KAAI,CAAG,KAAM,MAAKA,IAAL,CAAUhF,IAAV,CAAe,GAAAwM,gBAAA,GAAf,EAAwBC,SAAxB,EALO,CAOpB9L,GAAG,CAAGqE,IAAI,CAACkE,IAAL,CAAWvI,GAAD,EAAS,GAAAyB,qBAAA,EAAezB,GAAG,CAACqC,YAAnB,CAAiCA,YAAjC,CAAnB,CAPc,CAUpBK,QAAQ,CAAG,GAAAqJ,0BAAA,EAAoB/L,GAAG,CAACqC,YAAxB,CAAsCrC,GAAG,CAACgF,GAA1C,CAA+C,KAAKpL,IAApD,CAVS,CAc1B;AACA,MAHA,MAAM8I,SAAQ,CAACjG,yBAAT,EAGN,CAAQuP,wBAAD,EAA8B,CACnC;AADmC,KAE7BC,UAAS,CAAG,GAAIC,sBAAJ,CAChBF,wBADgB,CAFiB,CAS7BG,QAAQ,CAAGF,SAAS,CAACG,QAAV,GAAqB/M,IAArB,CACf,GAAA0B,cAAA,EAAI+C,OAAO,GAAK,CAAEA,OAAF,CAAWuI,KAAK,CAAE3J,QAAlB,CAA4B4J,OAAO,CAAE,IAArC,CAAL,CAAX,CADe,CAEf;AACA;AACA,GAAArL,wBAAA,EAAc,CAAd,CAJe,CATkB,CAMnC;AACA;AACA;AAOAkL,QAAQ,CAACjL,OAAT,EAfmC,CAiBnC;AAjBmC,KAkB7BqL,oBAAmB,CAAGC,QAAQ,CAACC,sBAAT,CAC1B;AACAD,QAAQ,CAACE,oBAAT,CAA8BP,QAA9B,CAAwC,UAAxC,CAAoDK,QAAQ,CAAC7P,QAA7D,CAF0B,CAG1B6P,QAAQ,CAACE,oBAAT,CAA8BP,QAA9B,CAAwC,OAAxC,CAAiDK,QAAQ,CAACnS,KAA1D,CAH0B,CAI1BmS,QAAQ,CAACE,oBAAT,CAA8BP,QAA9B,CAAwC,iBAAxC,CAA2DK,QAAQ,CAACG,cAApE,CAJ0B,CAK1BH,QAAQ,CAACE,oBAAT,CAA8BP,QAA9B,CAAwC,sBAAxC,CAAgEK,QAAQ,CAACI,mBAAzE,CAL0B,CAM1BJ,QAAQ,CAACE,oBAAT,CAA8BP,QAA9B,CAAwC,UAAxC,CAAoDK,QAAQ,CAACK,OAA7D,CAN0B,CAO1BL,QAAQ,CAACE,oBAAT,CAA8BP,QAA9B,CAAwC,SAAxC,CAAmDK,QAAQ,CAACrP,OAA5D,CAP0B,CAQ1BqP,QAAQ,CAACE,oBAAT,CAA8BP,QAA9B,CAAwC,MAAxC,CAAgDK,QAAQ,CAAClB,IAAzD,CAR0B,CAS1BkB,QAAQ,CAACE,oBAAT,CAA8BP,QAA9B,CAAwC,WAAxC,CAAqDK,QAAQ,CAACnP,QAA9D,CAT0B,CAU1BmP,QAAQ,CAACE,oBAAT,CAA8BP,QAA9B,CAAwC,SAAxC,CAAmDK,QAAQ,CAACM,OAA5D,CAV0B,CAW1BN,QAAQ,CAACE,oBAAT,CAA8BP,QAA9B,CAAwC,UAAxC,CAAoDK,QAAQ,CAACO,OAA7D,CAX0B,CAa1B;AACAP,QAAQ,CAACE,oBAAT,CAA8BP,QAA9B,CAAwC,QAAxC,CAAkDK,QAAQ,CAACQ,MAA3D,CAd0B,CAe1BR,QAAQ,CAACE,oBAAT,CAA8BP,QAA9B,CAAwC,MAAxC,CAAgDK,QAAQ,CAAClQ,IAAzD,CAf0B,CAgB1BkQ,QAAQ,CAACE,oBAAT,CAA8BP,QAA9B,CAAwC,cAAxC,CAAwDK,QAAQ,CAACS,WAAjE,CAhB0B,CAiB1BT,QAAQ,CAACE,oBAAT,CAA8BP,QAA9B,CAAwC,QAAxC,CAAkDK,QAAQ,CAAChS,MAA3D,CAjB0B,CAkB1BgS,QAAQ,CAACE,oBAAT,CAA8BP,QAA9B,CAAwC,aAAxC,CAAuDK,QAAQ,CAACpN,UAAhE,CAlB0B,CAoB1B;AACAoN,QAAQ,CAACE,oBAAT,CAA8BP,QAA9B,CAAwC,eAAxC,CAAyDK,QAAQ,CAACU,YAAlE,CArB0B,CAsB1BV,QAAQ,CAACE,oBAAT,CAA8BP,QAA9B,CAAwC,iBAAxC,CAA2DK,QAAQ,CAACW,cAApE,CAtB0B,CAuB1BX,QAAQ,CAACE,oBAAT,CAA8BP,QAA9B,CAAwC,iBAAxC,CAA2DK,QAAQ,CAACY,cAApE,CAvB0B,CAwB1BZ,QAAQ,CAACE,oBAAT,CAA8BP,QAA9B,CAAwC,sBAAxC,CAAgEK,QAAQ,CAACa,kBAAzE,CAxB0B,CA0B1B;AACAb,QAAQ,CAACE,oBAAT,CAA8BP,QAA9B,CAAwC,UAAxC,CAAoDK,QAAQ,CAACc,aAA7D,CA3B0B,CA4B1Bd,QAAQ,CAACE,oBAAT,CAA8BP,QAA9B,CAAwC,kBAAxC,CAA4DK,QAAQ,CAACe,eAArE,CA5B0B,CA6B1Bf,QAAQ,CAACE,oBAAT,CAA8BP,QAA9B,CAAwC,mBAAxC,CAA6DK,QAAQ,CAACtC,gBAAtE,CA7B0B,EA8B1BsD,SA9B0B,CA+BzBC,QAAD,EAAcxB,SAAS,CAACyB,YAAV,CAAuBD,QAAQ,CAACzC,EAAhC,CAAoCyC,QAAQ,CAACE,OAA7C,CA/BY,CAlBO,CAqD7BC,QAAQ,CAAG,IAAMrB,mBAAmB,CAACsB,WAApB,EArDY,CAuD7BC,qBAAqB,CAAG,UAC5BF,QAAQ,EADoB,CAIrBlT,MAAM,CACVqI,IADI,CACC,KAAM,MAAK1I,KAAL,CAAWuQ,MAAX,EADP,EAEJpF,MAFI,CAEG,CAACuI,OAAD,CAAUnM,QAAV,GACCmM,OAAO,CAACvL,IAAR,CAAa,IAClBZ,QAAQ,CAACoM,UAAT,CAAoB3L,YAApB,EACI,KAAKhI,KAAL,CAAWqQ,MAAX,CAAkB9I,QAAlB,CADJ,CAEIU,OAAO,CAACH,OAAR,EAHC,CAHJ,CAQFG,OAAO,CAACH,OAAR,EARE,CAJqB,CAvDK,CAoDnC;AAkBA,MAAO,CACLyL,QADK,CAELE,qBAFK,CAIR,CACF,CAED;AACF;AACA;AACA;AACA;AACA,KACE9P,WAAW,CAAErB,QAAF,CAAY,CACrB,KAAKA,QAAL,CAAc4M,IAAd,CAAmB5M,QAAnB,CACD,CAED;AACF;AACA;AACA;AACA,KACEoB,WAAW,EAAI,CACb,MAAO,MAAKpB,QAAL,CAAc0C,IAAd,CAAmB,GAAAwM,gBAAA,GAAnB,EAA4BC,SAA5B,EACR,CAED;AACF;AACA;AACA;AACA;AACA;AACA,KACEmB,WAAW,CAAEgB,OAAF,CAAWC,aAAX,CAA0B,OACZ,QAAnB,QAAOD,QADwB,CAI5B,GAAI3L,QAAJ,CAAY,CAACH,OAAD,CAAU6H,MAAV,GAAqB,CACtC,KAAKvM,UAAL,CAAgB8L,IAAhB,CAAqB,CACnB0E,OADmB,CAEnBC,aAFmB,CAGnB/L,OAHmB,CAInB6H,MAAM,CAAE3D,GAAF,CAAO,CACX2D,MAAM,CAAC3D,GAAG,EAAI,GAAI7J,MAAJ,CAAU,4BAAV,CAAR,CACP,CANkB,CAArB,CAQD,CATM,CAJ4B,CAE1B8F,OAAO,CAAC0H,MAAR,CAAe,GAAIxN,MAAJ,CAAU,kCAAV,CAAf,CAYV,CAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA,KACE2R,sBAAsB,CAAEC,eAAF,CAAsC,IAAnB,CAAEC,QAAF,CAAmB,wDAAJ,EAAI,CAC1D,MAAO,IAAI/L,QAAJ,CAAY,CAACH,OAAD,CAAU6H,MAAV,GAAqB,CACtC,KAAKxM,YAAL,CAAkB+L,IAAlB,CAAuB,CACrBpH,OADqB,CAErBkM,QAAQ,CAAE,CAAC,CAACA,QAFS,CAGrBC,WAAW,CAAEF,eAAe,CAAC,CAAD,CAHP,CAIrB9C,IAAI,CAAE8C,eAJe,CAKrBpE,MAAM,CAAE3D,GAAF,CAAO,CACX2D,MAAM,CAAC3D,GAAG,EAAI,GAAI7J,MAAJ,CAAU,gCAAV,CAAR,CACP,CAPoB,CAAvB,CASD,CAVM,CAWR,CAED;AACF;AACA;AACA;AACA;AACA;AACA,KACwB,KAAhB+R,iBAAgB,CAAEC,MAAF,CAAUC,MAAV,CAAkB,CACtC,KAAMnD,KAAI,CAAG,KAAM,MAAKoD,qBAAL,CAA2BF,MAA3B,CAAmCC,MAAnC,CAAnB,CACA,MAAO,MAAKN,sBAAL,CAA4B7C,IAA5B,CACR,CAED;AACF;AACA;AACA;AACA;AACA,KACEC,MAAM,CAAElJ,YAAF,CAAgB,CACpB,MAAO,MAAKgC,IAAL,CAAUhF,IAAV,CACL,GAAA0B,cAAA,EAAIsD,IAAI,EAAIA,IAAI,CAACkE,IAAL,CAAUvI,GAAG,EAAI,GAAAyB,qBAAA,EAAezB,GAAG,CAACqC,YAAnB,CAAiCA,YAAjC,CAAjB,CAAZ,CADK,CAEL,GAAAwJ,gBAAA,GAFK,EAGLC,SAHK,EAIR,CAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAC0B,KAAlB6C,mBAAkB,CAAEC,WAAF,CAAeC,eAAf,CAAgCJ,MAAhC,CAAwCK,cAAxC,CAAwD,CAC9E,KAAMnS,SAAQ,CAAG,KAAM,MAAKoB,WAAL,EAAvB,CAEA,IAAK,GAAIgR,QAAT,GAAoBpS,SAApB,CAA8B,CAC5B,KAAM2O,KAAI,CAAG,KAAM,MAAK0D,wBAAL,CACjBD,OADiB,CAEjBH,WAFiB,CAGjBC,eAHiB,CAIjBJ,MAJiB,CAKjBK,cALiB,CAAnB,CAQA,GAAkB,CAAd,CAAAxD,IAAI,CAACnI,MAAT,CACE,GAAI,CACF,MAAO,MAAK8L,uBAAL,CAA6B3D,IAA7B,CACR,CAAC,MAAO/O,CAAP,CAAU,CACV,MAAO+O,KACR,CAEJ,CAED,MAAO,EACR,CAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KACkC,KAA1B4D,2BAA0B,CAAEN,WAAF,CAAeO,iBAAf,CAAkCV,MAAlC,CAA0C,CACxE,GAAI,GAAAhN,qBAAA,EAAemN,WAAf,CAA4B,KAAK3Q,QAAL,CAAcuD,OAA1C,CAAJ,CACE,GAAI,CACF,MAAO,MAAKkN,qBAAL,CAA2BS,iBAAiB,CAAChK,IAA7C,CAAmDsJ,MAAnD,CACR,CAAC,MAAOlS,CAAP,CAAU,CACV,MAAO,EACR,CAGH,KAAM6S,aAAY,CAAG,KAAM,MAAK7D,MAAL,CAAYqD,WAAZ,CAA3B,CACA,GAAIQ,YAAJ,CACE;AACA,MAAO,MAAKT,kBAAL,CAAwBC,WAAxB,CAAqCO,iBAAiB,CAAChK,IAAvD,CAA6DsJ,MAA7D,CAAP,CAGF;AACA;AACA,KAAMM,QAAO,CAAG,CAAC,KAAM,MAAKhR,WAAL,EAAP,EAA2B,CAA3B,CAAhB,CAEA,GAAI,CACF,KAAMsR,GAAE,CAAG,KAAM,GAAAC,qCAAA,EAAwBP,OAAxB,CAAiCH,WAAjC,CAA8CO,iBAA9C,CAAiEV,MAAjE,CAAyE,KAAK7U,IAA9E,CAAjB,CACA,MAAO,MAAKqV,uBAAL,CAA6B,CAACI,EAAD,CAA7B,CACR,CAAC,MAAO9S,CAAP,CAAU,CACV,MAAO,EACR,CACF,CAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KACyC,KAAjCgT,kCAAiC,CAAEC,YAAF,CAA4C,IAA5B,CAAEC,SAAS,CAAG,KAAd,CAA4B,wDAAJ,EAAI,CACjF;AADiF,KAE3EC,eAAc,CACJ,KAAd,GAAAD,SAAS,CACLD,YAAa;AADR,CAES,QAAd,GAAAC,SAAS,CACP,CAACD,YAAY,CAAC,CAAD,CAAb,CAAkB;AADX,CAEP,EAPyE,CAQ3EG,WAAW,CAAG,KAAMrN,QAAO,CAACC,GAAR,CACxBmN,cAAc,CAAC3O,GAAf,CACE,YAAC,CAAC6N,WAAD,CAAcC,eAAd,CAA+BJ,MAA/B,CAAD,cACE,GAAAhN,qBAAA,EAAemN,WAAf,CAA4B,KAAK3Q,QAAL,CAAcuD,OAA1C,EACI,KAAKkN,qBAAL,CAA2BG,eAA3B,CAA4CJ,MAA5C,CADJ,CAEI,KAAKE,kBAAL,CAAwBC,WAAxB,CAAqCC,eAArC,CAAsDJ,MAAtD,CAHN,CADF,CADwB,CARuD,CAkB3EmB,UAAU,CAAG,GAAAC,2BAAA,EAAmBF,WAAnB,CAlB8D,CAmBjF,GAAIC,UAAJ,CAAgB,CACd;AADc,KAERE,OAAM,CAAG,CAAC,KAAM,MAAK/R,WAAL,EAAP,EAA2B,CAA3B,CAFD,CAGRgS,kBAAkB,CAAG,KAAMzN,QAAO,CAACC,GAAR,CAC/BiN,YAAY,CAACzO,GAAb,CACE,kBAAO,CAAC6N,WAAD,CAAcC,eAAd,CAA+BJ,MAA/B,CAAP,cACE,GAAAuB,2CAAA,EAA8BF,MAA9B,CAAsC,KAAM,MAAKvE,MAAL,CAAYqD,WAAZ,CAA5C,CAAsEC,eAAtE,CAAuFJ,MAAvF,CAA+F,KAAK7U,IAApG,CADF,CADF,CAD+B,CAHnB,CAE+B;AAQ7C,GAA8B,CAA1B,GAAA+V,WAAW,CAAC,CAAD,CAAX,CAAexM,MAAnB,CACE;AACA,GAAI,CACF,KAAM8M,sBAAqB,CAAG,KAAM,MAAKhB,uBAAL,CAClC,KAAM3M,QAAO,CAACC,GAAR,CACJwN,kBAAkB,CAAChP,GAAnB,CAAuBuN,WAAW,EAAI,KAAK4B,mBAAL,CAAyB5B,WAAzB,CAAtC,CADI,CAD4B,CAApC,CAMA,MAAO,CACLhD,IAAI,CAAE,EADD,CAEL9N,YAAY,CAAEyS,qBAFT,CAIR,CAAC,MAAO1T,CAAP,CAAU,CAAG,CAbjB,IAcO,CACL;AADK,KAEC4T,2BAA0B,CAAG,GAAAC,+CAAA,EAAkCN,MAAlC,CAA0C,EAA1C,CAA8C,KAAKlW,IAAnD,CAF9B,CAGCyW,aAAa,CAAGV,WAAW,CAAC,CAAD,CAC/B;AADoB,CAEnBW,KAFmB,CAEb,CAFa,CAEV,CAAC,CAFS,CAGpB;AAHoB,CAInBhI,OAJmB,EAKpB;AALoB,CAMnBvH,GANmB,CAMf,YAAC,CAAEwP,EAAF,CAAD,cAAYA,GAAZ,CANe,EAOnB/K,MAPmB,CAQlB,CAAC8F,IAAD,CAAOkF,aAAP,GAAyB,MACjBC,SAAQ,CAAGnF,IAAI,CAAC,CAAD,CADE,CAEjBoF,eAAe,CAAG,GAAAC,4BAAA,EAAiB/P,KAAK,CAACmE,OAAN,CAAc0L,QAAd,EAA0BA,QAA1B,CAAqC,CAACA,QAAD,CAAtD,CAFD,CAGvB,MAAO,CAACN,0BAA0B,CAACK,aAAD,CAAgBE,eAAhB,CAA3B,CAA6D,GAAGpF,IAAhE,CACR,CAZiB,CAalB;AACA;AACA,CAACyE,kBAAD,CAfkB,CAHjB,CAqBL,GAAI,CAGF,MADAM,cAAa,CAAC,CAAD,CAAb,CAAmB,KAAM,MAAKH,mBAAL,CAAyBG,aAAa,CAAC,CAAD,CAAtC,IACzB,CAAO,CACL/E,IAAI,CAAE,KAAM,MAAK2D,uBAAL,CAA6BoB,aAA7B,CADP,CAEL;AACA7S,YAAY,CAAE,CAAC6S,aAAa,CAAC,CAAD,CAAd,CAHT,CAKR,CAAC,MAAO9T,CAAP,CAAU,CAAG,CAChB,CACF,CAED;AACA,MAAO,CACL+O,IAAI,CAAE,EADD,CAEL9N,YAAY,CAAE,EAFT,CAIR,CAED;AACF;AACA;AACA;AACA;AACA;AACA,KAC4B,KAApBoT,qBAAoB,CAAEvF,UAAF,CAAcwF,QAAd,CAAwB,MAC1CjS,YAAW,CAAG,KAAM,MAAKA,WAAL,CAAiBS,IAAjB,CAAsB,GAAAwM,gBAAA,GAAtB,EAA+BC,SAA/B,EADsB,CAE1C7L,cAAc,CAAGrB,WAAW,CAACyM,UAAD,CAFc,CAIhD,MAAO/K,iBAAA,CAAQ3B,GAAR,CAAYsB,cAAZ,CAA6B,GAAE4Q,QAAS,UAAxC,CACR,CAED;AACF;AACA;AACA;AACA;AACA;AACA,KAC6B,KAArBnC,sBAAqB,CAAEG,eAAF,CAAmBJ,MAAnB,CAA2B,MAC9CqC,QAAO,CAAG,KAAK7S,QAAL,CAAcuD,OADsB,CAE9C3E,GAAG,CAAG,KAAM,MAAK0O,MAAL,CAAYuF,OAAZ,CAFkC,CAI9CtC,MAAM,CAAG,GAAAuC,iCAAA,EAA2BlU,GAA3B,CAAgCgS,eAAhC,CAAiD,CAAEmC,eAAe,GAAjB,CAAjD,CAJqC,CAKpD,GAAI,CAACxC,MAAL,CACE,KAAM,IAAIhS,MAAJ,CAAW,mBAAkBqS,eAAgB,SAA7C,CAAN,CAGF,GAAIL,MAAM,CAACyC,KAAP,EAAwC,CAAxB,GAAAzC,MAAM,CAACyC,KAAP,CAAa9N,MAAjC,CACE;AACA,MAAO,MAAKwL,kBAAL,CAAwBmC,OAAxB,CAAiCjC,eAAjC,CAAkDJ,MAAlD,CAAP,CAFF,IAGO,CACL;AACA;AACA;AACA,KAAMU,kBAAiB,CAAG,GAAA+B,0BAAA,EAAsBrU,GAAG,CAACmI,GAA1B,CAA+B6J,eAA/B,CAA1B,CACA,GAAI,CAACM,iBAAL,CACE,KAAM,IAAI3S,MAAJ,CAAW,UAASgS,MAAO,uBAA3B,CAAN,CANG,KASC2C,WAAU,CAAGhC,iBAAiB,CAACiC,MAAlB,CAAyBrQ,GAAzB,CAA8BsQ,KAAD,EAAWA,KAAK,CAAClM,IAA9C,CATd,CAUCmM,QAAQ,CAAGH,UAAU,CAACI,OAAX,CAAmB,MAAnB,CAVZ,CAWCC,SAAS,CAAGL,UAAU,CAACI,OAAX,CAAmB,OAAnB,CAXb,CAaL,GAAiB,CAAC,CAAd,GAAAD,QAAQ,EAAyB,CAAC,CAAf,GAAAE,SAAvB,CACE,KAAM,IAAIhV,MAAJ,CAAW,UAASqS,eAAgB,4EAApC,CAAN,CAGF,KAAMhO,QAAO,CAAG,KAAM,MAAK+P,oBAAL,CAA0BnC,MAAM,CAAC6C,QAAD,CAAhC,CAA4C7C,MAAM,CAAC+C,SAAD,CAAlD,CAAtB,CAEA,MAAO,MAAK7C,kBAAL,CAAwBmC,OAAxB,CAAiCjC,eAAjC,CAAkDJ,MAAlD,CAA0D5N,OAA1D,CACR,CACF,CAED;AACF;AACA;AACA;AACA;AACA,KACE4Q,qBAAqB,CAAEC,MAAF,CAAU,CAC7B;AACA;AACA,GAAI,CAAC,GAAAC,wBAAA,EAAaD,MAAb,CAAL,CACE,KAAM,IAAIlV,MAAJ,CAAW,gCAA+BkV,MAAO,EAAjD,CAAN,CAGF,KAAMpG,KAAI,CAAG,GAAAsG,4BAAA,EAAiBF,MAAjB,CAAb,CACA,MAAOpG,KAAI,CAACvK,GAAL,CAAU8Q,OAAD,EAAa,CAC3B,KAAM,CAAEC,IAAF,EAAWD,OAAjB,CAEA,GAAI,GAAAE,8BAAA,EAAmBD,IAAnB,CAAJ,CAA8B,CAC5B,KAAME,mBAAkB,CAAG,GAAAC,4BAAA,EAAiBH,IAAjB,CAA3B,CAEA,GAAI,CACFD,OAAO,CAACK,QAAR,CAAmB,KAAKT,qBAAL,CAA2BO,kBAA3B,CACpB,CAAC,MAAO3L,GAAP,CAAY,CAAE,CACjB,CAED,MAAOwL,QACR,CAZM,CAaR,CAED;AACF;AACA;AACA;AACA;AACA,KAC+B,KAAvB5C,wBAAuB,CAAE3D,IAAF,CAAQ,CACnC,MAAOhJ,QAAO,CAACC,GAAR,CAAY+I,IAAI,CAACvK,GAAL,CAAS,KAAOoR,KAAP,EAAgB,CAC1C,GAAIC,cAAJ,CAEA,GAAIxR,KAAK,CAACmE,OAAN,CAAcoN,IAAd,CAAJ,CAAyB,CACvB;AACA;AACA,GAAI,CACFC,aAAa,CAAG,KAAM,GAAAC,+CAAA,EAAuCF,IAAvC,CAA6C,IAA7C,CACvB,CAAC,MAAO9L,GAAP,CAAY,CAAG,CAEjB;AACA,MAAO+L,cAAa,EAAI,KAAKnD,uBAAL,CAA6BkD,IAA7B,CACzB,CAED;AACA;AACA,GAAI,CACFC,aAAa,CAAG,KAAM,GAAAE,qCAAA,EAA6BH,IAA7B,CAAmC,IAAnC,CACvB,CAAC,MAAO9L,GAAP,CAAY,CAAG,CAEjB;AACA,GAAI,CAAC+L,aAAL,CACE,GAAI,CACFA,aAAa,CAAG,KAAM,GAAAG,6BAAA,EAAqBJ,IAArB,CAA2B,IAA3B,CACvB,CAAC,MAAO9L,GAAP,CAAY,CAAG,CAGnB;AACA,GAAI+L,aAAJ,CAAmB,CACjB,GAAIA,aAAa,CAACI,WAAlB,CACE,GAAI,CACF,KAAMC,UAAS,CAAG,KAAM,GAAAC,sCAAA,EAA8BN,aAAa,CAACI,WAA5C,CAAyD,IAAzD,CAAxB,CACAJ,aAAa,CAACI,WAAd,CAA4BC,SAAS,CAACD,WAFpC,CAGFJ,aAAa,CAACO,oBAAd,CAAqCF,SAAS,CAACE,oBAChD,CAAC,MAAOtM,GAAP,CAAY,CAAG,CAGf+L,aAAa,CAACF,QATD,GAUfE,aAAa,CAACF,QAAd,CAAyB,KAAM,MAAKjD,uBAAL,CAA6BmD,aAAa,CAACF,QAA3C,CAVhB,CAYlB,CAED,MAAOE,cAAa,EAAID,IACzB,CA3CkB,CAAZ,CA4CR,CAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA,KACES,UAAU,CAAEC,SAAF,CAAa/C,MAAb,CAAqB4B,MAArB,CAA6B,CACrC,KAAMkB,WAAU,CAAG,GAAI,MAAKhZ,IAAL,CAAUkE,GAAV,CAAcgV,QAAlB,CACjB,GAAAC,kBAAA,EAAO,kBAAP,CADiB,CAEjBF,SAFiB,EAGjBG,OAHiB,WAAnB,CAKA,MAAOJ,WAAU,CAAC9C,MAAD,CAAS4B,MAAT,CAAV,CAA2BpV,IAA3B,GAAkCsG,KAAlC,CAAwC,MAAxC,CACR,CAEDqQ,kBAAkB,CAAEC,QAAF,CAAY,CAC5B,MAAO,MAAK/Y,iBAAL,CAAuB+Y,QAAvB,CACR,CAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAC2B,KAAnBhD,oBAAmB,CAAE5B,WAAF,CAAqC,IAAtB6E,aAAsB,6DAC5D;AACA;AACA;AACA,GAAI7E,WAAW,CAAC8E,cAAhB,CAGE;AACA,MAFA9E,YAAW,CAAC8E,cAAZ,CAA6B,KAAM,MAAKlD,mBAAL,CAAyB5B,WAAW,CAAC8E,cAArC,IAEnC,CAAO9E,WAAP,CAGF;AACA;AACA;AACA;AACA;AAf4D,KAgBtD+E,kBAAiB,CAAG,KAAM,MAAKzZ,IAAL,CAAUkE,GAAV,CAAcwV,WAAd,gCAA+BhF,WAA/B,MAA4CiF,GAAG,OAA/C,GAhB4B,CAiBtDC,mBAAmB,CAAG,KAAM,GAAAC,oCAAA,EAAuB,KAAK7Z,IAA5B,CAAkCyZ,iBAAlC,CAjB0B,CA6B5D,OARI,CAAC/E,WAAW,CAACiF,GAAb,EAAqBJ,YAAY,EAAI7E,WAAW,CAACiF,GAAZ,CAAkBC,mBAQ3D,IAPElF,WAAW,CAACiF,GAAZ,CAAkBC,mBAOpB,EAJKlF,WAAW,CAACoF,QAIjB,GAHEpF,WAAW,CAACoF,QAAZ,CAAuB,KAAM,MAAKT,kBAAL,CAAwB3E,WAAW,CAACiF,GAApC,CAG/B,EAAOjF,WACR,CAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KACgC,KAAxBU,yBAAwB,CAAEc,MAAF,CAAUlB,WAAV,CAAuBC,eAAvB,CAAwCJ,MAAxC,CAAgDK,cAAhD,CAAgE,CAC5F;AACA,KAAM9O,IAAG,CAAG,KAAM,MAAKuL,MAAL,CAAYqD,WAAZ,CAAlB,CACA,GAAI,CAAC5O,GAAL,CACE,KAAM,IAAIxD,MAAJ,CAAW,iCAAgCoS,WAAY,2BAAvD,CAAN,CAGF,KAAMJ,OAAM,CAAG,GAAAuC,iCAAA,EAA2B/Q,GAA3B,CAAgC6O,eAAhC,CAAiD,CAAEmC,eAAe,GAAjB,CAAjD,CAAf,CACA,GAAI,CAACxC,MAAL,CACE,KAAM,IAAIhS,MAAJ,CAAW,mBAAkBqS,eAAgB,OAAMD,WAAY,EAA/D,CAAN,CAGF;AAZ4F,KAatF+E,kBAAiB,CAAG,KAAM,GAAA3D,2CAAA,EAA8BF,MAA9B,CAAsC9P,GAAtC,CAA2C6O,eAA3C,CAA4DJ,MAA5D,CAAoE,KAAK7U,IAAzE,CAb4D,CAetFga,sBAAsB,CAAG,GAAAC,oBAAA,EAAU/E,cAAV,CAf6D,CAiB5F;AACA;AACA;AACA,GAC2B,CAAxB,GAAAN,MAAM,CAACyC,KAAP,CAAa9N,MAAb,EAA6B,CAACyQ,sBAA/B,EACA,GAAAnS,qBAAA,EAAeqN,cAAf,CAA+BgB,MAA/B,CAFF,CAIE,GAAI,CACF;AACA,MAAO,CAAC,KAAM,MAAKI,mBAAL,CAAyByD,iBAAzB,CAAP,CACR,CAAC,MAAOpX,CAAP,CAAU,CACV;AACA;AACA,MAAO,EACR,CAGH;AACA,KAAM0M,WAAU,CAAG,KAAM,MAAKA,UAAL,CAAgB5J,IAAhB,CAAqB,GAAAwM,gBAAA,GAArB,EAA8BC,SAA9B,GAA0CtJ,IAA1C,CACtByG,UAAD,EAAgBA,UAAU,CAAClI,GAAX,CACb8R,SAAD,EAAeA,SAAS,CAACxQ,YADX,CADO,CAAzB,CAMA,GAAIyR,yBAAJ,CACA,GAAIF,sBAAJ,CAA4B,CAC1B,GAAI,CAAC,GAAAG,sBAAA,EAAgB9K,UAAhB,CAA4B6F,cAA5B,CAAL,CACE;AACA;AACA,MAAO,EAAP,CAGF;AACA;AACAgF,wBAAwB,CAAG,CAAChF,cAAD,CAC5B,CAVD,IAUO,CACL;AADK,KAEClQ,YAAW,CAAG,KAAM,MAAKA,WAAL,CAAiBS,IAAjB,CAAsB,GAAAwM,gBAAA,GAAtB,EAA+BC,SAA/B,EAFrB,CAGCkI,sBAAsB,CAAGpV,WAAW,CAACgQ,WAAD,CAHrC,CAICqF,OAAO,CAAGjU,GAAG,CAACiR,KAAJ,CAAU1I,IAAV,CACbpI,IAAD,EAAUA,IAAI,CAAC6K,EAAL,GAAYwD,MAAM,CAACyC,KAAP,CAAa,CAAb,CADR,EAEdiD,KANG,CAOCC,eAAe,CAAG7T,gBAAA,CAAQ3B,GAAR,CACtBqV,sBADsB,CAErB,GAAEC,OAAQ,kBAFW,CAGtB,EAHsB,CAPnB,CAaL;AACA,GAA+B,CAA3B,GAAAE,eAAe,CAAChR,MAApB,CACE,MAAO,EAAP,CAGF;AACA,GACE,GAAA4Q,sBAAA,EAAgBI,eAAhB,CAAiCrE,MAAjC,GACA,GAAAiE,sBAAA,EAAgBI,eAAhB,CAAiCC,iBAAjC,CAFF,CAIE,GAAI,CACF;AACA,MAAO,CAAC,KAAM,MAAKlE,mBAAL,CAAyByD,iBAAzB,CAAP,CACR,CAAC,MAAOpX,CAAP,CAAU,CACV;AACA;AACA;AACD,CAGH;AACAuX,wBAAwB,CAAG7K,UAAU,CAAC3F,MAAX,CACxBuP,SAAD,EAAe,GAAAkB,sBAAA,EAAgBI,eAAhB,CAAiCtB,SAAjC,CADU,CAG5B,CAED,MAAO,MAAKwB,uBAAL,CAA6BvE,MAA7B,CAAqClB,WAArC,CAAkD+E,iBAAlD,CAAqEG,wBAArE,CACR,CAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAC+B,KAAvBO,wBAAuB,CAAEvE,MAAF,CAAUlB,WAAV,CAAuB+E,iBAAvB,CAA0CG,wBAA1C,CAAoE,CAC/F;AACA,GAAwC,CAApC,GAAAA,wBAAwB,CAAC3Q,MAA7B,CACE,MAAO,EAAP,CAGF;AACA;AACA;AACA,MAAOwQ,kBAAiB,CAACP,cATsE,CAW/F,KAAMjD,2BAA0B,CAAG,GAAAC,+CAAA,EAAkCN,MAAlC,CAA0C6D,iBAA1C,CAA6D,KAAK/Z,IAAlE,CAAnC,CAEA;AACA;AACA,IAAK,KAAMiZ,UAAX,GAAwBiB,yBAAxB,CAAkD,CAChD,KAAMpC,OAAM,CAAG,GAAAf,4BAAA,EAAiB,CAACgD,iBAAD,CAAjB,CAAf,CACA,GAAI,KAAM,MAAKf,UAAL,CAAgBC,SAAhB,CAA2B/C,MAA3B,CAAmC4B,MAAnC,CAAV,CAAsD,CACpD,KAAMpD,YAAW,CAAG6B,0BAA0B,CAAC0C,SAAD,CAAYnB,MAAZ,CAA9C,CACA,GAAI,CACF,KAAM4C,mBAAkB,CAAG,KAAM,GAAAC,8CAAA,EAAiCjG,WAAjC,CAA8C,KAAK1U,IAAnD,CAAjC,CACA;AACA;AACA;AACA,MAAO,CAAC,KAAM,MAAKsW,mBAAL,CAAyBoE,kBAAzB,IAAP,CAA2DX,iBAA3D,CACR,CAAC,MAAOtN,GAAP,CAAY,CACZ,MAAO,EACR,CACF,CACF,CAED;AA/B+F,KAgCzF4C,WAAU,CAAG,KAAM,MAAKA,UAAL,CAAgB5J,IAAhB,CAAqB,GAAAwM,gBAAA,GAArB,EAA8BC,SAA9B,GAA0CtJ,IAA1C,CACtByG,UAAD,EAAgBA,UAAU,CACvBlI,GADa,CACR8R,SAAD,EAAeA,SAAS,CAACxQ,YADhB,EAEbiB,MAFa,CAELuP,SAAD,EAAe,CAAC,GAAAkB,sBAAA,EAAgBD,wBAAhB,CAA0CjB,SAA1C,CAFV,CADO,CAhCsE,CA2CzF2B,KAAK,CAAGV,wBAAwB,CAAC/S,GAAzB,CAA8B0T,uBAAD,EAClC,CACL,CACEtE,0BAA0B,CAACsE,uBAAD,CAA0B,GAAA9D,4BAAA,EAAiB,CAACgD,iBAAD,CAAjB,CAA1B,CAD5B,CAEEA,iBAFF,CADK,CAIF1K,UAJE,CADK,CA3CiF,CAsC/F;AACA;AACA;AACA;AACA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAG,CACD,KAAM,CAACqC,IAAD,CAAO,CAACuH,SAAD,CAAY,GAAG6B,SAAf,CAAP,EAAoCF,KAAK,CAACG,KAAN,EAA1C,CAEA;AACA,GAAI,CAAC9B,SAAD,EAA4B,CAAd,CAAAvH,IAAI,CAACnI,MAAvB,CAAmC,SAEnC;AANC,KAOKyR,kBAAiB,CAAGtJ,IAAI,CAAC,CAAD,CAAJ,CAAQiF,EAPjC,CAUKmB,MAAM,CAAG,GAAAf,4BAAA,EAAiB,CAACrF,IAAI,CAAC,CAAD,CAAL,CAAjB,CAVd,CASD;AAGA,GAAI,KAAM,MAAKsH,UAAL,CAAgBgC,iBAAhB,CAAmC/B,SAAnC,CAA8CnB,MAA9C,CAAV,CACE,GAAI,KAAM,MAAKkB,UAAL,CAAgBC,SAAhB,CAA2B/C,MAA3B,CAAmC4B,MAAnC,CAAV,CAAsD,CACpD;AACA;AACA,KAAMpD,YAAW,CAAG6B,0BAA0B,CAAC0C,SAAD,CAAYnB,MAAZ,CAA9C,CAEA;AACA;AACA,GAAI,CACF,KAAM4C,mBAAkB,CAAG,KAAM,GAAAC,8CAAA,EAAiCjG,WAAjC,CAA8C,KAAK1U,IAAnD,CAAjC,CACA;AACA;AACA;AACA,MAAO,CAAC,KAAM,MAAKsW,mBAAL,CAAyBoE,kBAAzB,IAAP,CAA2D,GAAGhJ,IAA9D,CACR,CAAC,MAAOjF,GAAP,CAAY,CACZ,MAAO,EACR,CACF,CAhBD,IAiBE;AACA;AACA;AACAmO,KAAK,CAACxO,IAAN,CAAW,CACT,CAACmK,0BAA0B,CAAC0C,SAAD,CAAYnB,MAAZ,CAA3B,CAAgD,GAAGpG,IAAnD,CADS,CAET;AACA;AACA;AACArC,UAAU,CAAC3F,MAAX,CAAmBkN,aAAD,EAAmBA,aAAa,GAAKqC,SAAvD,CALS,CAAX,CApBF,CA8BF;AACA;AACA2B,KAAK,CAACxO,IAAN,CAAW,CAACsF,IAAD,CAAOoJ,SAAP,CAAX,CACD,CA9CD,MA8CSF,KAAK,CAACrR,MA9Cf,EAgDA,MAAO,EACR,CA9vDyB,CAiwD5B"}