"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var _rxjs=require("rxjs"),_operators=require("rxjs/operators"),_configuration=require("../../configuration"),configurationKeys=_interopRequireWildcard(require("../../configuration/keys")),_events=require("../../utils/events");function _getRequireWildcardCache(nodeInterop){if("function"!=typeof WeakMap)return null;var cacheBabelInterop=new WeakMap,cacheNodeInterop=new WeakMap;return(_getRequireWildcardCache=function(nodeInterop){return nodeInterop?cacheNodeInterop:cacheBabelInterop})(nodeInterop)}function _interopRequireWildcard(obj,nodeInterop){if(!nodeInterop&&obj&&obj.__esModule)return obj;if(null===obj||"object"!=typeof obj&&"function"!=typeof obj)return{default:obj};var cache=_getRequireWildcardCache(nodeInterop);if(cache&&cache.has(obj))return cache.get(obj);var newObj={},hasPropertyDescriptor=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var key in obj)if("default"!=key&&Object.prototype.hasOwnProperty.call(obj,key)){var desc=hasPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):null;desc&&(desc.get||desc.set)?Object.defineProperty(newObj,key,desc):newObj[key]=obj[key]}return newObj.default=obj,cache&&cache.set(obj,newObj),newObj}class ContractProxy{constructor(address,jsonInterface,web3){let{initializationBlock=0}=3<arguments.length&&arguments[3]!==void 0?arguments[3]:{};this.address=address,this.contract=new web3.eth.Contract(jsonInterface,address),this.web3=web3,this.initializationBlock=initializationBlock}/**
   * Fetches past events for a given block range
   *
   * @param {Array<String>} eventNames events to fetch
   * @param {Object} [options] web3.eth.Contract.getPastEvents()' options
   *   The fromBlock is defaulted to this app's initializationBlock unless explicitly provided
   * @return {Observable} Single-emission observable with an array of past events
   */pastEvents(eventNames){let options=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};// The `from`s only unpack the returned Promises (and not the array inside them!)
return(options.fromBlock=options.fromBlock||this.initializationBlock,eventNames=(0,_events.getEventNames)(eventNames),1===eventNames.length)?(0,_configuration.getConfiguration)(configurationKeys.PAST_EVENTS_BLOCK_SIZE)?(options.blockSizeLimit=(0,_configuration.getConfiguration)(configurationKeys.PAST_EVENTS_BLOCK_SIZE),(0,_rxjs.from)((0,_events.getPastEventsByBatch)({options,contract:this.contract,eventName:eventNames[0]}))):(0,_rxjs.from)(this.contract.getPastEvents(eventNames[0],options)):(0,_rxjs.from)(this.contract.getPastEvents("allEvents",options).then(events=>events.filter(event=>eventNames.includes(event.event))))}/**
   * Subscribe to events, fetching past events if necessary (based on the given options)
   *
   * @param {Array<String>} eventNames events to fetch
   * @param {Object} options web3.eth.Contract.events()' options
   *   The fromBlock is defaulted to this app's initializationBlock unless explicitly provided
   * @return {Observable} Multi-emission observable with individual events
   */events(eventNames){let options=1<arguments.length&&arguments[1]!==void 0?arguments[1]:{};options.fromBlock=options.fromBlock||this.initializationBlock,eventNames=(0,_events.getEventNames)(eventNames);let eventSource=1===eventNames.length?(0,_rxjs.fromEvent)(this.contract.events[eventNames[0]](options),"data"):(0,_rxjs.fromEvent)(this.contract.events.allEvents(options),"data").pipe((0,_operators.filter)(event=>eventNames.includes(event.event)));const eventDelay=(0,_configuration.getConfiguration)(configurationKeys.SUBSCRIPTION_EVENT_DELAY)||0;// Small optimization: don't pipe a delay if we don't have to
return eventDelay?eventSource.pipe((0,_operators.delay)(eventDelay)):eventSource}async call(method){if(!this.contract.methods[method])throw new Error(`No method named ${method} on ${this.address}`);for(var _len=arguments.length,params=Array(1<_len?_len-1:0),_key=1;_key<_len;_key++)params[_key-1]=arguments[_key];const lastParam=params[params.length-1];return"object"==typeof lastParam&&null!==lastParam?this.contract.methods[method](...params.slice(0,-1)).call(lastParam):this.contract.methods[method](...params).call()}async updateInitializationBlock(){const initBlock=await this.contract.methods.getInitializationBlock().call();this.initializationBlock=initBlock}}exports.default=ContractProxy;
//# sourceMappingURL=index.js.map