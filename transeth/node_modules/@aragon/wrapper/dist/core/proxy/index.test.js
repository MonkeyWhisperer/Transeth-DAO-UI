"use strict";var _interopRequireWildcard=require("@babel/runtime/helpers/interopRequireWildcard"),_interopRequireDefault=require("@babel/runtime/helpers/interopRequireDefault"),_ava=_interopRequireDefault(require("ava")),_proxyquire=_interopRequireDefault(require("proxyquire")),_sinon=_interopRequireDefault(require("sinon")),_events=require("events"),configurationKeys=_interopRequireWildcard(require("../../configuration/keys")),eventsUtils=_interopRequireWildcard(require("../../utils/events"));_ava.default.beforeEach(t=>{const configurationStub={getConfiguration:_sinon.default.stub()},utilsStub={events:eventsUtils},ContractProxy=(0,_proxyquire.default)("./index",{"../../configuration":configurationStub,"../../utils":utilsStub}).default;t.context={ContractProxy,configurationStub,utilsStub}}),_ava.default.afterEach.always(()=>{_sinon.default.restore()}),(0,_ava.default)("should get all the events",t=>{const{ContractProxy}=t.context;t.plan(1);// arrange
const eventEmitter=new _events.EventEmitter,web3Stub={eth:{Contract:_sinon.default.stub().returns({events:{allEvents:()=>eventEmitter}})}},instance=new ContractProxy(null,null,web3Stub),events=instance.events();// assert
events.subscribe(event=>{t.deepEqual(event,{foo:"bar"})}),eventEmitter.emit("data",{foo:"bar"})}),(0,_ava.default)("should get only the requested events",t=>{const{ContractProxy}=t.context;t.plan(2);// arrange
const eventEmitter=new _events.EventEmitter,web3Stub={eth:{Contract:_sinon.default.stub().returns({events:{allEvents:()=>eventEmitter}})}},instance=new ContractProxy(null,null,web3Stub),events=instance.events(["PayFee","PayService"]);// assert
events.subscribe(event=>{t.deepEqual(event.amount,5)}),eventEmitter.emit("data",{event:"PayFee",amount:5}),eventEmitter.emit("data",{event:"PaySomethingElse",amount:10}),eventEmitter.emit("data",{event:"PayService",amount:5})}),(0,_ava.default)("should get only request the single event",t=>{const{ContractProxy}=t.context;t.plan(4);// arrange
const allEventEmitter=new _events.EventEmitter,payFeeEventEmitter=new _events.EventEmitter,allEventsStub=_sinon.default.stub().returns(allEventEmitter),payFeeEventStub=_sinon.default.stub().returns(payFeeEventEmitter),web3Stub={eth:{Contract:_sinon.default.stub().returns({events:{allEvents:allEventsStub,PayFee:payFeeEventStub}})}},instance=new ContractProxy(null,null,web3Stub),events=instance.events("PayFee");t.true(payFeeEventStub.calledOnce),t.true(allEventsStub.notCalled);let eventCount=0;// Emit on both specific and all event emitters
events.subscribe(event=>{0===eventCount?t.deepEqual(event.amount,5):1===eventCount?t.deepEqual(event.amount,10):t.fail(),++eventCount}),allEventEmitter.emit("data",{event:"PaySomethingElse",amount:10}),allEventEmitter.emit("data",{event:"PayFee",amount:5}),payFeeEventEmitter.emit("data",{event:"PayFee",amount:5}),allEventEmitter.emit("data",{event:"PayFee",amount:10}),payFeeEventEmitter.emit("data",{event:"PayFee",amount:10}),allEventEmitter.emit("data",{event:"PayService",amount:5})}),(0,_ava.default)("should default the fromBlock to initializationBlock for requested events",t=>{const{ContractProxy}=t.context;t.plan(2);// arrange
const eventEmitter=new _events.EventEmitter,allEventsStub=_sinon.default.stub().returns(eventEmitter),web3Stub={eth:{Contract:_sinon.default.stub().returns({events:{allEvents:allEventsStub}})}},instance=new ContractProxy(null,null,web3Stub,{initializationBlock:5}),events=instance.events();// assert
t.true(allEventsStub.calledOnceWith({fromBlock:5})),events.subscribe(event=>{t.deepEqual(event,{foo:"bar"})}),eventEmitter.emit("data",{foo:"bar"})}),(0,_ava.default)("should use the correct options for requested events",t=>{const{ContractProxy}=t.context;t.plan(2);// arrange
const eventEmitter=new _events.EventEmitter,allEventsStub=_sinon.default.stub().returns(eventEmitter),web3Stub={eth:{Contract:_sinon.default.stub().returns({events:{allEvents:allEventsStub}})}},instance=new ContractProxy(null,null,web3Stub),events=instance.events(null,{fromBlock:10});// assert
t.true(allEventsStub.calledOnceWith({fromBlock:10})),events.subscribe(event=>{t.deepEqual(event,{foo:"bar"})}),eventEmitter.emit("data",{foo:"bar"})}),(0,_ava.default)("should not apply a delay to events if not configured",t=>{const{ContractProxy,configurationStub}=t.context;t.plan(2);// arrange
const eventEmitter=new _events.EventEmitter,web3Stub={eth:{Contract:_sinon.default.stub().returns({events:{allEvents:()=>eventEmitter}})}};configurationStub.getConfiguration.withArgs(configurationKeys.SUBSCRIPTION_EVENT_DELAY).returns(0);const instance=new ContractProxy(null,null,web3Stub),events=instance.events(),startTime=Date.now();// act
events.subscribe(event=>{// Hard to say exactly how much time this will take, but 20ms seems safe
// (this should be immediate)
t.deepEqual(event,{foo:"bar"}),t.true(20>Date.now()-startTime)}),eventEmitter.emit("data",{foo:"bar"})}),(0,_ava.default)("should apply a delay to events if configured",t=>{const{ContractProxy,configurationStub}=t.context,delayTime=1e3;t.plan(2);// arrange
const eventEmitter=new _events.EventEmitter,web3Stub={eth:{Contract:_sinon.default.stub().returns({events:{allEvents:()=>eventEmitter}})}};configurationStub.getConfiguration.withArgs(configurationKeys.SUBSCRIPTION_EVENT_DELAY).returns(delayTime);const instance=new ContractProxy(null,null,web3Stub),events=instance.events();// act
// assert
// Since we've added the delay, we need to tell ava to wait until we're done subscribing
return new Promise(resolve=>{const startTime=Date.now();events.subscribe(event=>{t.deepEqual(event,{foo:"bar"}),t.true(Date.now()-startTime>delayTime),resolve()}),eventEmitter.emit("data",{foo:"bar"})})}),(0,_ava.default)("should use the correct options for requested past events with fromBlock and toBlock ",t=>{const{ContractProxy}=t.context;t.plan(4);// arrange
const toBlock=15,pastEventsStub=_sinon.default.stub().resolves([{one:1},{two:2}]),web3Stub={eth:{Contract:_sinon.default.stub().returns({getPastEvents:pastEventsStub})}},instance=new ContractProxy(null,null,web3Stub),events=instance.pastEvents(null,{fromBlock:10,toBlock});return t.true(pastEventsStub.calledWithExactly("allEvents",{fromBlock:10,toBlock})),events.subscribe(events=>{t.is(events.length,2),t.deepEqual(events[0],{one:1}),t.deepEqual(events[1],{two:2})}),events;// return observable for ava to wait for its completion
}),(0,_ava.default)("should use the correct options for requested past events with toBlock and initializationBlock set ",t=>{const{ContractProxy}=t.context;t.plan(1);// arrange
const initializationBlock=20,pastEventsStub=_sinon.default.stub().resolves([{one:1},{two:2}]),web3Stub={eth:{Contract:_sinon.default.stub().returns({getPastEvents:pastEventsStub})}},instance=new ContractProxy(null,null,web3Stub,{initializationBlock});// act
// assert
instance.pastEvents(null,{toBlock:500}),t.true(pastEventsStub.calledWithExactly("allEvents",{fromBlock:initializationBlock,toBlock:500}))}),(0,_ava.default)("should filter past events correctly when more than one eventName is passed",t=>{const{ContractProxy}=t.context;t.plan(4);// arrange
const pastEventsStub=_sinon.default.stub().resolves([{event:"Orange",amount:16},{event:"Apple",amount:10},{event:"Pear",amount:5}]),web3Stub={eth:{Contract:_sinon.default.stub().returns({getPastEvents:pastEventsStub})}},instance=new ContractProxy(null,null,web3Stub),events=instance.pastEvents(["Orange","Pear"]);return t.true(pastEventsStub.calledWith("allEvents")),events.subscribe(events=>{t.is(events.length,2),t.deepEqual(events[0],{event:"Orange",amount:16}),t.deepEqual(events[1],{event:"Pear",amount:5})}),events;// return observable for ava to wait for its completion
});
//# sourceMappingURL=index.test.js.map