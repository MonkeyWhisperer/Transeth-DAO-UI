"use strict";var _interopRequireDefault=require("@babel/runtime/helpers/interopRequireDefault");Object.defineProperty(exports,"__esModule",{value:!0}),exports.makeRepoProxy=makeRepoProxy,exports.getAllRepoVersions=getAllRepoVersions,exports.getRepoLatestVersion=getRepoLatestVersion,exports.getRepoLatestVersionForContract=getRepoLatestVersionForContract,exports.getRepoVersionById=getRepoVersionById,exports.fetchRepoContentURI=fetchRepoContentURI;var _defineProperty2=_interopRequireDefault(require("@babel/runtime/helpers/defineProperty")),_web3Utils=require("web3-utils"),_interfaces=require("../../interfaces"),_utils=require("../../utils");function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);enumerableOnly&&(symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable})),keys.push.apply(keys,symbols)}return keys}function _objectSpread(target){for(var source,i=1;i<arguments.length;i++)source=null==arguments[i]?{}:arguments[i],i%2?ownKeys(Object(source),!0).forEach(function(key){(0,_defineProperty2.default)(target,key,source[key])}):Object.getOwnPropertyDescriptors?Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)):ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key))});return target}function makeRepoProxy(address,web3,options){return(0,_utils.makeProxyFromABI)(address,(0,_interfaces.getAbi)("apm/Repo"),web3,options)}async function getAllRepoVersions(repoProxy){const versions=[],versionCount=await repoProxy.call("getVersionsCount");// Versions index starts at 1
for(let versionId=1;versionId<=versionCount;++versionId)versions.push(await getRepoVersionById(repoProxy,versionId));return Promise.all(versions)}async function getRepoLatestVersion(repoProxy){const{contentURI,contractAddress,semanticVersion}=await repoProxy.call("getLatest");return{contractAddress,contentURI:(0,_web3Utils.hexToAscii)(contentURI),version:semanticVersion.join(".")}}async function getRepoLatestVersionForContract(repoProxy,appContractAddress){const{contentURI,contractAddress,semanticVersion}=await repoProxy.call("getLatestForContractAddress",appContractAddress);return{contractAddress,contentURI:(0,_web3Utils.hexToAscii)(contentURI),version:semanticVersion.join(".")}}async function getRepoVersionById(repoProxy,versionId){const{contentURI,contractAddress,semanticVersion}=await repoProxy.call("getByVersionId",versionId);return{contractAddress,contentURI:(0,_web3Utils.hexToAscii)(contentURI),version:semanticVersion.join("."),// Keeping this as a string makes comparisons a bit easier down the line
versionId:versionId.toString()}}async function fetchRepoContentURI(fileFetcher,contentURI,{fetchTimeout}={}){const[provider,location]=contentURI.split(/:(.+)/);if(!provider||!location)throw new Error(`contentURI invalid: ${contentURI}`);else if(!fileFetcher.supportsProvider(provider))throw new Error(`Provider not supported: ${provider}`);let files;try{const timeout=Number.isFinite(fetchTimeout)?fetchTimeout:0,filesFetch=Promise.all([fileFetcher.fetch(provider,location,"manifest.json",{timeout}),fileFetcher.fetch(provider,location,"artifact.json",{timeout})]);files=(await filesFetch).map(JSON.parse)}catch(err){// Fetch failed or timed out
return err instanceof SyntaxError&&console.warn(`Fetch failed: ${contentURI} was not JSON-parsable`,err),{content:{provider,location}}}const[manifest,artifact]=files;return _objectSpread(_objectSpread(_objectSpread({},manifest),artifact),{},{content:{provider,location}})}
//# sourceMappingURL=repo.js.map