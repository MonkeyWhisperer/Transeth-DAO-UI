{"version":3,"sources":["../../../src/core/apm/repo.js"],"names":["makeRepoProxy","address","web3","options","getAllRepoVersions","repoProxy","versions","versionCount","call","versionId","push","getRepoVersionById","Promise","all","getRepoLatestVersion","contentURI","contractAddress","semanticVersion","version","join","getRepoLatestVersionForContract","appContractAddress","toString","fetchRepoContentURI","fileFetcher","fetchTimeout","provider","location","split","Error","supportsProvider","files","timeout","Number","isFinite","filesFetch","fetch","map","JSON","parse","err","SyntaxError","console","warn","content","manifest","artifact"],"mappings":"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","sourcesContent":["import { hexToAscii } from 'web3-utils'\nimport { getAbi } from '../../interfaces'\nimport { makeProxyFromABI } from '../../utils'\n\nexport function makeRepoProxy (address, web3, options) {\n  return makeProxyFromABI(address, getAbi('apm/Repo'), web3, options)\n}\n\nexport async function getAllRepoVersions (repoProxy) {\n  const versions = []\n  const versionCount = await repoProxy.call('getVersionsCount')\n\n  // Versions index starts at 1\n  for (let versionId = 1; versionId <= versionCount; ++versionId) {\n    versions.push(await getRepoVersionById(repoProxy, versionId))\n  }\n\n  return Promise.all(versions)\n}\n\nexport async function getRepoLatestVersion (repoProxy) {\n  const { contentURI, contractAddress, semanticVersion } = await repoProxy.call('getLatest')\n  return {\n    contractAddress,\n    contentURI: hexToAscii(contentURI),\n    version: semanticVersion.join('.')\n  }\n}\n\nexport async function getRepoLatestVersionForContract (repoProxy, appContractAddress) {\n  const {\n    contentURI,\n    contractAddress,\n    semanticVersion\n  } = await repoProxy.call('getLatestForContractAddress', appContractAddress)\n\n  return {\n    contractAddress,\n    contentURI: hexToAscii(contentURI),\n    version: semanticVersion.join('.')\n  }\n}\n\nexport async function getRepoVersionById (repoProxy, versionId) {\n  const { contentURI, contractAddress, semanticVersion } = await repoProxy.call('getByVersionId', versionId)\n  return {\n    contractAddress,\n    contentURI: hexToAscii(contentURI),\n    version: semanticVersion.join('.'),\n    // Keeping this as a string makes comparisons a bit easier down the line\n    versionId: versionId.toString()\n  }\n}\n\nexport async function fetchRepoContentURI (fileFetcher, contentURI, { fetchTimeout } = {}) {\n  const [provider, location] = contentURI.split(/:(.+)/)\n\n  if (!provider || !location) {\n    throw new Error(`contentURI invalid: ${contentURI}`)\n  } else if (!fileFetcher.supportsProvider(provider)) {\n    throw new Error(`Provider not supported: ${provider}`)\n  }\n\n  let files\n  try {\n    const timeout = Number.isFinite(fetchTimeout) ? fetchTimeout : 0\n    const filesFetch = Promise.all([\n      fileFetcher.fetch(provider, location, 'manifest.json', { timeout }),\n      fileFetcher.fetch(provider, location, 'artifact.json', { timeout })\n    ])\n    files = (await filesFetch).map(JSON.parse)\n  } catch (err) {\n    if (err instanceof SyntaxError) {\n      // JSON parse error\n      console.warn(`Fetch failed: ${contentURI} was not JSON-parsable`, err)\n    }\n\n    // Fetch failed or timed out\n    return {\n      content: { provider, location }\n    }\n  }\n\n  const [manifest, artifact] = files\n  return {\n    ...manifest,\n    ...artifact,\n    content: { provider, location }\n  }\n}\n"],"file":"repo.js"}