{"version":3,"file":"forwarding.js","names":["FORWARD_SIG","isValidForwardCall","calldata","replace","selector","substring","evmscriptData","length","parseForwardCall","offset","parseInt","startIndex","dataLength"],"sources":["../../src/utils/forwarding.js"],"sourcesContent":["export const FORWARD_SIG = '0xd948d468' // function forward(bytes)\n\n/**\n * Tells if the given calldata (as a bytes string) is a valid invocation of\n * `forward(bytes)`.\n *\n * It will return true only if the given calldata starts with the forward\n * function signature and follows with at least an empty bytes array properly\n * ABI encoded following the convention [offset][length][data].\n *\n * @param {string} calldata Calldata encoded as an array of bytes\n * @returns {boolean}\n */\nexport function isValidForwardCall (calldata) {\n  // Drop the 0x starting notation if there is one\n  calldata = calldata.replace(/^0x/, '')\n  // First 4 bytes represent the function selector\n  const selector = calldata.substring(0, 8)\n  // Drop selector and grab the argument data\n  const evmscriptData = calldata.substring(8)\n  // Since arrays of bytes are encoded following the [offset][length][data]\n  // format, we expect it to have at least two words length (empty data scenario)\n  return `0x${selector}` === FORWARD_SIG && evmscriptData.length >= 128\n}\n\n/**\n * Parse the evmscript of a forward call following the byte ABI encoding\n * convention [offset][length][data].\n *\n * @param {string} calldata Calldata encoded as an array of bytes\n * @returns {string} Array of bytes representing the forwarded evmscript\n */\nexport function parseForwardCall (calldata) {\n  // Drop the 0x starting notation if there is one\n  calldata = calldata.replace(/^0x/, '')\n  // Drop function selector and grab the argument data (of type bytes)\n  const evmscriptData = calldata.substring(8)\n  // Parse first word of the bytes array to get data offset\n  // (it's stored as bytes so we need to parse in hex first and then multiply by 2)\n  const offset = parseInt(`0x${evmscriptData.substring(0, 64)}`, 16) * 2\n  // The first word in the data is its length (uint256); actual data starts after\n  const startIndex = offset + 64\n  // Parse length of the data stored\n  // (it's stored as bytes so we need to parse in hex first and then multiply by 2)\n  const dataLength = parseInt(`0x${evmscriptData.substring(offset, startIndex)}`, 16) * 2\n  // Grab the data stored in the bytes array\n  return `0x${evmscriptData.substring(startIndex, startIndex + dataLength)}`\n}\n"],"mappings":"iEAqeuB;sHArehB,KAAMA,YAAW,CAAG,YAApB,CAAiC;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,G,iCACO,QAASC,mBAAT,CAA6BC,QAA7B,CAAuC,CAE5CA,QAAQ,CAAGA,QAAQ,CAACC,OAAT,CAAiB,KAAjB,CAAwB,EAAxB,CAFiC,CAG5C;AAH4C,KAItCC,SAAQ,CAAGF,QAAQ,CAACG,SAAT,CAAmB,CAAnB,CAAsB,CAAtB,CAJ2B,CAMtCC,aAAa,CAAGJ,QAAQ,CAACG,SAAT,CAAmB,CAAnB,CANsB,CAK5C;AAEA;AACA;AACA,MAAQ,KAAID,QAAS,EAAd,GAAoBJ,WAApB,EAA2D,GAAxB,EAAAM,aAAa,CAACC,MACzD,CAED;AACA;AACA;AACA;AACA;AACA;AACA,GACO,QAASC,iBAAT,CAA2BN,QAA3B,CAAqC,CAE1CA,QAAQ,CAAGA,QAAQ,CAACC,OAAT,CAAiB,KAAjB,CAAwB,EAAxB,CAF+B,CAG1C;AAH0C,KAIpCG,cAAa,CAAGJ,QAAQ,CAACG,SAAT,CAAmB,CAAnB,CAJoB,CAOpCI,MAAM,CAAyD,CAAtD,CAAAC,QAAQ,CAAE,KAAIJ,aAAa,CAACD,SAAd,CAAwB,CAAxB,CAA2B,EAA3B,CAA+B,EAArC,CAAwC,EAAxC,CAPmB,CASpCM,UAAU,CAAGF,MAAM,CAAG,EATc,CAYpCG,UAAU,CAAsE,CAAnE,CAAAF,QAAQ,CAAE,KAAIJ,aAAa,CAACD,SAAd,CAAwBI,MAAxB,CAAgCE,UAAhC,CAA4C,EAAlD,CAAqD,EAArD,CAZe,CAK1C;AACA;AAOA;AACA,MAAQ,KAAIL,aAAa,CAACD,SAAd,CAAwBM,UAAxB,CAAoCA,UAAU,CAAGC,UAAjD,CAA6D,EAC1E"}