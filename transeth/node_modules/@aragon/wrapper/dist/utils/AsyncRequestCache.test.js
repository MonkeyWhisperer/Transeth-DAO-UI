"use strict";var _interopRequireDefault=require("@babel/runtime/helpers/interopRequireDefault"),_ava=_interopRequireDefault(require("ava")),_sinon=_interopRequireDefault(require("sinon")),_AsyncRequestCache=_interopRequireDefault(require("./AsyncRequestCache"));const wait=time=>new Promise(resolve=>{setTimeout(resolve,time)});(0,_ava.default)("AsyncRequestCache should cache requests",async t=>{// arrange
const requestFn=_sinon.default.spy(async key=>(await wait(100),key)),cache=new _AsyncRequestCache.default(requestFn),request=cache.request("key"),result=await request,requestAgain=cache.request("key"),resultAgain=await requestAgain;// assert
t.is(request,requestAgain),t.is(result,resultAgain),t.true(cache.has("key")),t.true(requestFn.calledOnceWith("key"))}),(0,_ava.default)("AsyncRequestCache can cache more than one key",async t=>{// arrange
const secondKey="second",requestFn=_sinon.default.spy(async key=>(await wait(100),key)),cache=new _AsyncRequestCache.default(requestFn),requestFirst=cache.request("first"),requestSecond=cache.request(secondKey),resultFirst=await requestFirst,resultSecond=await requestSecond,resultFirstAgain=await cache.request("first"),resultSecondAgain=await cache.request(secondKey);// assert
t.true(cache.has("first")),t.true(cache.has(secondKey)),t.is(resultFirst,resultFirstAgain),t.is(resultSecond,resultSecondAgain),t.not(resultFirst,resultSecond),t.is(requestFn.callCount,2)}),(0,_ava.default)("AsyncRequestCache should be able to force invalidate requests",async t=>{// arrange
const requestFn=_sinon.default.spy(async key=>(await wait(100),key)),cache=new _AsyncRequestCache.default(requestFn),request=cache.request("key");await request;const requestInvalidate=cache.request("key",!0// force cache invalidation
);// assert
await requestInvalidate,t.not(request,requestInvalidate),t.true(cache.has("key")),t.is(requestFn.callCount,2)}),(0,_ava.default)("AsyncRequestCache does not cache result if unsuccessful",async t=>{// arrange
const requestFn=_sinon.default.spy(async()=>{throw await wait(100),new Error("error")}),cache=new _AsyncRequestCache.default(requestFn),requestFail=await t.throwsAsync(cache.request("key"));// assert
t.is(requestFail.message,"error"),t.false(cache.has("key"))}),(0,_ava.default)("AsyncRequestCache deduplicates in-flight requests",async t=>{// arrange
const requestFn=_sinon.default.spy(async key=>{if(await wait(100),1===requestFn.callCount)throw new Error("error");return key}),cache=new _AsyncRequestCache.default(requestFn),requestFail=cache.request("key"),requestFailAgain=cache.request("key"),resultFail=await t.throwsAsync(requestFail),resultFailAgain=await t.throwsAsync(requestFailAgain),requestSuccess=cache.request("key"),requestSuccessAgain=cache.request("key"),resultSuccess=await requestSuccess,resultSuccessAgain=await requestSuccessAgain;// assert
t.is(requestFail,requestFailAgain),t.is(resultFail,resultFailAgain),t.not(requestFail,requestSuccess),t.is(requestSuccess,requestSuccessAgain),t.is(resultSuccess,resultSuccessAgain),t.true(cache.has("key")),t.is(requestFn.callCount,2)}),(0,_ava.default)("AsyncRequestCache should work with non-async request functions",async t=>{// arrange
const requestFn=_sinon.default.spy(key=>key),cache=new _AsyncRequestCache.default(requestFn),request=cache.request("key"),result=await request,requestAgain=cache.request("key"),resultAgain=await requestAgain;// assert
t.is(request,requestAgain),t.is(result,resultAgain),t.true(cache.has("key")),t.true(requestFn.calledOnceWith("key"))});
//# sourceMappingURL=AsyncRequestCache.test.js.map