"use strict";var _interopRequireDefault=require("@babel/runtime/helpers/interopRequireDefault");var _defineProperty2=_interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));Object.defineProperty(exports,"__esModule",{value:!0// force cache invalidation
}),exports.default=void 0;function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);enumerableOnly&&(symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable})),keys.push.apply(keys,symbols)}return keys}function _objectSpread(target){for(var source,i=1;i<arguments.length;i++)source=null==arguments[i]?{}:arguments[i],i%2?ownKeys(Object(source),!0).forEach(function(key){(0,_defineProperty2.default)(target,key,source[key])}):Object.getOwnPropertyDescriptors?Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)):ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key))});return target}const axios=require("axios");function sanitizePath(path){// Disallow a path being declared for the root or navigating to sibling paths
return path.replace(/^[./]+/,"")}function sanitizeUrl(url){return url.startsWith("http://")||url.startsWith("https://")||(url=`http://${url}`),url.endsWith("/")||(url=`${url}/`),url}class FileFetcher{constructor({ipfsGateway=""}={}){this.providers=new Map([["http"]]),ipfsGateway&&this.providers.set("ipfs",{gateway:sanitizeUrl(ipfsGateway)})}getFullPath(provider,location,path){if(!this.supportsProvider(provider))throw new Error(`Provider not supported: ${provider}`);// When IPFS is the provider, the declared location is a CID
const baseLocation="ipfs"===provider?`${this.providers.get("ipfs").gateway}${location}`:location;return`${sanitizeUrl(baseLocation)}${sanitizePath(path)}`}async fetch(provider,location,path,config){const response=await axios(this.getFullPath(provider,location,path),_objectSpread(_objectSpread({},config),{},{responseType:"text",// This is needed to disable the default behavior of axios, which
// always tries to use JSON.parse() even if `responseType` is "text".
//
// See:
//   https://github.com/axios/axios/issues/907#issuecomment-322054564
//
// Although the comment states that 'undefined' should work, setting 'undefined' on
// axios@0.19.0 does not override the default, so we have to use null
transformResponse:null}));return response.data}supportsProvider(provider){return this.providers.has(provider)}}exports.default=FileFetcher;
//# sourceMappingURL=FileFetcher.js.map