"use strict";var _interopRequireDefault=require("@babel/runtime/helpers/interopRequireDefault"),_ava=_interopRequireDefault(require("ava")),_sinon=_interopRequireDefault(require("sinon")),_proxyquire=_interopRequireDefault(require("proxyquire")),_rxjs=require("rxjs");const jsonrpcStub={};class MPM{}const Messenger=(0,_proxyquire.default)("./index",{"./jsonrpc":{default:jsonrpcStub},"./providers/MessagePortMessage":{default:MPM}}).default;_ava.default.afterEach.always(()=>{_sinon.default.restore()}),(0,_ava.default)("should assign MessagePortMessage as default provider",t=>{// arrange
// act
const instance=new Messenger;// assert
t.true(instance.provider instanceof MPM)}),(0,_ava.default)("should return the messages from provider",t=>{// arrange
const messagesStub=_sinon.default.stub().returns(6),instance=new Messenger({messages:messagesStub}),bus=instance.bus();// assert
t.is(bus,6)}),(0,_ava.default)("should encode and send the response",t=>{// arrange
const payload={id:2,jsonrpc:"2.0"};jsonrpcStub.encodeResponse=_sinon.default.stub().returns(payload);const mockProvider={send:_sinon.default.spy()},instance=new Messenger(mockProvider),id=instance.sendResponse(200,"success");// assert
t.true(jsonrpcStub.encodeResponse.calledOnceWith(200,"success")),t.is(id,2),t.is(mockProvider.send.getCall(0).args[0],payload)}),(0,_ava.default)("should encode and send the request",t=>{// arrange
const payload={id:"uuuuidv4",jsonrpc:"2.0"};jsonrpcStub.encodeRequest=_sinon.default.stub().returns(payload);const mockProvider={send:_sinon.default.spy()},instance=new Messenger(mockProvider),id=instance.send("sendEth");// assert
t.true(jsonrpcStub.encodeRequest.calledOnceWith("sendEth",[])),t.is(id,"uuuuidv4"),t.true(mockProvider.send.calledOnceWith(payload))}),(0,_ava.default)("should filter the incoming messages to responses only",t=>{t.plan(2);// arrange
const busMock=new _rxjs.Subject,instance=new Messenger(null);// assert
// act
instance.bus=()=>busMock,jsonrpcStub.isValidResponse=_sinon.default.stub().returns(!0),instance.responses().subscribe(value=>{t.is(value,"response"),t.is(jsonrpcStub.isValidResponse.getCall(0).args[0],"response")}),busMock.next("response"),busMock.complete()}),(0,_ava.default)("should filter the incoming messages to requests only",t=>{t.plan(2);// arrange
const busMock=new _rxjs.Subject,instance=new Messenger(null);// assert
// act
instance.bus=()=>busMock,jsonrpcStub.isValidResponse=_sinon.default.stub().returns(!1),instance.requests().subscribe(value=>{t.is(value,"request"),t.is(jsonrpcStub.isValidResponse.getCall(0).args[0],"request")}),busMock.next("request"),busMock.complete()}),(0,_ava.default)("should send and observe responses",t=>{t.plan(3);// arrange
const responsesMock=new _rxjs.Subject,instance=new Messenger(null);_sinon.default.stub(instance,"send").returns(41),_sinon.default.stub(instance,"responses").returns(responsesMock);const messages=instance.sendAndObserveResponses("sendEth",["params"]);// assert
// act
messages.subscribe(value=>t.is(value.data,"thanks")),t.true(instance.send.calledOnceWith("sendEth",["params"])),responsesMock.next({data:"thanks",id:41}),responsesMock.next({data:"thanks",id:41}),responsesMock.complete()}),(0,_ava.default)("should send and observe responses, even if errors are included",t=>{t.plan(5);// arrange
const responsesMock=new _rxjs.Subject,instance=new Messenger(null);_sinon.default.stub(instance,"send").returns(41),_sinon.default.stub(instance,"responses").returns(responsesMock);const messages=instance.sendAndObserveResponses("sendEth",["params"]);// assert
// act
messages.subscribe(value=>{value.data?t.is(value.data,"thanks"):value.error&&(t.true(value.error instanceof Error),t.is(value.error.message,"no thanks"))}),t.true(instance.send.calledOnceWith("sendEth",["params"])),responsesMock.next({data:"thanks",id:41}),responsesMock.next({error:"no thanks",id:41}),responsesMock.next({data:"thanks",id:41}),responsesMock.complete()}),(0,_ava.default)("should end response stream, once notified of its completion",t=>{t.plan(2);// arrange
const responsesMock=new _rxjs.Subject,instance=new Messenger(null);_sinon.default.stub(instance,"send").returns(41),_sinon.default.stub(instance,"responses").returns(responsesMock);const messages=instance.sendAndObserveResponses("sendEth");// assert
let completed;// act
// this should complete the messages stream
messages.subscribe({next(value){t.is(value.data,"thanks")},complete(){completed=!0}}),responsesMock.next({data:"thanks",id:41}),responsesMock.next({completed:!0,id:41}),responsesMock.next({data:"thanks again",id:41}),responsesMock.complete(),t.true(completed)}),(0,_ava.default)("should send and observe responses, defaulting parameters to empty array",t=>{t.plan(1);// arrange
const instance=new Messenger(null);_sinon.default.stub(instance,"send"),_sinon.default.stub(instance,"responses").returns((0,_rxjs.empty)());const messages=instance.sendAndObserveResponses("sendEth");// assert
messages.subscribe(),t.true(instance.send.calledOnceWith("sendEth",[]))}),(0,_ava.default)("should send and observe responses, but delay sending the request after subscribing",t=>{t.plan(2);// arrange
const instance=new Messenger(null);_sinon.default.stub(instance,"send"),_sinon.default.stub(instance,"responses").returns((0,_rxjs.empty)());const messages=instance.sendAndObserveResponses("sendEth",["params"]);// assert
// hasn't sent request before subscribing
t.true(instance.send.notCalled),messages.subscribe(),t.true(instance.send.calledOnceWith("sendEth",["params"]))}),(0,_ava.default)("should send and observe only the first response",t=>{t.plan(2);// arrange
const responsesMock=new _rxjs.Subject,instance=new Messenger(null);_sinon.default.stub(instance,"send").returns(41),_sinon.default.stub(instance,"responses").returns(responsesMock);// act
const messages=instance.sendAndObserveResponse("sendAnt",["params"]);// assert
messages.subscribe(value=>t.is(value.data,"first")),t.true(instance.send.calledOnceWith("sendAnt",["params"])),responsesMock.next({data:"first",id:41}),responsesMock.next({data:"second",id:41}),responsesMock.next({data:"third",id:41}),responsesMock.complete()}),(0,_ava.default)("should send and observe only the first error",t=>{t.plan(3);// arrange
const responsesMock=new _rxjs.Subject,instance=new Messenger(null);_sinon.default.stub(instance,"send").returns(41),_sinon.default.stub(instance,"responses").returns(responsesMock);const messages=instance.sendAndObserveResponse("sendAnt",["params"]);// assert
// act
messages.subscribe(()=>t.fail("should not have emitted any next values"),error=>{t.true(error instanceof Error),t.is(error.message,"bad first")}),t.true(instance.send.calledOnceWith("sendAnt",["params"])),responsesMock.next({error:"bad first",id:41}),responsesMock.next({data:"second",id:41}),responsesMock.complete()}),(0,_ava.default)("should end response stream immediately on first response",t=>{t.plan(2);// arrange
const responsesMock=new _rxjs.Subject,instance=new Messenger(null);_sinon.default.stub(instance,"send").returns(41),_sinon.default.stub(instance,"responses").returns(responsesMock);const messages=instance.sendAndObserveResponse("sendEth");// assert
let completed;// act
// this should complete the messages stream
messages.subscribe({next(value){t.is(value.data,"thanks")},complete(){completed=!0}}),responsesMock.next({data:"thanks",id:41}),responsesMock.next({data:"thanks again",id:41}),responsesMock.next({completed:!0,id:41}),responsesMock.complete(),t.true(completed)}),(0,_ava.default)("should send and observe only the first response, defaulting parameters to empty array",t=>{t.plan(1);// arrange
const instance=new Messenger(null);_sinon.default.stub(instance,"send").returns(41),_sinon.default.stub(instance,"responses").returns((0,_rxjs.of)({data:"response",id:41}));// must emit at least once
const messages=instance.sendAndObserveResponse("sendAnt");// assert
messages.subscribe(),t.true(instance.send.calledOnceWith("sendAnt",[]))}),(0,_ava.default)("should send and observe only the first response, but delay sending the request after subscribing",t=>{t.plan(2);// arrange
const instance=new Messenger(null);_sinon.default.stub(instance,"send").returns(41),_sinon.default.stub(instance,"responses").returns((0,_rxjs.of)({data:"response",id:41}));// must emit at least once
// act
const messages=instance.sendAndObserveResponse("sendAnt",["params"]);// assert
// hasn't sent request before subscribing
t.true(instance.send.notCalled),messages.subscribe(),t.true(instance.send.calledOnceWith("sendAnt",["params"]))});
//# sourceMappingURL=index.test.js.map