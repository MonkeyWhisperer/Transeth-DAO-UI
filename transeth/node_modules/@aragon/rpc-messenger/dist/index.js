"use strict";var _interopRequireDefault=require("@babel/runtime/helpers/interopRequireDefault");Object.defineProperty(exports,"__esModule",{value:!0}),Object.defineProperty(exports,"signals",{enumerable:!0,get:function get(){return _signals.default}}),exports.default=exports.providers=void 0;var _operators=require("rxjs/operators"),_rxjs=require("rxjs"),_jsonrpc=_interopRequireDefault(require("./jsonrpc")),_MessagePortMessage=_interopRequireDefault(require("./providers/MessagePortMessage")),_WindowMessage=_interopRequireDefault(require("./providers/WindowMessage")),_DevMessage=_interopRequireDefault(require("./providers/DevMessage")),_signals=_interopRequireDefault(require("./signals"));const providers={MessagePortMessage:_MessagePortMessage.default,WindowMessage:_WindowMessage.default,DevMessage:_DevMessage.default/**
 * The RPC messenger used for sending requests and responses between contexts.
 *
 * @param {Provider} [provider=MessagePortMessage] The underlying provider that passes messages
 * @class Messenger
 */};exports.providers=providers;class Messenger{constructor(provider=new _MessagePortMessage.default){this.provider=provider}/**
   * Get the message bus of incoming messages
   *
   * @returns {Observable}
   */bus(){return this.provider.messages()}/**
   * Get requests from the message bus.
   *
   * @returns {Observable}
   */requests(){return this.bus().pipe((0,_operators.filter)(message=>!_jsonrpc.default.isValidResponse(message)))}/**
   * Get responses from the message bus.
   *
   * @returns {Observable}
   */responses(){return this.bus().pipe((0,_operators.filter)(_jsonrpc.default.isValidResponse))}/**
   * Send a response
   *
   * @param {string} id The ID of the request being responded to.
   * @param {any} result The result of the request.
   * @returns {string}
   */sendResponse(id,result){const payload=_jsonrpc.default.encodeResponse(id,result);return this.provider.send(payload),payload.id}/**
   * Send a request
   *
   * @param {string} method The method name to call
   * @param {Array<any>} [params=[]] The parameters to send with the call
   * @returns {string} The ID of the payload that was sent
   */send(method,params=[]){const payload=_jsonrpc.default.encodeRequest(method,params);return this.provider.send(payload),payload.id}/**
   * Helper method to send a request and listen for multiple responses to that request.
   * To avoid dropping responses, the request is only sent once a subscriber is attached.
   *
   * @param {string} method The method name to call
   * @param {Array<any>} [params=[]] The parameters to send with the call
   * @returns {Observable} An observable of responses to the sent request
   */sendAndObserveResponses(method,params=[]){return(0,_rxjs.defer)(()=>{const id=this.send(method,params);return this.responses().pipe((0,_operators.filter)(message=>message.id===id),// End stream once we've been notified that it's complete
(0,_operators.takeWhile)(response=>!response.completed),(0,_operators.map)(response=>(response.error&&(response.error=new Error(response.error)),response))// Let callers handle errors themselves
)})}/**
   * Helper method to send a request and listen for a single response to that request
   * To avoid dropping the response, the request is only sent once a subscriber is attached.
   *
   * @param {string} method The method name to call
   * @param {Array<any>} [params] The parameters to send with the call
   * @returns {Observable} An observable that resolves to the response
   */sendAndObserveResponse(method,params=[]){return this.sendAndObserveResponses(method,params).pipe((0,_operators.first)(),(0,_operators.map)(response=>{// Emit an error if the response is an error
if(response.error)throw response.error;return response}))}}exports.default=Messenger;
//# sourceMappingURL=index.js.map