{"version":3,"sources":["../src/hid-framing.js"],"names":["Tag","asUInt16BE","value","b","Buffer","alloc","writeUInt16BE","initialAcc","data","dataLength","sequence","createHIDframing","channel","packetSize","makeBlocks","apdu","concat","length","blockSize","nbBlocks","Math","ceil","fill","blocks","i","head","writeUInt8","chunk","slice","push","reduceResponse","acc","readUInt16BE","readUInt8","chunkData","getReducedResult"],"mappings":"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","file":"hid-framing.js","sourcesContent":["// @flow\n\nimport { TransportError } from \"@ledgerhq/errors\";\n\nexport type ResponseAcc = ?{\n  data: Buffer,\n  dataLength: number,\n  sequence: number\n};\n\nconst Tag = 0x05;\n\nfunction asUInt16BE(value) {\n  const b = Buffer.alloc(2);\n  b.writeUInt16BE(value, 0);\n  return b;\n}\n\nconst initialAcc = {\n  data: Buffer.alloc(0),\n  dataLength: 0,\n  sequence: 0\n};\n\n/**\n *\n */\nconst createHIDframing = (channel: number, packetSize: number) => {\n  return {\n    makeBlocks(apdu: Buffer): Buffer[] {\n      let data = Buffer.concat([asUInt16BE(apdu.length), apdu]);\n      const blockSize = packetSize - 5;\n      const nbBlocks = Math.ceil(data.length / blockSize);\n      data = Buffer.concat([\n        data, // fill data with padding\n        Buffer.alloc(nbBlocks * blockSize - data.length + 1).fill(0)\n      ]);\n\n      const blocks = [];\n      for (let i = 0; i < nbBlocks; i++) {\n        const head = Buffer.alloc(5);\n        head.writeUInt16BE(channel, 0);\n        head.writeUInt8(Tag, 2);\n        head.writeUInt16BE(i, 3);\n        const chunk = data.slice(i * blockSize, (i + 1) * blockSize);\n        blocks.push(Buffer.concat([head, chunk]));\n      }\n      return blocks;\n    },\n\n    reduceResponse(acc: ResponseAcc, chunk: Buffer): ResponseAcc {\n      let { data, dataLength, sequence } = acc || initialAcc;\n\n      if (chunk.readUInt16BE(0) !== channel) {\n        throw new TransportError(\"Invalid channel\", \"InvalidChannel\");\n      }\n      if (chunk.readUInt8(2) !== Tag) {\n        throw new TransportError(\"Invalid tag\", \"InvalidTag\");\n      }\n      if (chunk.readUInt16BE(3) !== sequence) {\n        throw new TransportError(\"Invalid sequence\", \"InvalidSequence\");\n      }\n\n      if (!acc) {\n        dataLength = chunk.readUInt16BE(5);\n      }\n      sequence++;\n      const chunkData = chunk.slice(acc ? 5 : 7);\n      data = Buffer.concat([data, chunkData]);\n      if (data.length > dataLength) {\n        data = data.slice(0, dataLength);\n      }\n\n      return {\n        data,\n        dataLength,\n        sequence\n      };\n    },\n\n    getReducedResult(acc: ResponseAcc): ?Buffer {\n      if (acc && acc.dataLength === acc.data.length) {\n        return acc.data;\n      }\n    }\n  };\n};\n\nexport default createHIDframing;\n"]}