{"version":3,"sources":["../src/TransportNodeHid.js"],"names":["listenDevicesDebounce","listenDevicesPollingSkip","TransportNodeHid","path","Promise","resolve","then","HID","device","isSupported","list","setListenDevicesDebounce","delay","setListenDevicesPollingSkip","conditionToSkip","setListenDevicesDebug","console","warn","listen","observer","unsubscribed","devices","descriptor","deviceModel","productId","next","type","events","stop","onAdd","onRemove","on","unsubscribe","removeListener"],"mappings":";;;;;;;;AAEA;;;;AACA;;;;AAQA;;AACA;;AACA;;;;;;;;;;;;AAEA,IAAIA,wBAAwB,GAA5B;AACA,IAAIC,2BAA2B;AAAA,SAAM,KAAN;AAAA,CAA/B;;AAEA;;;;;;;;IAOqBC,gB;;;;;;;;;;;;;AAsFnB;;;;;AA7DA;;;;;AAdA;;;;AAVA;;;yBAwFYC,I,EAAe;AACzB,aAAOC,QAAQC,OAAR,GAAkBC,IAAlB,CAAuB,YAAM;AAClC,YAAIH,IAAJ,EAAU;AACR,iBAAO,IAAID,gBAAJ,CAAqB,IAAI,kBAAIK,GAAR,CAAYJ,IAAZ,CAArB,CAAP;AACD;AACD,YAAMK,SAAS,8CAAa,CAAb,CAAf;AACA,YAAI,CAACA,MAAL,EAAa,MAAM,2BAAmB,UAAnB,EAA+B,UAA/B,CAAN;AACb,eAAO,IAAIN,gBAAJ,CAAqB,IAAI,kBAAIK,GAAR,CAAYC,OAAOL,IAAnB,CAArB,CAAP;AACD,OAPM,CAAP;AAQD;;AAhED;;;;AAhBA;;;;;AAZA;;;;;;;;;AANmBD,gB,CAIZO,W,GAAc,qCAAyBA,W;AAJ3BP,gB,CASZQ,I,GAAO,qCAAyBA,I;;AATpBR,gB,CAcZS,wB,GAA2B,UAACC,KAAD,EAAmB;AACnDZ,0BAAwBY,KAAxB;AACD,C;;AAhBkBV,gB,CAqBZW,2B,GAA8B,UAACC,eAAD,EAAoC;AACvEb,6BAA2Ba,eAA3B;AACD,C;;AAvBkBZ,gB,CA4BZa,qB,GAAwB,YAAM;AACnCC,UAAQC,IAAR,CACE,0GADF;AAGD,C;;AAhCkBf,gB,CAoCZgB,M,GAAS,UACdC,QADc,EAEG;AACjB,MAAIC,eAAe,KAAnB;AACAhB,UAAQC,OAAR,CAAgB,6CAAhB,EAA8BC,IAA9B,CAAmC,mBAAW;AAC5C;AAD4C;AAAA;AAAA;;AAAA;AAE5C,2BAAqBe,OAArB,8HAA8B;AAAA,YAAnBb,MAAmB;;AAC5B,YAAI,CAACY,YAAL,EAAmB;AACjB,cAAME,aAAqBd,OAAOL,IAAlC;AACA,cAAMoB,cAAc,mCAAqBf,OAAOgB,SAA5B,CAApB;AACAL,mBAASM,IAAT,CAAc,EAAEC,MAAM,KAAR,EAAeJ,sBAAf,EAA2Bd,cAA3B,EAAmCe,wBAAnC,EAAd;AACD;AACF;AAR2C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAS7C,GATD;;AAFiB,uBAYQ,6BACvBvB,qBADuB,EAEvBC,wBAFuB,CAZR;AAAA,MAYT0B,MAZS,kBAYTA,MAZS;AAAA,MAYDC,IAZC,kBAYDA,IAZC;;AAiBjB,MAAMC,QAAQ,SAARA,KAAQ,SAAU;AACtB,QAAIT,gBAAgB,CAACZ,MAArB,EAA6B;AAC7B,QAAMe,cAAc,mCAAqBf,OAAOgB,SAA5B,CAApB;AACAL,aAASM,IAAT,CAAc;AACZC,YAAM,KADM;AAEZJ,kBAAYd,OAAOL,IAFP;AAGZoB,8BAHY;AAIZf;AAJY,KAAd;AAMD,GATD;AAUA,MAAMsB,WAAW,SAAXA,QAAW,SAAU;AACzB,QAAIV,gBAAgB,CAACZ,MAArB,EAA6B;AAC7B,QAAMe,cAAc,mCAAqBf,OAAOgB,SAA5B,CAApB;AACAL,aAASM,IAAT,CAAc;AACZC,YAAM,QADM;AAEZJ,kBAAYd,OAAOL,IAFP;AAGZoB,8BAHY;AAIZf;AAJY,KAAd;AAMD,GATD;AAUAmB,SAAOI,EAAP,CAAU,KAAV,EAAiBF,KAAjB;AACAF,SAAOI,EAAP,CAAU,QAAV,EAAoBD,QAApB;AACA,WAASE,WAAT,GAAuB;AACrBZ,mBAAe,IAAf;AACAO,WAAOM,cAAP,CAAsB,KAAtB,EAA6BJ,KAA7B;AACAF,WAAOM,cAAP,CAAsB,QAAtB,EAAgCH,QAAhC;AACAF;AACD;AACD,SAAO,EAAEI,wBAAF,EAAP;AACD,C;;kBApFkB9B,gB","file":"TransportNodeHid.js","sourcesContent":["//@flow\n\nimport HID from \"node-hid\";\nimport TransportNodeHidNoEvents, {\n  getDevices\n} from \"@ledgerhq/hw-transport-node-hid-noevents\";\nimport type {\n  Observer,\n  DescriptorEvent,\n  Subscription\n} from \"@ledgerhq/hw-transport\";\nimport { identifyUSBProductId } from \"@ledgerhq/devices\";\nimport { TransportError } from \"@ledgerhq/errors\";\nimport listenDevices from \"./listenDevices\";\n\nlet listenDevicesDebounce = 500;\nlet listenDevicesPollingSkip = () => false;\n\n/**\n * node-hid Transport implementation\n * @example\n * import TransportNodeHid from \"@ledgerhq/hw-transport-node-hid\";\n * ...\n * TransportNodeHid.create().then(transport => ...)\n */\nexport default class TransportNodeHid extends TransportNodeHidNoEvents {\n  /**\n   *\n   */\n  static isSupported = TransportNodeHidNoEvents.isSupported;\n\n  /**\n   *\n   */\n  static list = TransportNodeHidNoEvents.list;\n\n  /**\n   *\n   */\n  static setListenDevicesDebounce = (delay: number) => {\n    listenDevicesDebounce = delay;\n  };\n\n  /**\n   *\n   */\n  static setListenDevicesPollingSkip = (conditionToSkip: () => boolean) => {\n    listenDevicesPollingSkip = conditionToSkip;\n  };\n\n  /**\n   *\n   */\n  static setListenDevicesDebug = () => {\n    console.warn(\n      \"setListenDevicesDebug is deprecated. Use @ledgerhq/logs instead. No logs will get emitted there anymore.\"\n    );\n  };\n\n  /**\n   */\n  static listen = (\n    observer: Observer<DescriptorEvent<?string>>\n  ): Subscription => {\n    let unsubscribed = false;\n    Promise.resolve(getDevices()).then(devices => {\n      // this needs to run asynchronously so the subscription is defined during this phase\n      for (const device of devices) {\n        if (!unsubscribed) {\n          const descriptor: string = device.path;\n          const deviceModel = identifyUSBProductId(device.productId);\n          observer.next({ type: \"add\", descriptor, device, deviceModel });\n        }\n      }\n    });\n    const { events, stop } = listenDevices(\n      listenDevicesDebounce,\n      listenDevicesPollingSkip\n    );\n\n    const onAdd = device => {\n      if (unsubscribed || !device) return;\n      const deviceModel = identifyUSBProductId(device.productId);\n      observer.next({\n        type: \"add\",\n        descriptor: device.path,\n        deviceModel,\n        device\n      });\n    };\n    const onRemove = device => {\n      if (unsubscribed || !device) return;\n      const deviceModel = identifyUSBProductId(device.productId);\n      observer.next({\n        type: \"remove\",\n        descriptor: device.path,\n        deviceModel,\n        device\n      });\n    };\n    events.on(\"add\", onAdd);\n    events.on(\"remove\", onRemove);\n    function unsubscribe() {\n      unsubscribed = true;\n      events.removeListener(\"add\", onAdd);\n      events.removeListener(\"remove\", onRemove);\n      stop();\n    }\n    return { unsubscribe };\n  };\n\n  /**\n   * if path=\"\" is not provided, the library will take the first device\n   */\n  static open(path: ?string) {\n    return Promise.resolve().then(() => {\n      if (path) {\n        return new TransportNodeHid(new HID.HID(path));\n      }\n      const device = getDevices()[0];\n      if (!device) throw new TransportError(\"NoDevice\", \"NoDevice\");\n      return new TransportNodeHid(new HID.HID(device.path));\n    });\n  }\n}\n"]}