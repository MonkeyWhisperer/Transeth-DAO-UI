{"version":3,"sources":["../../src/parser/index.js"],"names":["PARSER_STATE","OK","ERROR","Parser","constructor","tokens","state","cursor","consume","previous","peek","matches","expected","eof","type","comparison","astBody","node","addition","operator","right","left","predicate","report","multiplication","power","unary","identifier","value","previousNode","length","pop","property","target","callee","inputs","functionInputs","outputs","typeList","helper","name","primary","NUMBER","STRING","HEXADECIMAL","BOOLEAN","expression","body","selected","push","hasSelectedTypeInList","find","item","input","walk","token","parse","ast","console","error"],"mappings":"8GAAA;;IAIA;;;;;IAOA;;;;IAKA;;;;;IAOA;;;;;GAMA,KAAMA,CAAAA,YAAY,CAAG,CACnBC,EAAE,CAAE,IADe,CAEnBC,KAAK,CAAE,OAFY,CAArB,CAKA;;;;;;;;GASO,KAAMC,CAAAA,MAAO,CAClBC,WAAW,CAAEC,MAAF,CAAU,CACnB,KAAKC,KAAL,CAAaN,YAAY,CAACC,EADP,CAGnB,KAAKI,MAAL,CAAcA,MAHK,CAInB,KAAKE,MAAL,CAAc,CACf,CAED;;;;KAKAC,OAAO,EAAI,CAGT,MAFA,MAAKD,MAAL,EAEA,CAAO,KAAKF,MAAL,CAAY,KAAKE,MAAL,CAAc,CAA1B,CACR,CAED;;;;KAKAE,QAAQ,EAAI,CACV,MAAO,MAAKJ,MAAL,CAAY,KAAKE,MAAL,CAAc,CAA1B,CACR,CAED;;;;KAKAG,IAAI,EAAI,CACN,MAAO,MAAKL,MAAL,CAAY,KAAKE,MAAjB,CACR,CAED;;;;;;;KAQAI,OAAO,CAAE,GAAGC,QAAL,CAAe,CACpB,GAAI,KAAKC,GAAL,EAAJ,CAAgB,SAChB,IAAK,GAAIC,CAAAA,IAAT,GAAiBF,CAAAA,QAAjB,CACE,GAAI,KAAKF,IAAL,GAAYI,IAAZ,GAAqBA,IAAzB,CAEE,MADA,MAAKP,MAAL,EACA,IAIJ,QACD,CAED;;;;;KAMAQ,UAAU,CAAEC,OAAF,CAAW,CACnB,GAAIC,CAAAA,IAAI,CAAG,KAAKC,QAAL,CAAcF,OAAd,CAAX,CADmB,KAGZ,KAAKL,OAAL,CAAa,SAAb,CAAwB,eAAxB,CAAyC,MAAzC,CAAiD,YAAjD,CAA+D,aAA/D,CAA8E,YAA9E,CAHY,EAGiF,IAC9FQ,CAAAA,QAAQ,CAAG,KAAKV,QAAL,GAAgBK,IADmE,CAE9FM,KAAK,CAAG,KAAKF,QAAL,CAAcF,OAAd,CAFsF,CAGlGC,IAAI,CAAG,CACLH,IAAI,CAAE,sBADD,CAELK,QAFK,CAGLE,IAAI,CAAEJ,IAHD,CAILG,KAJK,CAMR,CAwBD,MAtBI,MAAKT,OAAL,CAAa,eAAb,CAsBJ,GArBEM,IAAI,CAAG,CACLH,IAAI,CAAE,mBADD,CAELQ,SAAS,CAAEL,IAFN,CAGLI,IAAI,CAAE,KAAKN,UAAL,CAAgBC,OAAhB,CAHD,CAqBT,CAfM,CAAC,KAAKL,OAAL,CAAa,OAAb,CAeP,EAdI,KAAKY,MAAL,CAAY,qCAAZ,CAcJ,CAXEN,IAAI,CAACG,KAAL,CAAa,KAAKL,UAAL,CAAgBC,OAAhB,CAWf,EARI,KAAKL,OAAL,CAAa,qBAAb,CAQJ,GAPEM,IAAI,CAAG,CACLI,IAAI,CAAEJ,IADD,CAELG,KAAK,CAAE,KAAKL,UAAL,EAFF,CAGLD,IAAI,CAAE,mBAHD,CAOT,EAAOG,IACR,CAED;;;;;KAMAC,QAAQ,CAAEF,OAAF,CAAW,CACjB,GAAIC,CAAAA,IAAI,CAAG,KAAKO,cAAL,CAAoBR,OAApB,CAAX,CADiB,KAGV,KAAKL,OAAL,CAAa,OAAb,CAAsB,MAAtB,CAHU,EAGqB,IAChCQ,CAAAA,QAAQ,CAAG,KAAKV,QAAL,GAAgBK,IADK,CAEhCM,KAAK,CAAG,KAAKI,cAAL,CAAoBR,OAApB,CAFwB,CAGpCC,IAAI,CAAG,CACLH,IAAI,CAAE,kBADD,CAELK,QAFK,CAGLE,IAAI,CAAEJ,IAHD,CAILG,KAJK,CAMR,CAED,MAAOH,CAAAA,IACR,CAED;;;;;KAMAO,cAAc,CAAER,OAAF,CAAW,CACvB,GAAIC,CAAAA,IAAI,CAAG,KAAKQ,KAAL,CAAWT,OAAX,CAAX,CADuB,KAGhB,KAAKL,OAAL,CAAa,OAAb,CAAsB,MAAtB,CAA8B,QAA9B,CAHgB,EAGyB,IAC1CQ,CAAAA,QAAQ,CAAG,KAAKV,QAAL,GAAgBK,IADe,CAE1CM,KAAK,CAAG,KAAKK,KAAL,CAAWT,OAAX,CAFkC,CAI9CC,IAAI,CAAG,CACLH,IAAI,CAAE,kBADD,CAELK,QAFK,CAGLE,IAAI,CAAEJ,IAHD,CAILG,KAJK,CAMR,CAED,MAAOH,CAAAA,IACR,CAED;;;;;KAMAQ,KAAK,CAAET,OAAF,CAAW,CACd,GAAIC,CAAAA,IAAI,CAAG,KAAKS,KAAL,CAAWV,OAAX,CAAX,CADc,KAGP,KAAKL,OAAL,CAAa,OAAb,CAHO,EAGgB,IACxBQ,CAAAA,QAAQ,CAAG,KAAKV,QAAL,GAAgBK,IADH,CAExBM,KAAK,CAAG,KAAKM,KAAL,CAAWV,OAAX,CAFgB,CAI5BC,IAAI,CAAG,CACLH,IAAI,CAAE,kBADD,CAELK,QAFK,CAGLE,IAAI,CAAEJ,IAHD,CAILG,KAJK,CAMR,CAED,MAAOH,CAAAA,IACR,CAED;;;;;KAMAS,KAAK,CAAEV,OAAF,CAAW,CACd,GAAI,KAAKL,OAAL,CAAa,MAAb,CAAqB,OAArB,CAAJ,CAAmC,IAC7BQ,CAAAA,QAAQ,CAAG,KAAKV,QAAL,GAAgBK,IADE,CAE7BM,KAAK,CAAG,KAAKM,KAAL,CAAWV,OAAX,CAFqB,CAIjC,MAAO,CACLF,IAAI,CAAE,iBADD,CAELK,QAFK,CAGLC,KAAK,CAAEA,KAHF,CAKR,CAED,MAAO,MAAKO,UAAL,CAAgBX,OAAhB,CACR,CAED;;;;;KAMAW,UAAU,CAAEX,OAAF,CAAW,CACnB,GAAIC,CAAAA,IAAJ,CASA,GAPI,KAAKN,OAAL,CAAa,YAAb,CAOJ,GANEM,IAAI,CAAG,CACLH,IAAI,CAAE,YADD,CAELc,KAAK,CAAE,KAAKnB,QAAL,GAAgBmB,KAFlB,CAMT,EAAI,CAACX,IAAL,CAAW,CACT,KAAMY,CAAAA,YAAY,CAAGb,OAAO,CAACc,MAAR,EAAkBd,OAAO,CAACA,OAAO,CAACc,MAAR,CAAiB,CAAlB,CAA9C,CACID,YAAY,GACQ,YAAtB,GAAAA,YAAY,CAACf,IAAb,EACsB,mBAAtB,GAAAe,YAAY,CAACf,IADb,EAEsB,gBAAtB,GAAAe,YAAY,CAACf,IAHC,CAFP,GAOPG,IAAI,CAAGY,YAPA,CASPb,OAAO,CAACe,GAAR,EATO,CAWV,CAED,GAAId,IAAJ,CAAU,MACD,KAAKN,OAAL,CAAa,KAAb,CADC,EACoB,CAC1B,GAAIqB,CAAAA,QAAQ,CAAG,KAAKxB,OAAL,GAAeoB,KAA9B,CAEAX,IAAI,CAAG,CACLH,IAAI,CAAE,0BADD,CAELmB,MAAM,CAAEhB,IAFH,CAGLe,QAHK,CAKR,CAmBD,MAjBI,MAAKrB,OAAL,CAAa,YAAb,CAiBJ,GAhBEM,IAAI,CAAG,CACLH,IAAI,CAAE,gBADD,CAELmB,MAAM,CAAEhB,IAAI,CAACgB,MAFR,CAGLC,MAAM,CAAEjB,IAAI,CAACe,QAHR,CAILG,MAAM,CAAE,KAAKC,cAAL,CAAoBpB,OAApB,CAJH,CAKLqB,OAAO,CAAE,EALJ,CAgBT,CARM,KAAKxB,GAAL,EAQN,EANI,KAAKU,MAAL,CAAY,8BAAZ,CAMJ,CAHEN,IAAI,CAACoB,OAAL,CAAe,KAAKC,QAAL,EAGjB,EAAOrB,IACR,CAED,MAAO,MAAKsB,MAAL,CAAYvB,OAAZ,CACR,CAED;;;;;KAMAuB,MAAM,CAAEvB,OAAF,CAAW,CACf,GAAI,KAAKL,OAAL,CAAa,IAAb,CAAJ,CAAwB,MAChBgB,CAAAA,UAAU,CAAG,KAAKnB,OAAL,EADG,CAEhBgC,IAAI,CAAGb,UAAU,CAACC,KAFF,CAIE,YAApB,GAAAD,UAAU,CAACb,IAJO,EAKpB,KAAKS,MAAL,CAAa,iCAAgCiB,IAAK,oBAAlD,CALoB,CAQtB,KAAMvB,CAAAA,IAAI,CAAG,CACXH,IAAI,CAAE,gBADK,CAEX0B,IAAI,CAAEA,IAFK,CAAb,CAWA,MANI,MAAK7B,OAAL,CAAa,YAAb,CAMJ,CALEM,IAAI,CAACkB,MAAL,CAAc,KAAKC,cAAL,CAAoBpB,OAApB,CAKhB,CAHE,KAAKO,MAAL,CAAa,4CAAb,CAGF,CAAON,IACR,CAED,MAAO,MAAKwB,OAAL,CAAazB,OAAb,CACR,CAED;;;;;KAMAyB,OAAO,EAAW,CAChB,GAAI,KAAK9B,OAAL,CAAa,QAAb,CAAuB,QAAvB,CAAiC,aAAjC,CAAgD,SAAhD,CAAJ,CAAgE,CAC9D,GAAIG,CAAAA,IAAI,CAAG,CACT4B,MAAM,CAAE,eADC,CAETC,MAAM,CAAE,eAFC,CAGTC,WAAW,CAAE,cAHJ,CAITC,OAAO,CAAE,aAJA,EAKT,KAAKpC,QAAL,GAAgBK,IALP,CAAX,CAOA,MAAO,CACLA,IADK,CAELc,KAAK,CAAE,KAAKnB,QAAL,GAAgBmB,KAFlB,CAIR,CAED,GAAI,KAAKjB,OAAL,CAAa,YAAb,CAAJ,CAAgC,CAC9B,GAAImC,CAAAA,UAAJ,CAEA,EACE;AACAA,UAAU,CAAG,KAAK/B,UAAL,CAAgB+B,UAAU,CAAG,CAACA,UAAD,CAAH,CAAkB,EAA5C,CAFf,OAGS,CAAC,KAAKjC,GAAL,EAAD,EAAe,CAAC,KAAKF,OAAL,CAAa,aAAb,CAHzB,EASA,MAJI,MAAKE,GAAL,EAIJ,EAHE,KAAKU,MAAL,CAAY,uBAAZ,CAGF,CAAO,CACLT,IAAI,CAAE,mBADD,CAELiC,IAAI,CAAED,UAFD,CAIR,CAED,KAAKvB,MAAL,CAAa,kBAAiB,KAAKf,OAAL,GAAeM,IAAK,GAAlD,CACD,CAED;;;;KAKAA,IAAI,EAAI,CAON,MANK,MAAKH,OAAL,CAAa,OAAb,CAAD,EACmB,MAArB,QAAKD,IAAL,GAAYI,IAKd,EAHE,KAAKS,MAAL,CAAa,yBAAwB,KAAKb,IAAL,GAAYI,IAAK,GAAtD,CAGF,CAAO,KAAKN,OAAL,GAAeoB,KACvB,CAED;;;;KAKAU,QAAQ,EAAI,CAOV;AACA,GAPK,KAAK3B,OAAL,CAAa,OAAb,CAAD,EACoB,MAArB,QAAKD,IAAL,GAAYI,IAAZ,EAAoD,YAArB,QAAKJ,IAAL,GAAYI,IAM9C,EAJE,KAAKS,MAAL,CAAa,4CAA2C,KAAKb,IAAL,GAAYI,IAAK,GAAzE,CAIF,CAAI,CAAC,KAAKH,OAAL,CAAa,YAAb,CAAL,CACE,MAAO,CAAC,CACNG,IAAI,CAAE,KAAKN,OAAL,GAAeoB,KADf,CAENoB,QAAQ,GAFF,CAAD,CAAP,CAMF,GAAIV,CAAAA,QAAQ,CAAG,EAAf,CAfU,KAgBH,CAAC,KAAKzB,GAAL,EAAD,EAAe,CAAC,KAAKF,OAAL,CAAa,aAAb,CAhBb,EAgB0C,CAClD;AACA;AACA,GAAIqC,CAAAA,QAAQ,CAAG,KAAKrC,OAAL,CAAa,MAAb,CAAf,CAC0B,MAAtB,IAAC,KAAKD,IAAL,GAAYI,IAJiC,EAKhD,KAAKS,MAAL,CAAa,2DAA0D,KAAKb,IAAL,GAAYI,IAAK,GAAxF,CALgD,CAQlDwB,QAAQ,CAACW,IAAT,CAAc,CACZnC,IAAI,CAAE,KAAKN,OAAL,GAAeoB,KADT,CAEZoB,QAFY,CAAd,CARkD,CAe9CA,QAAQ,EAAI,CAAC,KAAKrC,OAAL,CAAa,SAAb,CAfiC,EAgBhD,KAAKY,MAAL,CAAa,wBAAb,CAhBgD,CAoB7C,KAAKZ,OAAL,CAAa,OAAb,CAAD,EAA+C,aAArB,QAAKD,IAAL,GAAYI,IApBQ,EAqBhD,KAAKS,MAAL,CAAY,wEAAZ,CAEH,CAEG,KAAKV,GAAL,EAzCM,EA2CR,KAAKU,MAAL,CAAa,oBAAb,CA3CQ,CA8CV;AACA;AACA;AACA;AACA;AACA;AACA,KAAM2B,CAAAA,qBAAqB,CAAG,CAAC,CAACZ,QAAQ,CAACa,IAAT,CAAeC,IAAD,EAAUA,IAAI,CAACJ,QAA7B,CAAhC,CAOA,MANKE,CAAAA,qBAAD,EAA8C,CAApB,GAAAZ,QAAQ,CAACR,MAMvC,CAJW,CAACoB,qBAIZ,EAHE,KAAK3B,MAAL,CAAa,gCAAb,CAGF,CALEe,QAAQ,CAAC,CAAD,CAAR,CAAYU,QAAZ,GAKF,CAAOV,QACR,CAED;;;;;KAMAF,cAAc,CAAEpB,OAAF,CAAW,CACvB,KAAMmB,CAAAA,MAAM,CAAG,EAAf,CADuB,KAGhB,CAAC,KAAKtB,GAAL,EAAD,EAAe,CAAC,KAAKF,OAAL,CAAa,aAAb,CAHA,EAG6B,CAClD,KAAM0C,CAAAA,KAAK,CAAG,KAAKtC,UAAL,CAAgBC,OAAhB,CAAd,CACKqC,KAAK,CAACvC,IAFuC,CAIvC,KAAKH,OAAL,CAAa,OAAb,CAJuC,EAKhD,KAAKY,MAAL,CAAa,sDAAb,CALgD,CAGhD8B,KAAK,CAACvC,IAAN,CAAa,KAAKA,IAAL,EAHmC,CAQlDqB,MAAM,CAACc,IAAP,CAAYI,KAAZ,CARkD,CAW7C,KAAK1C,OAAL,CAAa,OAAb,CAAD,EAA+C,aAArB,QAAKD,IAAL,GAAYI,IAXQ,EAYhD,KAAKS,MAAL,CAAY,wEAAZ,CAEH,CAED,MAAOY,CAAAA,MACR,CAED;;;;;;KAOAmB,IAAI,CAAEtC,OAAF,CAAW,CACb,GAAIuC,CAAAA,KAAK,CAAG,KAAK7C,IAAL,EAAZ,CAEA,GAAmB,WAAf,GAAA6C,KAAK,CAACzC,IAAV,CACE,MAAO,CACLA,IAAI,CAAE,oBADD,CAELc,KAAK,CAAE,KAAKpB,OAAL,GAAeoB,KAFjB,CAAP,CAMF,GAAmB,MAAf,GAAA2B,KAAK,CAACzC,IAAV,CAA2B,CACzB,GAAIG,CAAAA,IAAI,CAAG,CACTH,IAAI,CAAE,qBADG,CAETiC,IAAI,CAAE,EAFG,CAAX,CADyB,IAMzB,KAAKpC,OAAL,CAAa,MAAb,CANyB,CAQlB,CAAC,KAAKE,GAAL,EAAD,EAAoC,MAArB,QAAKH,IAAL,GAAYI,IART,EASvBG,IAAI,CAAC8B,IAAL,CAAUE,IAAV,CAAe,KAAKK,IAAL,CAAUrC,IAAI,CAAC8B,IAAf,CAAf,EASF,MANI,MAAKlC,GAAL,EAMJ,EALE,KAAKU,MAAL,CAAY,yBAAZ,CAKF,CAFA,KAAKZ,OAAL,CAAa,MAAb,CAEA,CAAOM,IACR,CAED,MAAO,MAAKF,UAAL,CAAgBC,OAAhB,CACR,CAED;;;;KAKA,KAAMwC,CAAAA,KAAN,EAAe,CACb,GAAIC,CAAAA,GAAG,CAAG,CACR3C,IAAI,CAAE,SADE,CAERiC,IAAI,CAAE,EAFE,CAAV,CADa,KAMN,CAAC,KAAKlC,GAAL,EANK,EAOX4C,GAAG,CAACV,IAAJ,CAASE,IAAT,CAAc,KAAKK,IAAL,CAAUG,GAAG,CAACV,IAAd,CAAd,EAPW,MAUT,MAAKzC,KAAL,GAAeN,YAAY,CAACE,KAVnB,EAWXwD,OAAO,CAACC,KAAR,CAAe,yCAAf,CAXW,CAYJF,GAZI,EAeNA,GACR,CAED;;;;KAKA5C,GAAG,EAAI,CACL,MAAO,MAAKN,MAAL,EAAe,KAAKF,MAAL,CAAYyB,MACnC,CAED;;;;;;KAOAP,MAAM,CAAEoC,KAAF,CAAS,CACb,KAAKrD,KAAL,CAAaN,YAAY,CAACE,KADb,CAEbwD,OAAO,CAACC,KAAR,CACG,UAAS,KAAKpD,MAAO,MAAKoD,KAAM,EADnC,CAGD,CA9gBiB,CAihBpB;;;;;;yBAOO,QAASH,CAAAA,KAAT,CAAgBnD,MAAhB,CAAwB,CAC7B,MAAO,IAAIF,CAAAA,MAAJ,CAAWE,MAAX,EAAmBmD,KAAnB,EACR","sourcesContent":["/**\n * @module radspec/parser\n */\n\n/**\n * A token.\n * @typedef {Object} Token\n * @property {string} type The token type\n * @property {*?} value The value of the token\n */\n\n/**\n * An AST node.\n * @typedef {Object} Node\n * @property {string} type The node type\n */\n/**\n * An AST.\n * @typedef {Object} AST\n * @property {string} type\n * @property {Array<Node>} body The AST nodes\n */\n\n/**\n * Enum for parser state.\n *\n * @readonly\n * @enum {string}\n */\nconst PARSER_STATE = {\n  OK: 'OK',\n  ERROR: 'ERROR'\n}\n\n/**\n * Parses a token list into an AST.\n *\n * @class Parser\n * @param {Array<Token>} tokens\n * @property {string} state The state of the parser (`OK` or `ERROR`)\n * @property {Array<Token>} tokens\n * @property {number} cursor\n */\nexport class Parser {\n  constructor (tokens) {\n    this.state = PARSER_STATE.OK\n\n    this.tokens = tokens\n    this.cursor = 0\n  }\n\n  /**\n   * Get the current token and increase the cursor by 1\n   *\n   * @return {Token}\n   */\n  consume () {\n    this.cursor++\n\n    return this.tokens[this.cursor - 1]\n  }\n\n  /**\n   * Get the previous token.\n   *\n   * @return {Token}\n   */\n  previous () {\n    return this.tokens[this.cursor - 1]\n  }\n\n  /**\n   * Get the token under the cursor without consuming it.\n   *\n   * @return {Token}\n   */\n  peek () {\n    return this.tokens[this.cursor]\n  }\n\n  /**\n   * Checks if the type of the next token matches any of the expected types.\n   *\n   * Increases the cursor by 1 if the token matches.\n   *\n   * @param {...string} expected The expected types\n   * @return {boolean} True if the next token matches, otherwise false\n   */\n  matches (...expected) {\n    if (this.eof()) return false\n    for (let type of expected) {\n      if (this.peek().type === type) {\n        this.cursor++\n        return true\n      }\n    }\n\n    return false\n  }\n\n  /**\n   * Try to parse comparison operators.\n   *\n   * @param  {Array<Node>} astBody Subtree of AST being walked\n   * @return {Node}\n   */\n  comparison (astBody) {\n    let node = this.addition(astBody)\n\n    while (this.matches('GREATER', 'GREATER_EQUAL', 'LESS', 'LESS_EQUAL', 'EQUAL_EQUAL', 'BANG_EQUAL')) {\n      let operator = this.previous().type\n      let right = this.addition(astBody)\n      node = {\n        type: 'ComparisonExpression',\n        operator,\n        left: node,\n        right\n      }\n    }\n\n    if (this.matches('QUESTION_MARK')) {\n      node = {\n        type: 'TernaryExpression',\n        predicate: node,\n        left: this.comparison(astBody)\n      }\n\n      if (!this.matches('COLON')) {\n        this.report('Half-baked ternary (expected colon)')\n      }\n\n      node.right = this.comparison(astBody)\n    }\n\n    if (this.matches('DOUBLE_VERTICAL_BAR')) {\n      node = {\n        left: node,\n        right: this.comparison(),\n        type: 'DefaultExpression'\n      }\n    }\n\n    return node\n  }\n\n  /**\n   * Try to parse arithmetic operators.\n   *\n   * @param  {Array<Node>} astBody Subtree of AST being walked\n   * @return {Node}\n   */\n  addition (astBody) {\n    let node = this.multiplication(astBody)\n\n    while (this.matches('MINUS', 'PLUS')) {\n      let operator = this.previous().type\n      let right = this.multiplication(astBody)\n      node = {\n        type: 'BinaryExpression',\n        operator,\n        left: node,\n        right\n      }\n    }\n\n    return node\n  }\n\n  /**\n   * Try to parse binary operators.\n   *\n   * @param  {Array<Node>} astBody Subtree of AST being walked\n   * @return {Node}\n   */\n  multiplication (astBody) {\n    let node = this.power(astBody)\n\n    while (this.matches('SLASH', 'STAR', 'MODULO')) {\n      let operator = this.previous().type\n      let right = this.power(astBody)\n\n      node = {\n        type: 'BinaryExpression',\n        operator,\n        left: node,\n        right\n      }\n    }\n\n    return node\n  }\n\n  /**\n   * Try to parse exponential operators.\n   *\n   * @param  {Array<Node>} astBody Subtree of AST being walked\n   * @return {Node}\n   */\n  power (astBody) {\n    let node = this.unary(astBody)\n\n    while (this.matches('POWER')) {\n      let operator = this.previous().type\n      let right = this.unary(astBody)\n\n      node = {\n        type: 'BinaryExpression',\n        operator,\n        left: node,\n        right\n      }\n    }\n\n    return node\n  }\n\n  /**\n   * Try to parse unary operators.\n   *\n   * @param  {Array<Node>} astBody Subtree of AST being walked\n   * @return {Node}\n   */\n  unary (astBody) {\n    if (this.matches('BANG', 'MINUS')) {\n      let operator = this.previous().type\n      let right = this.unary(astBody)\n\n      return {\n        type: 'UnaryExpression',\n        operator,\n        right: right\n      }\n    }\n\n    return this.identifier(astBody)\n  }\n\n  /**\n   * Try to parse identifiers and call expressions.\n   *\n   * @param  {Array<Node>} astBody Subtree of AST being walked\n   * @return {Node}\n   */\n  identifier (astBody) {\n    let node\n\n    if (this.matches('IDENTIFIER')) {\n      node = {\n        type: 'Identifier',\n        value: this.previous().value\n      }\n    }\n\n    if (!node) {\n      const previousNode = astBody.length && astBody[astBody.length - 1]\n      if (previousNode && (\n        previousNode.type === 'Identifier' ||\n        previousNode.type === 'GroupedExpression' ||\n        previousNode.type === 'CallExpression'\n      )) {\n        node = previousNode\n        // Consume the last node as part of this node\n        astBody.pop()\n      }\n    }\n\n    if (node) {\n      while (this.matches('DOT')) {\n        let property = this.consume().value\n\n        node = {\n          type: 'PropertyAccessExpression',\n          target: node,\n          property\n        }\n      }\n\n      if (this.matches('LEFT_PAREN')) {\n        node = {\n          type: 'CallExpression',\n          target: node.target,\n          callee: node.property,\n          inputs: this.functionInputs(astBody),\n          outputs: []\n        }\n\n        if (this.eof()) {\n          // TODO Better error\n          this.report('Unterminated call expression')\n        }\n\n        node.outputs = this.typeList()\n      }\n\n      return node\n    }\n\n    return this.helper(astBody)\n  }\n\n  /**\n   * Try to parse helper functions\n   *\n   * @param  {Array<Node>} astBody Subtree of AST being walked\n   * @return {Node}\n   */\n  helper (astBody) {\n    if (this.matches('AT')) {\n      const identifier = this.consume()\n      const name = identifier.value\n\n      if (identifier.type !== 'IDENTIFIER') {\n        this.report(`Invalid helper function name '${name}' provided after @`)\n      }\n\n      const node = {\n        type: 'HelperFunction',\n        name: name\n      }\n\n      if (this.matches('LEFT_PAREN')) {\n        node.inputs = this.functionInputs(astBody)\n      } else {\n        this.report(`Expected '(' for executing helper function`)\n      }\n\n      return node\n    }\n\n    return this.primary(astBody)\n  }\n\n  /**\n   * Try to parse primaries (literals).\n   *\n   * @param  {Array<Node>} astBody Subtree of AST being walked\n   * @return {Node}\n   */\n  primary (astBody) {\n    if (this.matches('NUMBER', 'STRING', 'HEXADECIMAL', 'BOOLEAN')) {\n      let type = {\n        NUMBER: 'NumberLiteral',\n        STRING: 'StringLiteral',\n        HEXADECIMAL: 'BytesLiteral',\n        BOOLEAN: 'BoolLiteral'\n      }[this.previous().type]\n\n      return {\n        type,\n        value: this.previous().value\n      }\n    }\n\n    if (this.matches('LEFT_PAREN')) {\n      let expression\n\n      do {\n        // Keep munching expressions in the context of the current expression\n        expression = this.comparison(expression ? [expression] : [])\n      } while (!this.eof() && !this.matches('RIGHT_PAREN'))\n\n      if (this.eof()) {\n        this.report('Unterminated grouping')\n      }\n\n      return {\n        type: 'GroupedExpression',\n        body: expression\n      }\n    }\n\n    this.report(`Unknown token \"${this.consume().type}\"`)\n  }\n\n  /**\n   * Try to parse a type.\n   *\n   * @return {string} The type\n   */\n  type () {\n    if (!this.matches('COLON') &&\n      this.peek().type !== 'TYPE') {\n      // TODO Better error\n      this.report(`Expected a type, got \"${this.peek().type}\"`)\n    }\n\n    return this.consume().value\n  }\n\n  /**\n   * Try to parse a type list.\n   *\n   * @return {Array<string>} The list of types\n   */\n  typeList () {\n    if (!this.matches('COLON') &&\n      (this.peek().type !== 'TYPE' || this.peek().type !== 'LEFT_PAREN')) {\n      // TODO Better error\n      this.report(`Expected a type or a list of types, got \"${this.peek().type}\"`)\n    }\n\n    // We just have a single type\n    if (!this.matches('LEFT_PAREN')) {\n      return [{\n        type: this.consume().value,\n        selected: true\n      }]\n    }\n\n    let typeList = []\n    while (!this.eof() && !this.matches('RIGHT_PAREN')) {\n      // Check if the type is preceded by a < to denote\n      // that this is the type of the return value we want.\n      let selected = this.matches('LESS')\n      if (!this.peek().type === 'TYPE') {\n        this.report(`Unexpected identifier in type list, expected type, got \"${this.peek().type}\"`)\n      }\n\n      typeList.push({\n        type: this.consume().value,\n        selected\n      })\n\n      // If the type was preceded by a <, then it\n      // should be followed by a >.\n      if (selected && !this.matches('GREATER')) {\n        this.report(`Unclosed selected type`)\n      }\n\n      // If this is true, then types have been specified without delimiting them using commas.\n      if (!this.matches('COMMA') && this.peek().type !== 'RIGHT_PAREN') {\n        this.report('Undelimited parameter type (expected comma delimiter or closing brace)')\n      }\n    }\n\n    if (this.eof()) {\n      // TODO Better error\n      this.report(`Unclosed type list`)\n    }\n\n    // Verify that at least one type in the type list has been selected\n    // as the type of the return value.\n    //\n    // If no type has been selected, and the number of types in the type\n    // list is exactly 1, then we assume that that type should be\n    // marked as selected.\n    const hasSelectedTypeInList = !!typeList.find((item) => item.selected)\n    if (!hasSelectedTypeInList && typeList.length === 1) {\n      typeList[0].selected = true\n    } else if (!hasSelectedTypeInList) {\n      this.report(`Type list has no selected type`)\n    }\n\n    return typeList\n  }\n\n  /**\n   * Try to parse function arguments.\n   *\n   * @param  {Array<Node>} astBody Subtree of AST being walked\n   * @return {Array<Node>}\n   */\n  functionInputs (astBody) {\n    const inputs = []\n\n    while (!this.eof() && !this.matches('RIGHT_PAREN')) {\n      const input = this.comparison(astBody)\n      if (!input.type) {\n        input.type = this.type()\n      } else if (this.matches('COLON')) {\n        this.report(`Unexpected type (already inferred type of parameter)`)\n      }\n\n      inputs.push(input)\n\n      // If this is true, then types have been specified without delimiting them using commas.\n      if (!this.matches('COMMA') && this.peek().type !== 'RIGHT_PAREN') {\n        this.report('Undelimited parameter type (expected comma delimiter or closing brace)')\n      }\n    }\n\n    return inputs\n  }\n\n  /**\n   * Walk all possible paths and try to parse a single node\n   * from the list of tokens.\n   *\n   * @param  {Array<Node>} astBody Subtree of AST being walked\n   * @return {Node}\n   */\n  walk (astBody) {\n    let token = this.peek()\n\n    if (token.type === 'MONOLOGUE') {\n      return {\n        type: 'MonologueStatement',\n        value: this.consume().value\n      }\n    }\n\n    if (token.type === 'TICK') {\n      let node = {\n        type: 'ExpressionStatement',\n        body: []\n      }\n\n      this.matches('TICK')\n\n      while (!this.eof() && this.peek().type !== 'TICK') {\n        node.body.push(this.walk(node.body))\n      }\n\n      if (this.eof()) {\n        this.report('Unterminated expression')\n      }\n\n      this.matches('TICK')\n\n      return node\n    }\n\n    return this.comparison(astBody)\n  }\n\n  /**\n   * Walks the token list and returns an AST.\n   *\n   * @return {AST} The AST\n   */\n  async parse () {\n    let ast = {\n      type: 'Program',\n      body: []\n    }\n\n    while (!this.eof()) {\n      ast.body.push(this.walk(ast.body))\n    }\n\n    if (this.state === PARSER_STATE.ERROR) {\n      console.error(`Errors encountered while parsing source`)\n      return ast\n    }\n\n    return ast\n  }\n\n  /**\n   * Returns true if we've reached the end of the token list, otherwise false.\n   *\n   * @return {boolean}\n   */\n  eof () {\n    return this.cursor >= this.tokens.length\n  }\n\n  /**\n   * Prints an error with location information to `stderr`\n   * and sets the parser state to `PARSER_STATE.ERROR`\n   *\n   * @param {string} error\n   * @return {void}\n   */\n  report (error) {\n    this.state = PARSER_STATE.ERROR\n    console.error(\n      `Error (${this.cursor}): ${error}`\n    )\n  }\n}\n\n/**\n * Walks token list and returns an AST.\n *\n * @memberof radspec/parser\n * @param  {Array<Token>} tokens\n * @return {AST} The AST\n */\nexport function parse (tokens) {\n  return new Parser(tokens).parse()\n}\n"],"file":"index.js"}