{"version":3,"sources":["../../src/helpers/radspec.js"],"names":["makeUnknownFunctionNode","methodId","type","value","getSig","fn","substr","processFunctions","functions","Object","keys","reduce","acc","key","source","sig","eth","evaluator","addr","data","knownFunctions","length","registry","MethodRegistry","networkId","result","lookup","name","parse","inputString","replace","split","parameters","inputs","parameterValues","ABI","decodeParameters","input","i","availableHelpers","helpers","getHelpers","to"],"mappings":"qvCAMMA,CAAAA,uBAAuB,CAAIC,QAAD,GAAe,CAC7CC,IAAI,CAAE,QADuC,CAE7CC,KAAK,CAAG,qBAAoBF,QAAS,GAFQ,CAAf,C,CAK1BG,MAAM,CAAIC,EAAD,EACb,yBAAUA,EAAV,EAAcC,MAAd,CAAqB,CAArB,CAAwB,EAAxB,C,CAKIC,gBAAgB,CAAIC,SAAD,EACvBC,MAAM,CAACC,IAAP,CAAYF,SAAZ,EAAuBG,MAAvB,CACE,CAACC,GAAD,CAAMC,GAAN,kBAEI,CAACT,MAAM,CAACS,GAAD,CAAP,EAAe,CAAEC,MAAM,CAAEN,SAAS,CAACK,GAAD,CAAnB,CAA0BE,GAAG,CAAEF,GAA/B,CAFnB,EAGOD,GAHP,CADF,CAMK,EANL,C,cAQa,CAACI,GAAD,CAAMC,SAAN,GACb;;;;;;;KAQA,MAAOC,IAAP,CAAaC,IAAb,GAAsB,CACpB,KAAMX,CAAAA,SAAS,CAAGD,gBAAgB,CAACa,oBAAD,CAAlC,CAEA,GAAkB,EAAd,CAAAD,IAAI,CAACE,MAAT,CACE,MAAOrB,CAAAA,uBAAuB,CAACmB,IAAD,CAA9B,CAGF;AAPoB,KAQdlB,CAAAA,QAAQ,CAAGkB,IAAI,CAACb,MAAL,CAAY,CAAZ,CAAe,EAAf,CARG,CASdD,EAAE,CAAGG,SAAS,CAACP,QAAD,CATA,CAWpB;AACA,GAAI,CAACI,EAAL,CAAS,CACP;AACA;AAFO,KAGDiB,CAAAA,QAAQ,CAAG,GAAIC,wBAAJ,CAAmB,CAAEC,SAAS,CAAE,GAAb,CAAkBR,GAAlB,CAAnB,CAHV,CAIDS,MAAM,CAAG,KAAMH,CAAAA,QAAQ,CAACI,MAAT,CAAgBzB,QAAhB,CAJd,CAMP,GAAIwB,MAAJ,CAAY,CACV,KAAM,CAAEE,IAAF,EAAWL,QAAQ,CAACM,KAAT,CAAeH,MAAf,CAAjB,CACA,MAAO,CACLvB,IAAI,CAAE,QADD,CAELC,KAAK,CAAEwB,IAAK;AAFP,CAIR,CACC,MAAO3B,CAAAA,uBAAuB,CAACC,QAAD,CAEjC,CACD;AA5BoB,KA6Bd,CAAEa,MAAF,CAAUC,GAAV,EAAkBV,EA7BJ,CAgCdwB,WAAW,CAAGd,GAAG,CAACe,OAAJ,CAAY,GAAZ,CAAiB,EAAjB,EAAqBC,KAArB,CAA2B,GAA3B,EAAgC,CAAhC,CAhCA,CA+BpB;AAGA,GAAIC,CAAAA,UAAU,CAAG,EAAjB,CAEA;AACA,GAAoB,EAAhB,GAAAH,WAAJ,CAAwB,MAChBI,CAAAA,MAAM,CAAGJ,WAAW,CAACE,KAAZ,CAAkB,GAAlB,CADO,CAIhBG,eAAe,CAAGC,oBAAIC,gBAAJ,CAAqBH,MAArB,CAA6B,KAAOd,IAAI,CAACb,MAAL,CAAY,EAAZ,CAApC,CAJF,CAGtB;AAEA0B,UAAU,CAAGC,MAAM,CAACtB,MAAP,CAAc,CAACC,GAAD,CAAMyB,KAAN,CAAaC,CAAb,kBAEvB,CAAE,IAAGA,CAAC,CAAG,CAAE,EAAX,EAAe,CACbpC,IAAI,CAAEmC,KADO,CAEblC,KAAK,CAAE+B,eAAe,CAACI,CAAD,CAFT,CAFQ,EAMpB1B,GANoB,CAAd,CAOP,EAPO,CAQd,CAED,MAAO,CACLV,IAAI,CAAE,QADD,CAELC,KAAK,CAAE,KAAM,qBACXW,MADW,CAEXkB,UAFW,CAGX,CACEhB,GADF,CAEEuB,gBAAgB,CAAEtB,SAAS,CAACuB,OAAV,CAAkBC,UAAlB,EAFpB,CAGEC,EAAE,CAAExB,IAHN,CAHW,CAFR,CAYR,C","sourcesContent":["import ABI from 'web3-eth-abi'\nimport { keccak256 } from 'web3-utils'\nimport MethodRegistry from './lib/methodRegistry'\nimport { evaluateRaw } from '../lib/'\nimport { knownFunctions } from '../data/'\n\nconst makeUnknownFunctionNode = (methodId) => ({\n  type: 'string',\n  value: `Unknown function (${methodId})`\n})\n\nconst getSig = (fn) =>\n  keccak256(fn).substr(0, 10)\n\n// Convert from the knownFunctions data format into the needed format\n// Input: { \"signature(type1,type2)\": \"Its radspec string\", ... }\n// Output: { \"0xabcdef12\": { \"sig\": \"signature(type1,type2)\", \"source\": \"Its radspec string\" }, ...}\nconst processFunctions = (functions) => (\n  Object.keys(functions).reduce(\n    (acc, key) => (\n      {\n        [getSig(key)]: { source: functions[key], sig: key },\n        ...acc\n      }\n    ), {})\n)\nexport default (eth, evaluator) =>\n  /**\n   * Interpret calldata using radspec recursively. If the function signature is not in the package's known\n   * functions, it fallbacks to looking for the function name using github.com/parity-contracts/signature-registry\n   *\n   * @param {address} addr The target address of the call\n   * @param {bytes} data The calldata of the call\n   * @return {Promise<radspec/evaluator/TypedValue>}\n   */\n  async (addr, data) => {\n    const functions = processFunctions(knownFunctions)\n\n    if (data.length < 10) {\n      return makeUnknownFunctionNode(data)\n    }\n\n    // Get method ID\n    const methodId = data.substr(0, 10)\n    const fn = functions[methodId]\n\n    // If function is not a known function, execute fallback checking Parity's on-chain signature registry\n    if (!fn) {\n      // Even if we pass the ETH object, if it is not on mainnet it will use Aragon's ETH mainnet node\n      // As the registry is the only available on mainnet\n      const registry = new MethodRegistry({ networkId: '1', eth })\n      const result = await registry.lookup(methodId)\n\n      if (result) {\n        const { name } = registry.parse(result)\n        return {\n          type: 'string',\n          value: name // TODO: should we decode and print the arguments as well?\n        }\n      } else {\n        return makeUnknownFunctionNode(methodId)\n      }\n    }\n    // If the function was found in local radspec registry. Decode and evaluate.\n    const { source, sig } = fn\n\n    // get the array of input types from the function signature\n    const inputString = sig.replace(')', '').split('(')[1]\n\n    let parameters = []\n\n    // If the function has parameters\n    if (inputString !== '') {\n      const inputs = inputString.split(',')\n\n      // Decode parameters\n      const parameterValues = ABI.decodeParameters(inputs, '0x' + data.substr(10))\n      parameters = inputs.reduce((acc, input, i) => (\n        {\n          [`$${i + 1}`]: {\n            type: input,\n            value: parameterValues[i]\n          },\n          ...acc\n        }), {})\n    }\n\n    return {\n      type: 'string',\n      value: await evaluateRaw(\n        source,\n        parameters,\n        {\n          eth,\n          availableHelpers: evaluator.helpers.getHelpers(),\n          to: addr\n        }\n      )\n    }\n  }\n"],"file":"radspec.js"}