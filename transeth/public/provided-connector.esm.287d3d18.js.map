{"version":3,"sources":["../../../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/index.ts"],"names":["_iteratorSymbol","Symbol","iterator","_asyncIteratorSymbol","asyncIterator","_catch","body","recover","result","e","then","parseSendReturn","sendReturn","hasOwnProperty","NoEthereumProviderError","name","constructor","message","Error","UserRejectedRequestError","ProvidedConnector","provider","window","ethereum","supportedChainIds","handleNetworkChanged","bind","handleChainChanged","handleAccountsChanged","handleClose","chainId","console","log","emitUpdate","accounts","length","emitDeactivate","account","code","reason","networkId","activate","enable","on","isMetaMask","autoRefreshOnNetworkChange","send","error","warning","getProvider","getChainId","method","isDapper","cachedResults","net_version","networkVersion","_chainId","getAccount","deactivate","removeListener","isAuthorized","AbstractConnector"],"mappings":"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","file":"provided-connector.esm.287d3d18.js","sourceRoot":"../src","sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import { ConnectorUpdate } from '@web3-react/types'\nimport { AbstractConnector } from '@web3-react/abstract-connector'\nimport warning from 'tiny-warning'\n\nimport { SendReturnResult, SendReturn, Send, SendOld } from './types'\n\nfunction parseSendReturn(sendReturn: SendReturnResult | SendReturn): any {\n  return sendReturn.hasOwnProperty('result') ? sendReturn.result : sendReturn\n}\n\nexport class NoEthereumProviderError extends Error {\n  public constructor() {\n    super()\n    this.name = this.constructor.name\n    this.message = 'No Ethereum provider was passed to the constructor or found on window.ethereum.'\n  }\n}\n\nexport class UserRejectedRequestError extends Error {\n  public constructor() {\n    super()\n    this.name = this.constructor.name\n    this.message = 'The user rejected the request.'\n  }\n}\n\ninterface ProvidedConnectorArguments {\n  provider?: any\n  supportedChainIds: number[]\n}\n\nexport class ProvidedConnector extends AbstractConnector {\n  private provider: Ethereum\n\n  constructor({ provider = window.ethereum, supportedChainIds }: ProvidedConnectorArguments) {\n    super({ supportedChainIds })\n\n    this.provider = provider\n\n    this.handleNetworkChanged = this.handleNetworkChanged.bind(this)\n    this.handleChainChanged = this.handleChainChanged.bind(this)\n    this.handleAccountsChanged = this.handleAccountsChanged.bind(this)\n    this.handleClose = this.handleClose.bind(this)\n  }\n\n  private handleChainChanged(chainId: string | number): void {\n    if (__DEV__) {\n      console.log(\"Handling 'chainChanged' event with payload\", chainId)\n    }\n    this.emitUpdate({ chainId, provider: this.provider })\n  }\n\n  private handleAccountsChanged(accounts: string[]): void {\n    if (__DEV__) {\n      console.log(\"Handling 'accountsChanged' event with payload\", accounts)\n    }\n    if (accounts.length === 0) {\n      this.emitDeactivate()\n    } else {\n      this.emitUpdate({ account: accounts[0] })\n    }\n  }\n\n  private handleClose(code: number, reason: string): void {\n    if (__DEV__) {\n      console.log(\"Handling 'close' event with payload\", code, reason)\n    }\n    this.emitDeactivate()\n  }\n\n  private handleNetworkChanged(networkId: string | number): void {\n    if (__DEV__) {\n      console.log(\"Handling 'networkChanged' event with payload\", networkId)\n    }\n    this.emitUpdate({ chainId: networkId, provider: this.provider })\n  }\n\n  public async activate(): Promise<ConnectorUpdate> {\n    if (!this.provider) {\n      throw new NoEthereumProviderError()\n    }\n\n    if (this.provider.on) {\n      this.provider.on('chainChanged', this.handleChainChanged)\n      this.provider.on('accountsChanged', this.handleAccountsChanged)\n      this.provider.on('close', this.handleClose)\n      this.provider.on('networkChanged', this.handleNetworkChanged)\n    }\n\n    if ((this.provider as any).isMetaMask) {\n      ;(this.provider as any).autoRefreshOnNetworkChange = false\n    }\n\n    // try to activate + get account via eth_requestAccounts\n    let account\n    try {\n      account = await (this.provider.send as Send)('eth_requestAccounts').then(\n        sendReturn => parseSendReturn(sendReturn)[0]\n      )\n    } catch (error) {\n      if ((error as any).code === 4001) {\n        throw new UserRejectedRequestError()\n      }\n      warning(false, 'eth_requestAccounts was unsuccessful, falling back to enable')\n    }\n\n    // if unsuccessful, try enable\n    if (!account) {\n      // if enable is successful but doesn't return accounts, fall back to getAccount (not happy i have to do this...)\n      account = await this.provider.enable().then(sendReturn => sendReturn && parseSendReturn(sendReturn)[0])\n    }\n\n    return { provider: this.provider, ...(account ? { account } : {}) }\n  }\n\n  public async getProvider(): Promise<any> {\n    return this.provider\n  }\n\n  public async getChainId(): Promise<number | string> {\n    if (!this.provider) {\n      throw new NoEthereumProviderError()\n    }\n\n    let chainId\n    try {\n      chainId = await (this.provider.send as Send)('eth_chainId').then(parseSendReturn)\n    } catch {\n      warning(false, 'eth_chainId was unsuccessful, falling back to net_version')\n    }\n\n    if (!chainId) {\n      try {\n        chainId = await (this.provider.send as Send)('net_version').then(parseSendReturn)\n      } catch {\n        warning(false, 'net_version was unsuccessful, falling back to net version v2')\n      }\n    }\n\n    if (!chainId) {\n      try {\n        chainId = parseSendReturn((this.provider.send as SendOld)({ method: 'net_version' }))\n      } catch {\n        warning(false, 'net_version v2 was unsuccessful, falling back to manual matches and static properties')\n      }\n    }\n\n    if (!chainId) {\n      if ((this.provider as any).isDapper) {\n        chainId = parseSendReturn((this.provider as any).cachedResults.net_version)\n      } else {\n        chainId =\n          (this.provider as any).chainId || (this.provider as any).networkVersion || (this.provider as any)._chainId\n      }\n    }\n\n    return chainId\n  }\n\n  public async getAccount(): Promise<null | string> {\n    if (!this.provider) {\n      throw new NoEthereumProviderError()\n    }\n\n    let account\n    try {\n      account = await (this.provider.send as Send)('eth_accounts').then(sendReturn => parseSendReturn(sendReturn)[0])\n    } catch {\n      warning(false, 'eth_accounts was unsuccessful, falling back to enable')\n    }\n\n    if (!account) {\n      try {\n        account = await this.provider.enable().then(sendReturn => parseSendReturn(sendReturn)[0])\n      } catch {\n        warning(false, 'enable was unsuccessful, falling back to eth_accounts v2')\n      }\n    }\n\n    if (!account) {\n      account = parseSendReturn((this.provider.send as SendOld)({ method: 'eth_accounts' }))[0]\n    }\n\n    return account\n  }\n\n  public deactivate() {\n    if (this.provider && this.provider.removeListener) {\n      this.provider.removeListener('chainChanged', this.handleChainChanged)\n      this.provider.removeListener('accountsChanged', this.handleAccountsChanged)\n      this.provider.removeListener('close', this.handleClose)\n      this.provider.removeListener('networkChanged', this.handleNetworkChanged)\n    }\n  }\n\n  public async isAuthorized(): Promise<boolean> {\n    if (!this.provider) {\n      return false\n    }\n\n    try {\n      return await (this.provider.send as Send)('eth_accounts').then(sendReturn => {\n        if (parseSendReturn(sendReturn).length > 0) {\n          return true\n        } else {\n          return false\n        }\n      })\n    } catch {\n      return false\n    }\n  }\n}\n"]}