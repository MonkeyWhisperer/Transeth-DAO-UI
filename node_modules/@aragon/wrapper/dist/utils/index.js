"use strict";var _interopRequireDefault=require("@babel/runtime/helpers/interopRequireDefault");Object.defineProperty(exports,"__esModule",{value:!0// force cache invalidation
}),exports.ANY_ENTITY=void 0,Object.defineProperty(exports,"AsyncRequestCache",{enumerable:!0,get:function(){return _AsyncRequestCache.default}}),exports.addressesEqual=addressesEqual,exports.getCacheKey=getCacheKey,exports.includesAddress=includesAddress,exports.makeAddressMapProxy=makeAddressMapProxy,exports.makeProxy=makeProxy,exports.makeProxyFromABI=makeProxyFromABI,exports.makeProxyFromAppABI=makeProxyFromAppABI;var _web3Utils=require("web3-utils"),_proxy=_interopRequireDefault(require("../core/proxy")),_interfaces=require("../interfaces"),_AsyncRequestCache=_interopRequireDefault(require("./AsyncRequestCache"));const ANY_ENTITY="0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF";// Check address equality without checksums
exports.ANY_ENTITY="0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF";function addressesEqual(first,second){return first=first&&first.toLowerCase(),second=second&&second.toLowerCase(),first===second}// "Safer" version of [].includes() for addresses
function includesAddress(arr,address){return arr.some(a=>addressesEqual(a,address))}// Address map that ensures consistent non-checksummed interpretations of addresses
function makeAddressMapProxy(){let target=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};const targetLowerCaseKeys={};return Object.entries(target).forEach(_ref=>{let[address,val]=_ref;targetLowerCaseKeys[address.toLowerCase()]=val}),new Proxy(targetLowerCaseKeys,{get(target,property){return property in target?target[property]:"string"==typeof property&&(0,_web3Utils.isAddress)(property)?target[property.toLowerCase()]:void 0},set(target,property,value){return"string"==typeof property&&(0,_web3Utils.isAddress)(property)?target[property.toLowerCase()]=value:target[property]=value,!0}})}/**
 * Get a standard cache key
 *
 * @param {string} address
 * @param {string} location
 */function getCacheKey(address,location){return`${address}.${location}`}function makeProxy(address,interfaceName,web3,options){const abi=(0,_interfaces.getAbi)(`aragon/${interfaceName}`);return makeProxyFromABI(address,abi,web3,options)}const appProxyEventsAbi=(0,_interfaces.getAbi)("aragon/AppProxy").filter(_ref2=>{let{type}=_ref2;return"event"===type});function makeProxyFromAppABI(address,appAbi,web3,options){const appAbiWithProxyEvents=[].concat(appAbi,appProxyEventsAbi);return makeProxyFromABI(address,appAbiWithProxyEvents,web3,options)}function makeProxyFromABI(address,abi,web3,options){return new _proxy.default(address,abi,web3,options)}
//# sourceMappingURL=index.js.map