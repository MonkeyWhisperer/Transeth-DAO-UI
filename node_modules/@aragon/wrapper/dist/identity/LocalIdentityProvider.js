"use strict";var _interopRequireDefault=require("@babel/runtime/helpers/interopRequireDefault");Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var _cache=_interopRequireDefault(require("../cache")),_AddressIdentityProvider=_interopRequireDefault(require("./AddressIdentityProvider"));/**
 * An local identity provider for addresses
 *
 * @class LocalIdentityProvider
 */class LocalIdentityProvider extends _AddressIdentityProvider.default{/**
   * Create a new identity provider attached to a locally-stored cache.
   */constructor(){super(),this.identityCache=new _cache.default("localIdentity")}async init(){await this.identityCache.init()}/**
   * Resolve the locally-stored label for an address
   *
   * @param  {string} address Address to resolve
   * @return {Promise} Resolved metadata, null when not found, rejected on error
   */async resolve(address){return address=address.toLowerCase(),this.identityCache.get(address)}/**
   * Modify the locally-stored label of an address
   *
   * @param  {string} address  Address to resolve
   * @param  {Object} metadata Metadata to modify
   * @return {Promise} Resolved with saved address and metadata or rejected on error
   */async modify(address){let{name="",createdAt=Date.now()}=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};if(!name)throw new Error("name is required when modifying a local identity");address=address.toLowerCase();const metadata={name,createdAt};// First save it in the cache
return await this.identityCache.set(address,metadata),Promise.resolve({address,metadata})}/**
   * Search for matches in the locally-stored labels.
   *
   * If the search term starts with '0x', addresses will be matched for instead.
   *
   * @param  {string} searchTerm Search term
   * @return {Promise} Resolved with array of matches, each containing the address and name
   */async search(){let searchTerm=0<arguments.length&&arguments[0]!==void 0?arguments[0]:"";const isAddressSearch="0x"===searchTerm.substring(0,2).toLowerCase(),identities=await this.identityCache.getAll(),results=Object.entries(identities).filter(_ref=>{let[address,{name}]=_ref;return isAddressSearch&&3<searchTerm.length&&0===address.toLowerCase().indexOf(searchTerm.toLowerCase())||-1<name.toLowerCase().indexOf(searchTerm.toLowerCase())}).map(_ref2=>{let[address,{name}]=_ref2;return{name,address}});return results}/**
   * Get all local identities
   *
   * @return {Promise} Resolved with an object of all identities when completed
   */async getAll(){return this.identityCache.getAll()}/**
   * Remove a single identity from the local cache
   *
   * @return {Promise} Resolved when completed
   */async remove(address){await this.identityCache.remove(address.toLowerCase())}}exports.default=LocalIdentityProvider;
//# sourceMappingURL=LocalIdentityProvider.js.map