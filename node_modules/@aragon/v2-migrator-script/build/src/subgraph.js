"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const graphql_request_1 = require("graphql-request");
const ethers_1 = require("ethers");
const ZERO_ADDRESS = '0x0000000000000000000000000000000000000000';
const SUBGRAPH_URL = {
    rinkeby: 'https://api.thegraph.com/subgraphs/name/aragon/aragon-vault-rinkeby',
    mainnet: 'https://api.thegraph.com/subgraphs/name/aragon/aragon-vault-mainnet',
};
const Subgraph = {
    getAssets(network, dao) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = SUBGRAPH_URL[network];
            if (!url)
                throw Error(`Unknown network ${network}`);
            const result = yield graphql_request_1.request(url, `{
      tokenBalances (where: { vault: "${dao.vault.toLowerCase()}" }) {
        balance
        token {
          id
        }
      }
    }`);
            const provider = ethers_1.getDefaultProvider(network);
            let results = result.tokenBalances.map((balance) => __awaiter(this, void 0, void 0, function* () {
                if (balance.token.id == ZERO_ADDRESS) {
                    return provider.getBalance(dao.vault);
                }
                else {
                    const contract = new ethers_1.Contract(balance.token.id, [
                        'function balanceOf(address _who) public view returns (uint256)'
                    ], provider);
                    return contract.balanceOf(dao.vault);
                }
            }));
            results = yield Promise.all(results);
            return result.tokenBalances.map((balance, index) => {
                return { token: balance.token.id, amount: results[index] };
            }).filter((daoAsset) => daoAsset.amount != '0');
        });
    }
};
exports.default = Subgraph;
