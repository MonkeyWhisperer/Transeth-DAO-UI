{"version":3,"file":"asStream.js","sourceRoot":"","sources":["../src/asStream.ts"],"names":[],"mappings":";;;AAAA,mCAAgD;AAIhD,MAAM,qBAAyB,SAAQ,eAAY;IAKjD,YAAY,QAA4B;QACtC,KAAK,CAAC;YACJ,kCAAkC;YAClC,UAAU,EAAE,IAAI;SACjB,CAAC,CAAC;QACH,+BAA+B;QAC/B,IAAI,CAAC,MAAM,EAAE,CAAC;QACd,2CAA2C;QAC3C,IAAI,CAAC,OAAO,GAAG,CAAC,KAAQ,EAAE,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QAC9C,gCAAgC;QAChC,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;QACzB,IAAI,CAAC,QAAQ,CAAC,SAAS,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;IACxC,CAAC;IAED,wCAAwC;IACxC,IAAI,CACF,IAAO,EACP,OAA2B;QAE3B,MAAM,MAAM,GAAG,KAAK,CAAC,IAAI,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;QACzC,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,QAAQ,EAAS,CAAC,CAAC;QAC5C,OAAO,MAAM,CAAC;IAChB,CAAC;IAED,sCAAsC;IACtC,MAAM,CACJ,KAAU,EACV,SAAiB,EACjB,QAAwC;QAExC,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;QAC9B,QAAQ,EAAE,CAAC;IACb,CAAC;IAED,yEAAyE;IACzE,KAAK,CAAC,KAAa;QACjB,OAAO,SAAS,CAAC;IACnB,CAAC;IAED,iCAAiC;IACjC,QAAQ,CAAC,GAAiB,EAAE,QAAuC;QACjE,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;QACxC,KAAK,CAAC,QAAQ,CAAC,GAAG,EAAE,QAAQ,CAAC,CAAC;IAChC,CAAC;CACF;AAED,SAAgB,aAAa,CAC3B,QAA4B;IAE5B,OAAO,IAAI,qBAAqB,CAAC,QAAQ,CAAC,CAAC;AAC7C,CAAC;AAJD,sCAIC","sourcesContent":["import { Duplex as DuplexStream } from 'stream';\n\nimport { ObservableStore } from './ObservableStore';\n\nclass ObservableStoreStream<T> extends DuplexStream {\n  handler: (state: T) => void;\n\n  obsStore: ObservableStore<T>;\n\n  constructor(obsStore: ObservableStore<T>) {\n    super({\n      // pass values, not serializations\n      objectMode: true,\n    });\n    // dont buffer outgoing updates\n    this.resume();\n    // save handler so we can unsubscribe later\n    this.handler = (state: T) => this.push(state);\n    // subscribe to obsStore changes\n    this.obsStore = obsStore;\n    this.obsStore.subscribe(this.handler);\n  }\n\n  // emit current state on new destination\n  pipe<U extends NodeJS.WritableStream>(\n    dest: U,\n    options?: { end?: boolean },\n  ): U {\n    const result = super.pipe(dest, options);\n    dest.write(this.obsStore.getState() as any);\n    return result;\n  }\n\n  // write from incoming stream to state\n  _write(\n    chunk: any,\n    _encoding: string,\n    callback: (error?: Error | null) => void,\n  ): void {\n    this.obsStore.putState(chunk);\n    callback();\n  }\n\n  // noop - outgoing stream is asking us if we have data we arent giving it\n  _read(_size: number): void {\n    return undefined;\n  }\n\n  // unsubscribe from event emitter\n  _destroy(err: Error | null, callback: (error: Error | null) => void): void {\n    this.obsStore.unsubscribe(this.handler);\n    super._destroy(err, callback);\n  }\n}\n\nexport function storeAsStream<T>(\n  obsStore: ObservableStore<T>,\n): ObservableStoreStream<T> {\n  return new ObservableStoreStream(obsStore);\n}\n"]}