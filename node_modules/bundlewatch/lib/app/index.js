"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "STATUSES", {
  enumerable: true,
  get: function () {
    return _analyzeFiles.STATUSES;
  }
});
exports.default = void 0;

var _getLocalFileDetails = _interopRequireDefault(require("./getLocalFileDetails"));

var _BundleWatchService = _interopRequireDefault(require("./reporting/BundleWatchService"));

var _GitHubService = _interopRequireDefault(require("./reporting/GitHubService"));

var _analyze = _interopRequireDefault(require("./analyze"));

var _analyzeFiles = require("./analyze/analyzeFiles");

var _getConfig = _interopRequireDefault(require("./config/getConfig"));

var _createURL = _interopRequireDefault(require("./resultsPage/createURL"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const main = async ({
  files,
  bundlewatchServiceHost,
  ci,
  defaultCompression
}) => {
  const currentBranchFileDetails = (0, _getLocalFileDetails.default)({
    files,
    defaultCompression: defaultCompression
  });
  const bundlewatchService = new _BundleWatchService.default({
    repoOwner: ci.repoOwner,
    repoName: ci.repoName,
    repoCurrentBranch: ci.repoCurrentBranch,
    repoBranchBase: ci.repoBranchBase,
    commitSha: ci.commitSha,
    bundlewatchServiceHost,
    githubAccessToken: ci.githubAccessToken
  });
  const baseBranchFileDetails = await bundlewatchService.getFileDetailsForBaseBranch();
  await bundlewatchService.saveFileDetailsForCurrentBranch({
    fileDetailsByPath: currentBranchFileDetails,
    trackBranches: ci.trackBranches
  });
  const results = (0, _analyze.default)({
    currentBranchFileDetails,
    baseBranchFileDetails,
    baseBranchName: ci.repoBranchBase
  });
  const url = await (0, _createURL.default)({
    results,
    bundlewatchServiceHost,
    repoOwner: ci.repoOwner,
    repoName: ci.repoName,
    repoCurrentBranch: ci.repoCurrentBranch,
    repoBranchBase: ci.repoBranchBase,
    commitSha: ci.commitSha
  });
  return _objectSpread(_objectSpread({}, results), {}, {
    url
  });
};

const bundlewatchApi = async customConfig => {
  const config = (0, _getConfig.default)(customConfig);
  const githubService = new _GitHubService.default({
    repoOwner: config.ci.repoOwner,
    repoName: config.ci.repoName,
    commitSha: config.ci.commitSha,
    githubAccessToken: config.ci.githubAccessToken
  });
  await githubService.start({
    message: 'Checking bundlewatch...'
  });

  try {
    const results = await main(config);

    if (results.status === _analyzeFiles.STATUSES.FAIL) {
      await githubService.fail({
        message: results.summary,
        url: results.url
      });
      await Promise.all(results.fullResults.map(result => {
        if (result.status === _analyzeFiles.STATUSES.FAIL) {
          return githubService.fail({
            message: result.message,
            filePath: result.filePath
          });
        }

        return Promise.resolve();
      }));
    } else {
      // TODO: add warn
      await githubService.pass({
        message: results.summary,
        url: results.url
      });
    }

    return results;
  } catch (e) {
    await githubService.error({
      message: `Unable to analyze, check logs. ${e ? e.messsage : ''}`
    });
    throw e;
  }
};

var _default = bundlewatchApi;
exports.default = _default;