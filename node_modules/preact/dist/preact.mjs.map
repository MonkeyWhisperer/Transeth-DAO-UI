{"version":3,"file":"preact.mjs","sources":["../src/constants.js","../src/options.js","../src/diff/catch-error.js","../src/diff/commit.js","../src/create-element.js","../src/diff/refs.js","../src/diff/props.js","../src/create-context.js","../src/diff/unmount.js","../src/tree.js","../src/diff/children.js","../src/diff/patch.js","../src/component.js","../src/diff/component.js","../src/diff/mount.js","../src/render.js","../src/create-root.js","../src/clone-element.js"],"sourcesContent":["// Internal._flags bitfield constants\nexport const TYPE_TEXT = 1 << 0;\nexport const TYPE_ELEMENT = 1 << 1;\nexport const TYPE_CLASS = 1 << 2;\nexport const TYPE_FUNCTION = 1 << 3;\n/** Signals this internal has a _parentDom prop that should change the parent\n * DOM node of it's children */\nexport const TYPE_ROOT = 1 << 4;\n\n/** Any type of internal representing DOM */\nexport const TYPE_DOM = TYPE_TEXT | TYPE_ELEMENT;\n/** Any type of component */\nexport const TYPE_COMPONENT = TYPE_CLASS | TYPE_FUNCTION | TYPE_ROOT;\n\n// Modes of rendering\n/** Normal hydration that attaches to a DOM tree but does not diff it. */\nexport const MODE_HYDRATE = 1 << 5;\n/** Top level render unspecified behaviour (old replaceNode parameter to render) */\nexport const MODE_MUTATIVE_HYDRATE = 1 << 6;\n/** Signifies this VNode suspended on the previous render */\nexport const MODE_SUSPENDED = 1 << 7;\n/** Signifies this VNode errored on the previous render */\nexport const MODE_ERRORED = 1 << 8;\n/** Signifies an error has been thrown and this component will be attempting to\n * handle & rerender the error on next render. In other words, on the next\n * render of this component, unset this mode and set the MODE_RERENDERING_ERROR.\n * This flag is distinct from MODE_RERENDERING_ERROR so that a component can\n * catch multiple errors thrown by its children in one render pass (see test\n * \"should handle double child throws\").\n */\nexport const MODE_PENDING_ERROR = 1 << 9;\n/** Signifies this Internal is attempting to \"handle\" an error and is\n * rerendering. This mode tracks that a component's last rerender was trying to\n * handle an error. As such, if another error is thrown while a component has\n * this flag set, it should not handle the newly thrown error since it failed to\n * successfully rerender the original error. This prevents error handling\n * infinite render loops */\nexport const MODE_RERENDERING_ERROR = 1 << 10;\n/** Signals this internal has been unmounted */\nexport const MODE_UNMOUNTING = 1 << 11;\n/** This Internal is rendered in an SVG tree */\nexport const MODE_SVG = 1 << 12;\n\n/** Signifies that bailout checks will be bypassed */\nexport const FORCE_UPDATE = 1 << 13;\n/** Signifies that a node needs to be updated */\nexport const DIRTY_BIT = 1 << 14;\n\n/** Reset all mode flags */\nexport const RESET_MODE = ~(\n\tMODE_HYDRATE |\n\tMODE_MUTATIVE_HYDRATE |\n\tMODE_SUSPENDED |\n\tMODE_ERRORED |\n\tMODE_RERENDERING_ERROR |\n\tFORCE_UPDATE\n);\n\n/** Modes a child internal inherits from their parent */\nexport const INHERITED_MODES = MODE_HYDRATE | MODE_MUTATIVE_HYDRATE | MODE_SVG;\n\nexport const EMPTY_ARR = [];\nexport const UNDEFINED = undefined;\n","import { _catchError } from './diff/catch-error';\n\n/**\n * The `option` object can potentially contain callback functions\n * that are called during various stages of our renderer. This is the\n * foundation on which all our addons like `preact/debug`, `preact/compat`,\n * and `preact/hooks` are based on. See the `Options` type in `internal.d.ts`\n * for a full list of available option hooks (most editors/IDEs allow you to\n * ctrl+click or cmd+click on mac the type definition below).\n * @type {import('./internal').Options}\n */\nconst options = {\n\t_catchError\n};\n\nexport default options;\n","import {\n\tDIRTY_BIT,\n\tMODE_RERENDERING_ERROR,\n\tMODE_PENDING_ERROR,\n\tTYPE_COMPONENT\n} from '../constants';\n\n/**\n * Find the closest error boundary to a thrown error and call it\n * @param {object} error The thrown value\n * @param {import('../internal').Internal} internal The Internal node that threw\n * the error that was caught (except for unmounting when this parameter\n * is the highest parent that was being unmounted)\n */\nexport function _catchError(error, internal) {\n\twhile ((internal = internal._parent)) {\n\t\tif (\n\t\t\tinternal._flags & TYPE_COMPONENT &&\n\t\t\t~internal._flags & MODE_RERENDERING_ERROR\n\t\t) {\n\t\t\ttry {\n\t\t\t\tif (internal.type.getDerivedStateFromError) {\n\t\t\t\t\tinternal._component.setState(\n\t\t\t\t\t\tinternal.type.getDerivedStateFromError(error)\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif (internal._component.componentDidCatch) {\n\t\t\t\t\tinternal._component.componentDidCatch(error);\n\t\t\t\t}\n\n\t\t\t\t// NOTE: We're checking that any component in the stack got marked as dirty, even if it did so prior to this loop,\n\t\t\t\t// which is technically incorrect. However, there is no way for a component to mark itself as dirty during rendering.\n\t\t\t\t// The only way for a component to falsely intercept error bubbling would be to manually sets its internal dirty flag.\n\t\t\t\tif (internal._flags & DIRTY_BIT) {\n\t\t\t\t\tinternal._flags |= MODE_PENDING_ERROR;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\terror = e;\n\t\t\t}\n\t\t}\n\t}\n\n\tthrow error;\n}\n","import options from '../options';\n\n/**\n * @param {import('../internal').Internal} internal\n * @param {() => void} callback\n */\nexport function addCommitCallback(internal, callback) {\n\tif (internal._commitCallbacks == null) {\n\t\tinternal._commitCallbacks = [];\n\t}\n\n\tinternal._commitCallbacks.push(callback);\n}\n\n/**\n * @param {import('../internal').CommitQueue} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {import('../internal').Internal} rootInternal\n */\nexport function commitRoot(commitQueue, rootInternal) {\n\tif (options._commit) options._commit(rootInternal, commitQueue);\n\n\tcommitQueue.some(internal => {\n\t\ttry {\n\t\t\t// @ts-ignore Reuse the root variable here so the type changes\n\t\t\tcommitQueue = internal._commitCallbacks.length;\n\t\t\t// @ts-ignore See above ts-ignore comment\n\t\t\twhile (commitQueue--) {\n\t\t\t\tinternal._commitCallbacks.shift().call(internal._component);\n\t\t\t}\n\t\t} catch (e) {\n\t\t\toptions._catchError(e, internal);\n\t\t}\n\t});\n}\n","import { UNDEFINED } from './constants';\nimport options from './options';\n\nlet vnodeId = 0;\n\n/**\n * Create an virtual node (used for JSX)\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component\n * constructor for this virtual node\n * @param {object | null | undefined} [props] The properties of the virtual node\n * @param {Array<import('.').ComponentChildren>} [children] The children of the virtual node\n * @returns {import('./internal').VNode}\n */\nexport function createElement(type, props, children) {\n\tlet normalizedProps = {},\n\t\tkey,\n\t\tref,\n\t\ti;\n\tfor (i in props) {\n\t\tif (!(i === 'key' || (typeof type !== 'function' && i === 'ref')))\n\t\t\tnormalizedProps[i] = props[i];\n\t\telse if (i === 'ref') {\n\t\t\tref = props[i];\n\t\t} else if (i === 'key') {\n\t\t\tkey = props[i];\n\t\t}\n\t}\n\n\tif (arguments.length > 3) {\n\t\tchildren = [children];\n\t\t// https://github.com/preactjs/preact/issues/1916\n\t\tfor (i = 3; i < arguments.length; i++) {\n\t\t\tchildren.push(arguments[i]);\n\t\t}\n\t}\n\tif (children != null) {\n\t\tnormalizedProps.children = children;\n\t}\n\n\t// If a Component VNode, check for and apply defaultProps\n\t// Note: type may be undefined in development, must never error here.\n\tif (typeof type == 'function' && type.defaultProps != null) {\n\t\tfor (i in type.defaultProps) {\n\t\t\tif (normalizedProps[i] === UNDEFINED) {\n\t\t\t\tnormalizedProps[i] = type.defaultProps[i];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn createVNode(type, normalizedProps, key, ref, 0);\n}\n\n/**\n * Create a VNode (used internally by Preact)\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component\n * Constructor for this virtual node\n * @param {object | string | number | null} props The properties of this virtual node.\n * If this virtual node represents a text node, this is the text of the node (string or number).\n * @param {string | number | null} key The key for this virtual node, used when\n * diffing it against its children\n * @param {import('./internal').VNode[\"ref\"]} ref The ref property that will\n * receive a reference to its created child\n * @returns {import('./internal').VNode}\n */\nexport function createVNode(type, props, key, ref, original) {\n\t// V8 seems to be better at detecting type shapes if the object is allocated from the same call site\n\t// Do not inline into createElement and coerceToVNode!\n\tconst vnode = {\n\t\ttype,\n\t\tprops,\n\t\tkey,\n\t\tref,\n\t\tconstructor: undefined,\n\t\t_vnodeId: original || ++vnodeId\n\t};\n\n\tif (options.vnode != null) options.vnode(vnode);\n\n\treturn vnode;\n}\n\n/**\n * @param {import('./internal').ComponentChildren} childVNode\n * @returns {import('./internal').VNode | string | null}\n */\nexport function normalizeToVNode(childVNode) {\n\tif (childVNode == null || typeof childVNode == 'boolean') {\n\t\treturn null;\n\t}\n\t// If this newVNode is being reused (e.g. <div>{reuse}{reuse}</div>) in the same diff,\n\t// or we are rendering a component (e.g. setState) copy the oldVNodes so it can have\n\t// it's own DOM & etc. pointers\n\telse if (\n\t\ttypeof childVNode == 'number' ||\n\t\t// eslint-disable-next-line valid-typeof\n\t\ttypeof childVNode == 'bigint'\n\t) {\n\t\treturn childVNode + '';\n\t} else if (Array.isArray(childVNode)) {\n\t\treturn createVNode(Fragment, { children: childVNode }, null, null, 0);\n\t}\n\n\treturn childVNode;\n}\n\nexport function createRef() {\n\treturn { current: null };\n}\n\nexport function Fragment(props) {\n\treturn props.children;\n}\n\n/**\n * Check if a the argument is a valid Preact VNode.\n * @param {*} vnode\n * @returns {vnode is import('./internal').VNode}\n */\nexport const isValidElement = vnode =>\n\tvnode != null && vnode.constructor === UNDEFINED;\n","import options from '../options';\n\n/**\n * Invoke or update a ref, depending on whether it is a function or object ref.\n * @param {object|function} ref\n * @param {any} value\n * @param {import('../internal').Internal} internal\n */\nexport function applyRef(oldRef, ref, value, internal) {\n\tif (oldRef === ref) return;\n\n\tif (oldRef) applyRef(null, oldRef, null, internal);\n\ttry {\n\t\tif (typeof ref == 'function') ref(value);\n\t\telse ref.current = value;\n\t} catch (e) {\n\t\toptions._catchError(e, internal);\n\t}\n}\n","import options from '../options';\n\nfunction setStyle(style, key, value) {\n\tif (key[0] === '-') {\n\t\tstyle.setProperty(key, value);\n\t} else if (value == null) {\n\t\tstyle[key] = '';\n\t} else {\n\t\tstyle[key] = value;\n\t}\n}\n\n/**\n * Set a property value on a DOM node\n * @param {import('../internal').PreactElement} dom The DOM node to modify\n * @param {string} name The name of the property to set\n * @param {*} value The value to set the property to\n * @param {*} oldValue The old value the property had\n * @param {number} isSvg 0 if not an SVG element, else it is an SVG element\n */\nexport function setProperty(dom, name, value, oldValue, isSvg) {\n\tlet useCapture;\n\n\to: if (name === 'style') {\n\t\tif (typeof value == 'string') {\n\t\t\tdom.style.cssText = value;\n\t\t} else {\n\t\t\tif (typeof oldValue == 'string') {\n\t\t\t\tdom.style.cssText = oldValue = '';\n\t\t\t}\n\n\t\t\tif (oldValue) {\n\t\t\t\tfor (name in oldValue) {\n\t\t\t\t\tif (!(value && name in value)) {\n\t\t\t\t\t\tsetStyle(dom.style, name, '');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (value) {\n\t\t\t\tfor (name in value) {\n\t\t\t\t\tif (!oldValue || value[name] !== oldValue[name]) {\n\t\t\t\t\t\tsetStyle(dom.style, name, value[name]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// Benchmark for comparison: https://esbench.com/bench/574c954bdb965b9a00965ac6\n\telse if (name[0] === 'o' && name[1] === 'n') {\n\t\tuseCapture = name !== (name = name.replace(/Capture$/, ''));\n\n\t\t// Infer correct casing for DOM built-in events:\n\t\tif (name.toLowerCase() in dom) name = name.toLowerCase().slice(2);\n\t\telse name = name.slice(2);\n\n\t\tif (!dom._listeners) dom._listeners = {};\n\t\tdom._listeners[name + useCapture] = value;\n\n\t\tif (value) {\n\t\t\tif (!oldValue) {\n\t\t\t\tconst handler = useCapture ? eventProxyCapture : eventProxy;\n\t\t\t\tdom.addEventListener(name, handler, useCapture);\n\t\t\t}\n\t\t} else {\n\t\t\tconst handler = useCapture ? eventProxyCapture : eventProxy;\n\t\t\tdom.removeEventListener(name, handler, useCapture);\n\t\t}\n\t} else if (name !== 'dangerouslySetInnerHTML') {\n\t\tif (isSvg) {\n\t\t\t// Normalize incorrect prop usage for SVG:\n\t\t\t// - xlink:href / xlinkHref --> href (xlink:href was removed from SVG and isn't needed)\n\t\t\t// - className --> class\n\t\t\tname = name.replace(/xlink[H:h]/, 'h').replace(/sName$/, 's');\n\t\t} else if (\n\t\t\tname !== 'href' &&\n\t\t\tname !== 'list' &&\n\t\t\tname !== 'form' &&\n\t\t\t// Default value in browsers is `-1` and an empty string is\n\t\t\t// cast to `0` instead\n\t\t\tname !== 'tabIndex' &&\n\t\t\tname !== 'download' &&\n\t\t\tname in dom\n\t\t) {\n\t\t\ttry {\n\t\t\t\tdom[name] = value == null ? '' : value;\n\t\t\t\t// labelled break is 1b smaller here than a return statement (sorry)\n\t\t\t\tbreak o;\n\t\t\t} catch (e) {}\n\t\t}\n\n\t\t// ARIA-attributes have a different notion of boolean values.\n\t\t// The value `false` is different from the attribute not\n\t\t// existing on the DOM, so we can't remove it. For non-boolean\n\t\t// ARIA-attributes we could treat false as a removal, but the\n\t\t// amount of exceptions would cost us too many bytes. On top of\n\t\t// that other VDOM frameworks also always stringify `false`.\n\n\t\tif (typeof value === 'function') {\n\t\t\t// never serialize functions as attribute values\n\t\t} else if (\n\t\t\tvalue != null &&\n\t\t\t(value !== false || (name[0] === 'a' && name[1] === 'r'))\n\t\t) {\n\t\t\tdom.setAttribute(name, value);\n\t\t} else {\n\t\t\tdom.removeAttribute(name);\n\t\t}\n\t}\n}\n\n/**\n * Proxy an event to hooked event handlers\n * @param {Event} e The event object from the browser\n * @private\n */\nfunction eventProxy(e) {\n\tthis._listeners[e.type + false](options.event ? options.event(e) : e);\n\tif (this._isControlled) {\n\t\tif (this.value != null && (e.type === 'input' || e.type === 'change')) {\n\t\t\tthis.value = this._prevValue;\n\t\t}\n\t\tif (this.checked != null && e.type === 'change') {\n\t\t\tthis.checked = this._prevValue;\n\t\t}\n\t}\n}\n\nfunction eventProxyCapture(e) {\n\tthis._listeners[e.type + true](options.event ? options.event(e) : e);\n}\n","import { enqueueRender } from './component';\n\nexport let nextContextId = 0;\n\nconst providers = new Set();\n\nexport const unsubscribeFromContext = component => {\n\t// if this was a context provider, delete() returns true and we exit:\n\tif (providers.delete(component)) return;\n\t// ... otherwise, unsubscribe from any contexts:\n\tproviders.forEach(p => p._subs.delete(component));\n};\n\nexport const createContext = (defaultValue, contextId) => {\n\tcontextId = '__cC' + nextContextId++;\n\n\tconst context = {\n\t\t_id: contextId,\n\t\t_defaultValue: defaultValue,\n\t\t/** @type {import('./internal').FunctionComponent} */\n\t\tConsumer(props, contextValue) {\n\t\t\t// return props.children(\n\t\t\t// \tcontext[contextId] ? context[contextId].props.value : defaultValue\n\t\t\t// );\n\t\t\treturn props.children(contextValue);\n\t\t},\n\t\t/** @type {import('./internal').FunctionComponent} */\n\t\tProvider(props, ctx) {\n\t\t\t// initial setup:\n\t\t\tif (!this._subs) {\n\t\t\t\tthis._subs = new Set();\n\t\t\t\tctx = {};\n\t\t\t\tctx[contextId] = this;\n\t\t\t\tthis.getChildContext = () => ctx;\n\t\t\t}\n\t\t\t// re-render subscribers in response to value change\n\t\t\telse if (props.value !== this._prev) {\n\t\t\t\tthis._subs.forEach(enqueueRender);\n\t\t\t}\n\t\t\tthis._prev = props.value;\n\n\t\t\treturn props.children;\n\t\t}\n\t};\n\n\t// Devtools needs access to the context object when it\n\t// encounters a Provider. This is necessary to support\n\t// setting `displayName` on the context object instead\n\t// of on the component itself. See:\n\t// https://reactjs.org/docs/context.html#contextdisplayname\n\n\treturn (context.Provider._contextRef = context.Consumer.contextType = context);\n};\n","import { MODE_UNMOUNTING, TYPE_DOM, TYPE_ROOT } from '../constants';\nimport { unsubscribeFromContext } from '../create-context';\nimport options from '../options';\nimport { applyRef } from './refs';\n\n/**\n * Unmount a virtual node from the tree and apply DOM changes\n * @param {import('../internal').Internal} internal The virtual node to unmount\n * @param {import('../internal').Internal} parentInternal The parent of the VNode that\n * initiated the unmount\n * @param {number} [skipRemove] Flag that indicates that a parent node of the\n * current element is already detached from the DOM.\n */\nexport function unmount(internal, parentInternal, skipRemove) {\n\tlet r,\n\t\ti = 0;\n\tif (options.unmount) options.unmount(internal);\n\tinternal._flags |= MODE_UNMOUNTING;\n\n\tif ((r = internal.ref)) {\n\t\tif (!r.current || r.current === internal._dom)\n\t\t\tapplyRef(null, r, null, parentInternal);\n\t}\n\n\tif ((r = internal._component)) {\n\t\tunsubscribeFromContext(r);\n\n\t\tif (r.componentWillUnmount) {\n\t\t\ttry {\n\t\t\t\tr.componentWillUnmount();\n\t\t\t} catch (e) {\n\t\t\t\toptions._catchError(e, parentInternal);\n\t\t\t}\n\t\t}\n\t}\n\n\tif ((r = internal._children)) {\n\t\tfor (; i < r.length; i++) {\n\t\t\tif (r[i]) {\n\t\t\t\tunmount(\n\t\t\t\t\tr[i],\n\t\t\t\t\tparentInternal,\n\t\t\t\t\tskipRemove ? ~internal._flags & TYPE_ROOT : internal._flags & TYPE_DOM\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!skipRemove && internal._flags & TYPE_DOM) {\n\t\tinternal._dom.remove();\n\t}\n\n\tinternal._dom = null;\n}\n","import options from './options';\nimport {\n\tTYPE_FUNCTION,\n\tTYPE_ELEMENT,\n\tTYPE_TEXT,\n\tTYPE_CLASS,\n\tTYPE_ROOT,\n\tINHERITED_MODES,\n\tTYPE_COMPONENT,\n\tTYPE_DOM,\n\tMODE_SVG,\n\tUNDEFINED\n} from './constants';\n\n/**\n * Create an internal tree node\n * @param {import('./internal').VNode | string} vnode\n * @param {import('./internal').Internal} [parentInternal]\n * @returns {import('./internal').Internal}\n */\nexport function createInternal(vnode, parentInternal) {\n\tlet type = null,\n\t\tprops,\n\t\tkey,\n\t\tref;\n\n\t/** @type {number} */\n\tlet flags = parentInternal ? parentInternal._flags & INHERITED_MODES : 0;\n\n\t// Text VNodes/Internals use NaN as an ID so that two are never equal.\n\tlet vnodeId = NaN;\n\n\tif (typeof vnode === 'string') {\n\t\t// type = null;\n\t\tflags |= TYPE_TEXT;\n\t\tprops = vnode;\n\t} else if (vnode.constructor !== UNDEFINED) {\n\t\tflags |= TYPE_TEXT;\n\t\tprops = '';\n\t} else {\n\t\ttype = vnode.type;\n\t\tprops = vnode.props || {};\n\t\tkey = vnode.key;\n\t\tref = vnode.ref;\n\t\tvnodeId = vnode._vnodeId;\n\n\t\t// @TODO re-enable this when we stop removing key+ref from VNode props\n\t\t// if (props) {\n\t\t// \tif ((key = props.key) != null) {\n\t\t// \t\tprops.key = UNDEFINED;\n\t\t// \t}\n\t\t// \tif (typeof type !== 'function' && (ref = props.ref) != null) {\n\t\t// \t\tprops.ref = UNDEFINED;\n\t\t// \t}\n\t\t// } else {\n\t\t// \tprops = {};\n\t\t// }\n\n\t\t// flags = typeof type === 'function' ? COMPONENT_NODE : ELEMENT_NODE;\n\t\tflags |=\n\t\t\ttypeof type === 'function'\n\t\t\t\t? type.prototype && 'render' in type.prototype\n\t\t\t\t\t? TYPE_CLASS\n\t\t\t\t\t: props._parentDom\n\t\t\t\t\t? TYPE_ROOT\n\t\t\t\t\t: TYPE_FUNCTION\n\t\t\t\t: TYPE_ELEMENT;\n\n\t\tif (flags & TYPE_ELEMENT && type === 'svg') {\n\t\t\tflags |= MODE_SVG;\n\t\t} else if (\n\t\t\tparentInternal &&\n\t\t\tparentInternal._flags & MODE_SVG &&\n\t\t\tparentInternal.type === 'foreignObject'\n\t\t) {\n\t\t\tflags &= ~MODE_SVG;\n\t\t}\n\t}\n\n\t/** @type {import('./internal').Internal} */\n\tconst internal = {\n\t\ttype,\n\t\tprops,\n\t\tkey,\n\t\tref,\n\t\t_children: null,\n\t\t_parent: parentInternal,\n\t\t_vnodeId: vnodeId,\n\t\t_dom: null,\n\t\t_component: null,\n\t\t_flags: flags,\n\t\t_depth: parentInternal ? parentInternal._depth + 1 : 0\n\t};\n\n\tif (options._internal) options._internal(internal, vnode);\n\n\treturn internal;\n}\n\nconst shouldSearchComponent = internal =>\n\tinternal._flags & TYPE_COMPONENT &&\n\t(!(internal._flags & TYPE_ROOT) ||\n\t\tinternal.props._parentDom == getParentDom(internal._parent));\n\n/**\n * @param {import('./internal').Internal} internal\n * @param {number | null} [childIndex]\n * @returns {import('./internal').PreactNode}\n */\nexport function getDomSibling(internal, childIndex) {\n\tif (childIndex == null) {\n\t\t// Use childIndex==null as a signal to resume the search from the vnode's sibling\n\t\treturn getDomSibling(\n\t\t\tinternal._parent,\n\t\t\tinternal._parent._children.indexOf(internal) + 1\n\t\t);\n\t}\n\n\tlet childDom = getChildDom(internal, childIndex);\n\tif (childDom) {\n\t\treturn childDom;\n\t}\n\n\t// If we get here, we have not found a DOM node in this vnode's children. We\n\t// must resume from this vnode's sibling (in it's parent _children array).\n\t// Only climb up and search the parent if we aren't searching through a DOM\n\t// VNode (meaning we reached the DOM parent of the original vnode that began\n\t// the search). Note, the top of the tree has _parent == null so avoiding that\n\t// here.\n\treturn internal._parent && shouldSearchComponent(internal)\n\t\t? getDomSibling(internal)\n\t\t: null;\n}\n\n/**\n * @param {import('./internal').Internal} internal\n * @param {number} [i]\n * @returns {import('./internal').PreactElement}\n */\nexport function getChildDom(internal, i) {\n\tif (internal._children == null) {\n\t\treturn null;\n\t}\n\n\tfor (i = i || 0; i < internal._children.length; i++) {\n\t\tlet child = internal._children[i];\n\t\tif (child != null) {\n\t\t\tif (child._flags & TYPE_DOM) {\n\t\t\t\treturn child._dom;\n\t\t\t}\n\n\t\t\tif (shouldSearchComponent(child)) {\n\t\t\t\tlet childDom = getChildDom(child);\n\t\t\t\tif (childDom) {\n\t\t\t\t\treturn childDom;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn null;\n}\n\n/**\n * @param {import('./internal').Internal} internal\n * @returns {import('./internal').PreactElement}\n */\nexport function getParentDom(internal) {\n\tlet parentDom =\n\t\tinternal._flags & TYPE_ROOT ? internal.props._parentDom : null;\n\n\tlet parent = internal._parent;\n\twhile (parentDom == null && parent) {\n\t\tif (parent._flags & TYPE_ROOT) {\n\t\t\tparentDom = parent.props._parentDom;\n\t\t} else if (parent._flags & TYPE_ELEMENT) {\n\t\t\tparentDom = parent._dom;\n\t\t}\n\n\t\tparent = parent._parent;\n\t}\n\n\treturn parentDom;\n}\n","import { applyRef } from './refs';\nimport { normalizeToVNode } from '../create-element';\nimport {\n\tTYPE_COMPONENT,\n\tTYPE_TEXT,\n\tMODE_HYDRATE,\n\tMODE_SUSPENDED,\n\tEMPTY_ARR,\n\tTYPE_DOM,\n\tUNDEFINED\n} from '../constants';\nimport { mount } from './mount';\nimport { patch } from './patch';\nimport { unmount } from './unmount';\nimport { createInternal, getDomSibling, getChildDom } from '../tree';\n\n/**\n * Diff the children of a virtual node\n * @param {import('../internal').PreactElement} parentDom The DOM element whose\n * children are being diffed\n * @param {import('../internal').ComponentChildren[]} renderResult\n * @param {import('../internal').Internal} parentInternal The Internal node\n * whose children should be diff'ed against newParentVNode\n * @param {object} globalContext The current context object - modified by\n * getChildContext\n * @param {import('../internal').CommitQueue} commitQueue List of\n * components which have callbacks to invoke in commitRoot\n * @param {import('../internal').PreactElement} startDom The dom node\n * diffChildren should begin diffing with.\n */\nexport function diffChildren(\n\tparentDom,\n\trenderResult,\n\tparentInternal,\n\tglobalContext,\n\tcommitQueue,\n\tstartDom\n) {\n\tlet i, newDom, refs;\n\n\t/** @type {import('../internal').Internal} */\n\tlet childInternal;\n\n\t/** @type {import('../internal').VNode | string} */\n\tlet childVNode;\n\n\tlet oldChildren =\n\t\t(parentInternal._children && parentInternal._children.slice()) || EMPTY_ARR;\n\tlet oldChildrenLength = oldChildren.length;\n\n\tconst newChildren = [];\n\tfor (i = 0; i < renderResult.length; i++) {\n\t\tchildVNode = normalizeToVNode(renderResult[i]);\n\n\t\t// Terser removes the `continue` here and wraps the loop body\n\t\t// in a `if (childVNode) { ... } condition\n\t\tif (childVNode == null) {\n\t\t\tnewChildren[i] = null;\n\t\t\tcontinue;\n\t\t}\n\n\t\tchildInternal = findMatchingInternal(\n\t\t\tchildVNode,\n\t\t\toldChildren,\n\t\t\ti,\n\t\t\toldChildrenLength\n\t\t);\n\n\t\tlet oldVNodeRef;\n\t\tlet nextDomSibling;\n\t\tif (childInternal == null) {\n\t\t\tchildInternal = createInternal(childVNode, parentInternal);\n\n\t\t\t// We are mounting a new VNode\n\t\t\tnextDomSibling = mount(\n\t\t\t\tparentDom,\n\t\t\t\tchildVNode,\n\t\t\t\tchildInternal,\n\t\t\t\tglobalContext,\n\t\t\t\tcommitQueue,\n\t\t\t\tstartDom\n\t\t\t);\n\t\t}\n\t\t// If this node suspended during hydration, and no other flags are set:\n\t\t// @TODO: might be better to explicitly check for MODE_ERRORED here.\n\t\telse if (\n\t\t\t(childInternal._flags & (MODE_HYDRATE | MODE_SUSPENDED)) ===\n\t\t\t(MODE_HYDRATE | MODE_SUSPENDED)\n\t\t) {\n\t\t\t// We are resuming the hydration of a VNode\n\t\t\tstartDom = childInternal._dom;\n\t\t\toldVNodeRef = childInternal.ref;\n\n\t\t\tnextDomSibling = mount(\n\t\t\t\tparentDom,\n\t\t\t\tchildVNode,\n\t\t\t\tchildInternal,\n\t\t\t\tglobalContext,\n\t\t\t\tcommitQueue,\n\t\t\t\tstartDom\n\t\t\t);\n\t\t} else {\n\t\t\toldVNodeRef = childInternal.ref;\n\n\t\t\t// Morph the old element into the new one, but don't append it to the dom yet\n\t\t\tnextDomSibling = patch(\n\t\t\t\tparentDom,\n\t\t\t\tchildVNode,\n\t\t\t\tchildInternal,\n\t\t\t\tglobalContext,\n\t\t\t\tcommitQueue,\n\t\t\t\tstartDom\n\t\t\t);\n\t\t}\n\n\t\tnewDom = childInternal._dom;\n\n\t\tif (childVNode.ref) {\n\t\t\tif (!refs) refs = [];\n\t\t\trefs.push(\n\t\t\t\toldVNodeRef,\n\t\t\t\tchildVNode.ref,\n\t\t\t\tchildInternal._component || newDom,\n\t\t\t\tchildInternal\n\t\t\t);\n\t\t}\n\n\t\tif (childInternal._flags & TYPE_COMPONENT) {\n\t\t\tstartDom = nextDomSibling;\n\t\t} else if (newDom && newDom == startDom) {\n\t\t\t// If the newDom and the dom we are expecting to be there are the same, then\n\t\t\t// do nothing\n\t\t\tstartDom = nextDomSibling;\n\t\t} else if (newDom) {\n\t\t\tstartDom = placeChild(parentDom, oldChildrenLength, newDom, startDom);\n\t\t} else if (\n\t\t\tstartDom &&\n\t\t\tchildInternal != null &&\n\t\t\tstartDom.parentNode != parentDom\n\t\t) {\n\t\t\t// The above condition is to handle null placeholders. See test in placeholder.test.js:\n\t\t\t// `efficiently replace null placeholders in parent rerenders`\n\t\t\tstartDom = nextDomSibling;\n\t\t}\n\n\t\tnewChildren[i] = childInternal;\n\t}\n\n\tparentInternal._children = newChildren;\n\n\t// Remove remaining oldChildren if there are any.\n\tfor (i = oldChildrenLength; i--; ) {\n\t\tif (oldChildren[i] != null) {\n\t\t\tif (\n\t\t\t\tparentInternal._flags & TYPE_COMPONENT &&\n\t\t\t\tstartDom != null &&\n\t\t\t\t((oldChildren[i]._flags & TYPE_DOM &&\n\t\t\t\t\toldChildren[i]._dom == startDom) ||\n\t\t\t\t\tgetChildDom(oldChildren[i]) == startDom)\n\t\t\t) {\n\t\t\t\t// If the startDom points to a dom node that is about to be unmounted,\n\t\t\t\t// then get the next sibling of that vnode and set startDom to it\n\t\t\t\tstartDom = getDomSibling(parentInternal, i + 1);\n\t\t\t}\n\n\t\t\tunmount(oldChildren[i], oldChildren[i]);\n\t\t}\n\t}\n\n\t// Set refs only after unmount\n\tif (refs) {\n\t\tfor (i = 0; i < refs.length; i++) {\n\t\t\tapplyRef(refs[i], refs[++i], refs[++i], refs[++i]);\n\t\t}\n\t}\n\n\treturn startDom;\n}\n\n/**\n * @param {import('../internal').VNode | string} childVNode\n * @param {import('../internal').Internal[]} oldChildren\n * @param {number} i\n * @param {number} oldChildrenLength\n * @returns {import('../internal').Internal}\n */\nfunction findMatchingInternal(childVNode, oldChildren, i, oldChildrenLength) {\n\t// Check if we find a corresponding element in oldChildren.\n\t// If found, delete the array item by setting to `undefined`.\n\t// We use `undefined`, as `null` is reserved for empty placeholders\n\t// (holes).\n\tlet childInternal = oldChildren[i];\n\n\tif (typeof childVNode === 'string') {\n\t\t// We never move Text nodes, so we only check for an in-place match:\n\t\tif (childInternal && childInternal._flags & TYPE_TEXT) {\n\t\t\toldChildren[i] = UNDEFINED;\n\t\t} else {\n\t\t\t// We're looking for a Text node, but this wasn't one: ignore it\n\t\t\tchildInternal = UNDEFINED;\n\t\t}\n\t} else if (\n\t\tchildInternal === null ||\n\t\t(childInternal &&\n\t\t\tchildVNode.key == childInternal.key &&\n\t\t\tchildVNode.type === childInternal.type)\n\t) {\n\t\toldChildren[i] = UNDEFINED;\n\t} else {\n\t\t// Either oldVNode === undefined or oldChildrenLength > 0,\n\t\t// so after this loop oldVNode == null or oldVNode is a valid value.\n\t\tfor (let j = 0; j < oldChildrenLength; j++) {\n\t\t\tchildInternal = oldChildren[j];\n\t\t\t// If childVNode is unkeyed, we only match similarly unkeyed nodes, otherwise we match by key.\n\t\t\t// We always match by type (in either case).\n\t\t\tif (\n\t\t\t\tchildInternal &&\n\t\t\t\tchildVNode.key == childInternal.key &&\n\t\t\t\tchildVNode.type === childInternal.type\n\t\t\t) {\n\t\t\t\toldChildren[j] = UNDEFINED;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tchildInternal = null;\n\t\t}\n\t}\n\n\treturn childInternal;\n}\n\n/**\n * @param {import('../internal').Internal} internal\n * @param {import('../internal').PreactElement} startDom\n * @param {import('../internal').PreactElement} parentDom\n */\nexport function reorderChildren(internal, startDom, parentDom) {\n\tif (internal._children == null) {\n\t\treturn startDom;\n\t}\n\n\tfor (let tmp = 0; tmp < internal._children.length; tmp++) {\n\t\tlet childInternal = internal._children[tmp];\n\t\tif (childInternal) {\n\t\t\t// We typically enter this code path on sCU bailout, where we copy\n\t\t\t// oldVNode._children to newVNode._children. If that is the case, we need\n\t\t\t// to update the old children's _parent pointer to point to the newVNode\n\t\t\t// (childVNode here).\n\t\t\tchildInternal._parent = internal;\n\n\t\t\tif (childInternal._flags & TYPE_COMPONENT) {\n\t\t\t\tstartDom = reorderChildren(childInternal, startDom, parentDom);\n\t\t\t} else if (childInternal._dom == startDom) {\n\t\t\t\tstartDom = startDom.nextSibling;\n\t\t\t} else {\n\t\t\t\tstartDom = placeChild(\n\t\t\t\t\tparentDom,\n\t\t\t\t\tinternal._children.length,\n\t\t\t\t\tchildInternal._dom,\n\t\t\t\t\tstartDom\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn startDom;\n}\n\n/**\n * Flatten and loop through the children of a virtual node\n * @param {import('../index').ComponentChildren} children The unflattened\n * children of a virtual node\n * @returns {import('../internal').VNode[]}\n */\nexport function toChildArray(children, out) {\n\tout = out || [];\n\tif (children == null || typeof children == 'boolean') {\n\t} else if (Array.isArray(children)) {\n\t\tfor (children of children) {\n\t\t\ttoChildArray(children, out);\n\t\t}\n\t} else {\n\t\tout.push(children);\n\t}\n\n\treturn out;\n}\n\n/**\n * @param {import('../internal').PreactElement} parentDom\n * @param {number} oldChildrenLength\n * @param {import('../internal').PreactElement} newDom\n * @param {import('../internal').PreactElement} startDom\n * @returns {import('../internal').PreactElement}\n */\nfunction placeChild(parentDom, oldChildrenLength, newDom, startDom) {\n\tif (startDom == null || newDom.parentNode == null) {\n\t\t// \"startDom == null\": The diff has finished with existing DOM children and\n\t\t// we are appending new ones.\n\t\t//\n\t\t// newDom.parentNode == null: newDom is a brand new unconnected DOM node. Go\n\t\t// ahead and mount it here.\n\t\tparentDom.insertBefore(newDom, startDom);\n\t\treturn startDom;\n\t}\n\n\t// `j<oldChildrenLength; j+=2` is an alternative to `j++<oldChildrenLength/2`\n\tfor (\n\t\tlet sibDom = startDom, j = 0;\n\t\t(sibDom = sibDom.nextSibling) && j < oldChildrenLength;\n\t\tj += 2\n\t) {\n\t\tif (sibDom == newDom) {\n\t\t\treturn newDom.nextSibling;\n\t\t}\n\t}\n\tparentDom.insertBefore(newDom, startDom);\n\treturn startDom;\n}\n","import { diffChildren } from './children';\nimport { setProperty } from './props';\nimport options from '../options';\nimport { renderComponent } from './component';\nimport {\n\tRESET_MODE,\n\tTYPE_TEXT,\n\tTYPE_ELEMENT,\n\tMODE_SUSPENDED,\n\tMODE_ERRORED,\n\tTYPE_ROOT,\n\tMODE_SVG,\n\tUNDEFINED\n} from '../constants';\nimport { getChildDom, getDomSibling } from '../tree';\n\n/**\n * Diff two virtual nodes and apply proper changes to the DOM\n * @param {import('../internal').PreactElement} parentDom The parent of the DOM element\n * @param {import('../internal').VNode | string} newVNode The new virtual node\n * @param {import('../internal').Internal} internal The Internal node to patch\n * @param {object} globalContext The current context object. Modified by getChildContext\n * @param {import('../internal').CommitQueue} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {import('../internal').PreactNode} startDom\n */\nexport function patch(\n\tparentDom,\n\tnewVNode,\n\tinternal,\n\tglobalContext,\n\tcommitQueue,\n\tstartDom\n) {\n\tlet dom = internal._dom;\n\tlet flags = internal._flags;\n\n\tif (flags & TYPE_TEXT) {\n\t\tif (newVNode !== internal.props) {\n\t\t\tdom.data = newVNode;\n\t\t\tinternal.props = newVNode;\n\t\t}\n\n\t\treturn dom.nextSibling;\n\t}\n\n\t// When passing through createElement it assigns the object\n\t// constructor as undefined. This to prevent JSON-injection.\n\tif (newVNode.constructor !== UNDEFINED) return null;\n\n\tif (options._diff) options._diff(internal, newVNode);\n\n\tif (flags & TYPE_ELEMENT) {\n\t\tif (newVNode._vnodeId !== internal._vnodeId) {\n\t\t\t// @ts-ignore dom is a PreactElement here\n\t\t\tpatchDOMElement(dom, newVNode, internal, globalContext, commitQueue);\n\t\t\t// Once we have successfully rendered the new VNode, copy it's ID over\n\t\t\tinternal._vnodeId = newVNode._vnodeId;\n\t\t}\n\n\t\tif (options.diffed) options.diffed(internal);\n\n\t\t// We successfully rendered this VNode, unset any stored hydration/bailout state:\n\t\tinternal._flags &= RESET_MODE;\n\n\t\treturn dom.nextSibling;\n\t}\n\n\t/** @type {import('../internal').PreactNode} */\n\tlet nextDomSibling;\n\n\t// Root nodes signal that an attempt to render into a specific DOM node on\n\t// the page. Root nodes can occur anywhere in the tree and not just at the\n\t// top.\n\tlet prevStartDom = startDom;\n\tlet prevParentDom = parentDom;\n\tif (flags & TYPE_ROOT) {\n\t\tparentDom = newVNode.props._parentDom;\n\n\t\tif (parentDom !== prevParentDom) {\n\t\t\tstartDom = getChildDom(internal) || startDom;\n\n\t\t\t// The `startDom` variable might point to a node from another\n\t\t\t// tree from a previous render\n\t\t\tif (startDom != null && startDom.parentNode !== parentDom) {\n\t\t\t\tstartDom = null;\n\t\t\t}\n\t\t}\n\t}\n\n\ttry {\n\t\tnextDomSibling = renderComponent(\n\t\t\tparentDom,\n\t\t\t/** @type {import('../internal').VNode} */\n\t\t\t(newVNode),\n\t\t\tinternal,\n\t\t\tglobalContext,\n\t\t\tcommitQueue,\n\t\t\tstartDom\n\t\t);\n\t} catch (e) {\n\t\t// @TODO: assign a new VNode ID here? Or NaN?\n\t\t// newVNode._vnodeId = 0;\n\t\tinternal._flags |= e.then ? MODE_SUSPENDED : MODE_ERRORED;\n\t\toptions._catchError(e, internal);\n\n\t\treturn nextDomSibling;\n\t}\n\n\tif (prevParentDom !== parentDom) {\n\t\t// If this is a root node/Portal, and it changed the parentDom it's\n\t\t// children, then we need to determine which dom node the diff should\n\t\t// continue with.\n\t\tif (prevStartDom == null || prevStartDom.parentNode == prevParentDom) {\n\t\t\t// If prevStartDom == null, then we are diffing a root node that\n\t\t\t// didn't have a startDom to begin with, so we can just return null.\n\t\t\t//\n\t\t\t// Or, if the previous value for start dom still has the same parent\n\t\t\t// DOM has the root node's parent tree, then we can use it. This case\n\t\t\t// assumes the root node rendered its children into a new parent.\n\t\t\tnextDomSibling = prevStartDom;\n\t\t} else {\n\t\t\t// Here, if the parentDoms are different and prevStartDom has moved into\n\t\t\t// a new parentDom, we'll assume the root node moved prevStartDom under\n\t\t\t// the new parentDom. Because of this change, we need to search the\n\t\t\t// internal tree for the next DOM sibling the tree should begin with\n\t\t\tnextDomSibling = getDomSibling(internal);\n\t\t}\n\t}\n\n\tif (options.diffed) options.diffed(internal);\n\n\t// We successfully rendered this VNode, unset any stored hydration/bailout state:\n\tinternal._flags &= RESET_MODE;\n\t// Once we have successfully rendered the new VNode, copy it's ID over\n\tinternal._vnodeId = newVNode._vnodeId;\n\n\treturn nextDomSibling;\n}\n\n/**\n * Diff two virtual nodes representing DOM element\n * @param {import('../internal').PreactElement} dom The DOM element representing\n * the virtual nodes being diffed\n * @param {import('../internal').VNode} newVNode The new virtual node\n * @param {import('../internal').Internal} internal The Internal node to patch\n * @param {object} globalContext The current context object\n * @param {import('../internal').CommitQueue} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n */\nfunction patchDOMElement(dom, newVNode, internal, globalContext, commitQueue) {\n\tlet oldProps = internal.props,\n\t\tnewProps = (internal.props = newVNode.props),\n\t\tisSvg = internal._flags & MODE_SVG,\n\t\ti,\n\t\tvalue,\n\t\ttmp,\n\t\tnewHtml,\n\t\toldHtml,\n\t\tnewChildren;\n\n\tfor (i in oldProps) {\n\t\tvalue = oldProps[i];\n\t\tif (i === 'key') {\n\t\t} else if (i === 'children') {\n\t\t} else if (i === 'dangerouslySetInnerHTML') {\n\t\t\toldHtml = value;\n\t\t} else if (!(i in newProps)) {\n\t\t\tsetProperty(dom, i, null, value, isSvg);\n\t\t}\n\t}\n\n\tfor (i in newProps) {\n\t\tvalue = newProps[i];\n\t\tif (i === 'key') {\n\t\t} else if (i === 'children') {\n\t\t\tnewChildren = value;\n\t\t} else if (i === 'dangerouslySetInnerHTML') {\n\t\t\tnewHtml = value;\n\t\t} else if (\n\t\t\tvalue !== (tmp = oldProps[i]) ||\n\t\t\t((i === 'checked' || i === 'value') && value != null && value !== dom[i])\n\t\t) {\n\t\t\tsetProperty(dom, i, value, tmp, isSvg);\n\t\t}\n\t}\n\n\t// If the new vnode didn't have dangerouslySetInnerHTML, diff its children\n\tif (newHtml) {\n\t\tvalue = newHtml.__html;\n\t\t// Avoid re-applying the same '__html' if it did not changed between re-render\n\t\tif (!oldHtml || (value !== oldHtml.__html && value !== dom.innerHTML)) {\n\t\t\tdom.innerHTML = value;\n\t\t}\n\t\tinternal._children = null;\n\t} else {\n\t\tif (oldHtml) dom.innerHTML = '';\n\n\t\tdiffChildren(\n\t\t\tdom,\n\t\t\tnewChildren && Array.isArray(newChildren) ? newChildren : [newChildren],\n\t\t\tinternal,\n\t\t\tglobalContext,\n\t\t\tcommitQueue,\n\t\t\tdom.firstChild\n\t\t);\n\t}\n\n\tif (newProps.value != null && dom._isControlled) {\n\t\tdom._prevValue = newProps.value;\n\t} else if (newProps.checked != null && dom._isControlled) {\n\t\tdom._prevValue = newProps.checked;\n\t}\n}\n","import { addCommitCallback, commitRoot } from './diff/commit';\nimport options from './options';\nimport { createVNode, Fragment } from './create-element';\nimport { patch } from './diff/patch';\nimport {\n\tDIRTY_BIT,\n\tFORCE_UPDATE,\n\tMODE_HYDRATE,\n\tMODE_SUSPENDED,\n\tMODE_UNMOUNTING\n} from './constants';\nimport { getDomSibling, getParentDom } from './tree';\n\n/**\n * Base Component class. Provides `setState()` and `forceUpdate()`, which\n * trigger rendering\n * @param {object} props The initial component props\n * @param {object} context The initial context from parent components'\n * getChildContext\n */\nexport function Component(props, context) {\n\tthis.props = props;\n\tthis.context = context;\n}\n\n/**\n * Update component state and schedule a re-render.\n * @this {import('./internal').Component}\n * @param {object | ((s: object, p: object) => object)} update A hash of state\n * properties to update with new values or a function that given the current\n * state and props returns a new partial state\n * @param {() => void} [callback] A function to be called once component state is\n * updated\n */\nComponent.prototype.setState = function(update, callback) {\n\t// only clone state when copying to nextState the first time.\n\tlet s;\n\tif (this._nextState != null && this._nextState !== this.state) {\n\t\ts = this._nextState;\n\t} else {\n\t\ts = this._nextState = Object.assign({}, this.state);\n\t}\n\n\tif (typeof update == 'function') {\n\t\t// Some libraries like `immer` mark the current state as readonly,\n\t\t// preventing us from mutating it, so we need to clone it. See #2716\n\t\tupdate = update(Object.assign({}, s), this.props);\n\t}\n\n\tif (update) {\n\t\tObject.assign(s, update);\n\t}\n\n\t// Skip update if updater function returned null\n\tif (update == null) return;\n\n\tif (this._internal) {\n\t\tif (callback) addCommitCallback(this._internal, callback);\n\t\tenqueueRender(this);\n\t}\n};\n\n/**\n * Immediately perform a synchronous re-render of the component\n * @this {import('./internal').Component}\n * @param {() => void} [callback] A function to be called after component is\n * re-rendered\n */\nComponent.prototype.forceUpdate = function(callback) {\n\tif (this._internal) {\n\t\t// Set render mode so that we can differentiate where the render request\n\t\t// is coming from. We need this because forceUpdate should never call\n\t\t// shouldComponentUpdate\n\t\tthis._internal._flags |= FORCE_UPDATE;\n\t\tif (callback) addCommitCallback(this._internal, callback);\n\t\tenqueueRender(this);\n\t}\n};\n\n/**\n * Accepts `props` and `state`, and returns a new Virtual DOM tree to build.\n * Virtual DOM is generally constructed via [JSX](http://jasonformat.com/wtf-is-jsx).\n * @param {object} props Props (eg: JSX attributes) received from parent\n * element/component\n * @param {object} state The component's current state\n * @param {object} context Context object, as returned by the nearest\n * ancestor's `getChildContext()`\n * @returns {import('./index').ComponentChildren | void}\n */\nComponent.prototype.render = Fragment;\n\n/**\n * Trigger in-place re-rendering of a component.\n * @param {import('./internal').Component} component The component to rerender\n */\nfunction rerenderComponent(component) {\n\tlet internal = component._internal;\n\n\tif (~internal._flags & MODE_UNMOUNTING && internal._flags & DIRTY_BIT) {\n\t\tlet parentDom = getParentDom(internal);\n\t\tlet startDom =\n\t\t\t(internal._flags & (MODE_HYDRATE | MODE_SUSPENDED)) ===\n\t\t\t(MODE_HYDRATE | MODE_SUSPENDED)\n\t\t\t\t? internal._dom\n\t\t\t\t: getDomSibling(internal, 0);\n\n\t\tconst vnode = createVNode(\n\t\t\tinternal.type,\n\t\t\tinternal.props,\n\t\t\tinternal.key, // @TODO we shouldn't need to actually pass these\n\t\t\tinternal.ref, // since the mode flag should bypass key/ref handling\n\t\t\t0\n\t\t);\n\n\t\tconst commitQueue = [];\n\t\tpatch(\n\t\t\tparentDom,\n\t\t\tvnode,\n\t\t\tinternal,\n\t\t\tcomponent._globalContext,\n\t\t\tcommitQueue,\n\t\t\tstartDom\n\t\t);\n\t\tcommitRoot(commitQueue, internal);\n\t}\n}\n\n/**\n * The render queue\n * @type {Array<import('./internal').Component>}\n */\nlet rerenderQueue = [];\n\n/*\n * The value of `Component.debounce` must asynchronously invoke the passed in callback. It is\n * important that contributors to Preact can consistently reason about what calls to `setState`, etc.\n * do, and when their effects will be applied. See the links below for some further reading on designing\n * asynchronous APIs.\n * * [Designing APIs for Asynchrony](https://blog.izs.me/2013/08/designing-apis-for-asynchrony)\n * * [Callbacks synchronous and asynchronous](https://blog.ometer.com/2011/07/24/callbacks-synchronous-and-asynchronous/)\n */\n\nlet prevDebounce;\n\nconst defer = Promise.prototype.then.bind(Promise.resolve());\n\n/**\n * Enqueue a rerender of a component\n * @param {import('./internal').Component} c The component to rerender\n */\nexport function enqueueRender(c) {\n\tif (\n\t\t(!(c._internal._flags & DIRTY_BIT) &&\n\t\t\t(c._internal._flags |= DIRTY_BIT) &&\n\t\t\trerenderQueue.push(c) &&\n\t\t\t!process._rerenderCount++) ||\n\t\tprevDebounce !== options.debounceRendering\n\t) {\n\t\tprevDebounce = options.debounceRendering;\n\t\t(prevDebounce || defer)(process);\n\t}\n}\n\n/** Flush the render queue by rerendering all queued components */\nfunction process() {\n\twhile ((len = process._rerenderCount = rerenderQueue.length)) {\n\t\trerenderQueue.sort((a, b) => a._internal._depth - b._internal._depth);\n\t\twhile (len--) {\n\t\t\trerenderComponent(rerenderQueue.shift());\n\t\t}\n\t}\n}\nlet len = (process._rerenderCount = 0);\n","import { Fragment } from '../create-element';\nimport options from '../options';\nimport { Component } from '../component';\nimport { mountChildren } from './mount';\nimport { diffChildren, reorderChildren } from './children';\nimport {\n\tDIRTY_BIT,\n\tFORCE_UPDATE,\n\tMODE_PENDING_ERROR,\n\tMODE_RERENDERING_ERROR,\n\tTYPE_CLASS\n} from '../constants';\nimport { addCommitCallback } from './commit';\n\n/**\n * Diff two virtual nodes and apply proper changes to the DOM\n * @param {import('../internal').PreactElement} parentDom The parent of the DOM element\n * @param {import('../internal').VNode} newVNode The new virtual node\n * @param {import('../internal').Internal} internal The component's backing Internal node\n * @param {object} globalContext The current context object. Modified by getChildContext\n * @param {import('../internal').CommitQueue} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {import('../internal').PreactNode} startDom\n * @returns {import('../internal').PreactNode} pointer to the next DOM node (in order) to be rendered (or null)\n */\nexport function renderComponent(\n\tparentDom,\n\tnewVNode,\n\tinternal,\n\tglobalContext,\n\tcommitQueue,\n\tstartDom\n) {\n\t/** @type {import('../internal').Component} */\n\tlet c;\n\tlet isNew, oldProps, oldState, snapshot, tmp;\n\n\t/** @type {import('../internal').ComponentType} */\n\tlet type = (internal.type);\n\n\t// @TODO split update + mount?\n\tlet newProps = newVNode ? newVNode.props : internal.props;\n\n\tif (internal._flags & MODE_PENDING_ERROR) {\n\t\t// Toggle the MODE_PENDING_ERROR and MODE_RERENDERING_ERROR flags. In\n\t\t// actuality, this should turn off the MODE_PENDING_ERROR flag and turn on\n\t\t// the MODE_RERENDERING_ERROR flag.\n\t\tinternal._flags ^= MODE_PENDING_ERROR | MODE_RERENDERING_ERROR;\n\t}\n\n\t// Necessary for createContext api. Setting this property will pass\n\t// the context value as `this.context` just for this component.\n\ttmp = type.contextType;\n\tlet provider = tmp && globalContext[tmp._id];\n\tlet componentContext = tmp\n\t\t? provider\n\t\t\t? provider.props.value\n\t\t\t: tmp._defaultValue\n\t\t: globalContext;\n\n\tif (internal && internal._component) {\n\t\tc = internal._component;\n\t} else {\n\t\t// Instantiate the new component\n\t\tif (internal._flags & TYPE_CLASS) {\n\t\t\t// @ts-ignore The check above verifies that newType is suppose to be constructed\n\t\t\tinternal._component = c = new type(newProps, componentContext); // eslint-disable-line new-cap\n\t\t} else {\n\t\t\t// @ts-ignore Trust me, Component implements the interface we want\n\t\t\tinternal._component = c = new Component(newProps, componentContext);\n\t\t\tc.constructor = type;\n\t\t\tc.render = doRender;\n\t\t}\n\t\tif (provider) provider._subs.add(c);\n\n\t\tc.props = newProps;\n\t\tif (!c.state) c.state = {};\n\t\tc.context = componentContext;\n\t\tc._globalContext = globalContext;\n\t\tisNew = true;\n\t\tinternal._flags |= DIRTY_BIT;\n\t}\n\n\t// Invoke getDerivedStateFromProps\n\tif (c._nextState == null) {\n\t\tc._nextState = c.state;\n\t}\n\tif (type.getDerivedStateFromProps != null) {\n\t\tif (c._nextState == c.state) {\n\t\t\tc._nextState = Object.assign({}, c._nextState);\n\t\t}\n\n\t\tObject.assign(\n\t\t\tc._nextState,\n\t\t\ttype.getDerivedStateFromProps(newProps, c._nextState)\n\t\t);\n\t}\n\n\toldProps = c.props;\n\toldState = c.state;\n\tif (isNew) {\n\t\tif (type.getDerivedStateFromProps == null && c.componentWillMount != null) {\n\t\t\tc.componentWillMount();\n\t\t}\n\n\t\tif (c.componentDidMount != null) {\n\t\t\t// If the component was constructed, queue up componentDidMount so the\n\t\t\t// first time this internal commits (regardless of suspense or not) it\n\t\t\t// will be called\n\t\t\taddCommitCallback(internal, c.componentDidMount);\n\t\t}\n\t} else {\n\t\tif (\n\t\t\ttype.getDerivedStateFromProps == null &&\n\t\t\tnewProps !== oldProps &&\n\t\t\tc.componentWillReceiveProps != null\n\t\t) {\n\t\t\tc.componentWillReceiveProps(newProps, componentContext);\n\t\t}\n\n\t\tif (\n\t\t\t(!(internal._flags & FORCE_UPDATE) &&\n\t\t\t\tc.shouldComponentUpdate != null &&\n\t\t\t\tc.shouldComponentUpdate(newProps, c._nextState, componentContext) ===\n\t\t\t\t\tfalse) ||\n\t\t\t(newVNode && newVNode._vnodeId === internal._vnodeId)\n\t\t) {\n\t\t\tc.props = newProps;\n\t\t\tc.state = c._nextState;\n\t\t\tinternal.props = newProps;\n\t\t\t// More info about this here: https://gist.github.com/JoviDeCroock/bec5f2ce93544d2e6070ef8e0036e4e8\n\t\t\tif (newVNode && newVNode._vnodeId !== internal._vnodeId) {\n\t\t\t\tinternal._flags &= ~DIRTY_BIT;\n\t\t\t}\n\n\t\t\tc._internal = internal;\n\t\t\tif (\n\t\t\t\tinternal._commitCallbacks != null &&\n\t\t\t\tinternal._commitCallbacks.length\n\t\t\t) {\n\t\t\t\tcommitQueue.push(internal);\n\t\t\t}\n\n\t\t\t// TODO: Returning undefined here (i.e. return;) passes all tests. That seems\n\t\t\t// like a bug. Should validate that we have test coverage for sCU that\n\t\t\t// returns Fragments with multiple DOM children\n\t\t\treturn reorderChildren(internal, startDom, parentDom);\n\t\t}\n\n\t\tif (c.componentWillUpdate != null) {\n\t\t\tc.componentWillUpdate(newProps, c._nextState, componentContext);\n\t\t}\n\t}\n\n\tc.context = componentContext;\n\tc.props = newProps;\n\tc.state = c._nextState;\n\n\tinternal.props = newProps;\n\n\tif ((tmp = options._render)) tmp(internal);\n\n\tinternal._flags &= ~DIRTY_BIT;\n\tc._internal = internal;\n\n\ttmp = c.render(c.props, c.state, c.context);\n\n\t// Handle setState called in render, see #2553\n\tc.state = c._nextState;\n\n\tif (c.getChildContext != null) {\n\t\tglobalContext = Object.assign({}, globalContext, c.getChildContext());\n\t}\n\n\tif (!isNew) {\n\t\tif (c.getSnapshotBeforeUpdate != null) {\n\t\t\tsnapshot = c.getSnapshotBeforeUpdate(oldProps, oldState);\n\t\t}\n\n\t\t// Only schedule componentDidUpdate if the component successfully rendered\n\t\tif (c.componentDidUpdate != null) {\n\t\t\taddCommitCallback(internal, () => {\n\t\t\t\tc.componentDidUpdate(oldProps, oldState, snapshot);\n\t\t\t});\n\t\t}\n\t}\n\n\tlet isTopLevelFragment =\n\t\ttmp != null && tmp.type === Fragment && tmp.key == null;\n\tlet renderResult = isTopLevelFragment ? tmp.props.children : tmp;\n\n\tlet nextDomSibling;\n\n\tif (internal._children == null) {\n\t\tnextDomSibling = mountChildren(\n\t\t\tparentDom,\n\t\t\tArray.isArray(renderResult) ? renderResult : [renderResult],\n\t\t\tinternal,\n\t\t\tglobalContext,\n\t\t\tcommitQueue,\n\t\t\tstartDom\n\t\t);\n\t} else {\n\t\tnextDomSibling = diffChildren(\n\t\t\tparentDom,\n\t\t\tArray.isArray(renderResult) ? renderResult : [renderResult],\n\t\t\tinternal,\n\t\t\tglobalContext,\n\t\t\tcommitQueue,\n\t\t\tstartDom\n\t\t);\n\t}\n\n\tif (internal._commitCallbacks != null && internal._commitCallbacks.length) {\n\t\tcommitQueue.push(internal);\n\t}\n\n\treturn nextDomSibling;\n}\n\n/** The `.render()` method for a PFC backing instance. */\nfunction doRender(props, state, context) {\n\treturn this.constructor(props, context);\n}\n","import { applyRef } from './refs';\nimport {\n\tTYPE_COMPONENT,\n\tTYPE_ELEMENT,\n\tMODE_HYDRATE,\n\tMODE_MUTATIVE_HYDRATE,\n\tMODE_SUSPENDED,\n\tRESET_MODE,\n\tTYPE_TEXT,\n\tMODE_ERRORED,\n\tTYPE_ROOT,\n\tMODE_SVG\n} from '../constants';\nimport { normalizeToVNode } from '../create-element';\nimport { setProperty } from './props';\nimport { renderComponent } from './component';\nimport { createInternal } from '../tree';\nimport options from '../options';\n\n/**\n * Diff two virtual nodes and apply proper changes to the DOM\n * @param {import('../internal').PreactElement} parentDom The parent of the DOM element\n * @param {import('../internal').VNode | string} newVNode The new virtual node\n * @param {import('../internal').Internal} internal The Internal node to mount\n * @param {object} globalContext The current context object. Modified by getChildContext\n * @param {import('../internal').CommitQueue} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {import('../internal').PreactElement} startDom\n * @returns {import('../internal').PreactElement | null} pointer to the next DOM node to be hydrated (or null)\n */\nexport function mount(\n\tparentDom,\n\tnewVNode,\n\tinternal,\n\tglobalContext,\n\tcommitQueue,\n\tstartDom\n) {\n\tif (options._diff) options._diff(internal, newVNode);\n\n\t/** @type {import('../internal').PreactElement} */\n\tlet nextDomSibling;\n\n\ttry {\n\t\tif (internal._flags & TYPE_COMPONENT) {\n\t\t\t// Root nodes signal that an attempt to render into a specific DOM node on\n\t\t\t// the page. Root nodes can occur anywhere in the tree and not just at the\n\t\t\t// top.\n\t\t\tlet prevStartDom = startDom;\n\t\t\tlet prevParentDom = parentDom;\n\t\t\tif (internal._flags & TYPE_ROOT) {\n\t\t\t\tparentDom = newVNode.props._parentDom;\n\n\t\t\t\tif (parentDom !== prevParentDom) {\n\t\t\t\t\tstartDom = null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnextDomSibling = renderComponent(\n\t\t\t\tparentDom,\n\t\t\t\tnull,\n\t\t\t\tinternal,\n\t\t\t\tglobalContext,\n\t\t\t\tcommitQueue,\n\t\t\t\tstartDom\n\t\t\t);\n\n\t\t\tif (internal._flags & TYPE_ROOT && prevParentDom !== parentDom) {\n\t\t\t\t// If we just mounted a root node/Portal, and it changed the parentDom\n\t\t\t\t// of it's children, then we need to resume the diff from it's previous\n\t\t\t\t// startDom element, which could be null if we are mounting an entirely\n\t\t\t\t// new tree, or the portal's nextSibling if we are mounting a Portal in\n\t\t\t\t// an existing tree.\n\t\t\t\tnextDomSibling = prevStartDom;\n\t\t\t}\n\t\t} else {\n\t\t\tlet hydrateDom =\n\t\t\t\tinternal._flags & (MODE_HYDRATE | MODE_MUTATIVE_HYDRATE)\n\t\t\t\t\t? startDom\n\t\t\t\t\t: null;\n\n\t\t\tnextDomSibling = mountDOMElement(\n\t\t\t\thydrateDom,\n\t\t\t\tinternal,\n\t\t\t\tglobalContext,\n\t\t\t\tcommitQueue\n\t\t\t);\n\t\t}\n\n\t\tif (options.diffed) options.diffed(internal);\n\n\t\t// We successfully rendered this VNode, unset any stored hydration/bailout state:\n\t\tinternal._flags &= RESET_MODE;\n\t} catch (e) {\n\t\tinternal._vnodeId = 0;\n\t\tinternal._flags |= e.then ? MODE_SUSPENDED : MODE_ERRORED;\n\n\t\tif (internal._flags & MODE_HYDRATE) {\n\t\t\t// @ts-ignore Trust me TS, nextSibling is a PreactElement\n\t\t\tnextDomSibling = startDom && startDom.nextSibling;\n\t\t\tinternal._dom = startDom; // Save our current DOM position to resume later\n\t\t}\n\t\toptions._catchError(e, internal);\n\t}\n\n\treturn nextDomSibling;\n}\n\n/**\n * Diff two virtual nodes representing DOM element\n * @param {import('../internal').PreactElement} dom The DOM element representing\n * the virtual nodes being diffed\n * @param {import('../internal').Internal} internal The Internal node to mount\n * @param {object} globalContext The current context object\n * @param {import('../internal').CommitQueue} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @returns {import('../internal').PreactElement}\n */\nfunction mountDOMElement(dom, internal, globalContext, commitQueue) {\n\tlet newProps = internal.props;\n\tlet nodeType = internal.type;\n\t/** @type {any} */\n\tlet i, value;\n\n\tlet flags = internal._flags;\n\tlet isSvg = flags & MODE_SVG;\n\n\t// Are we *not* hydrating? (a top-level render() or mutative hydration):\n\tlet isFullRender = ~flags & MODE_HYDRATE;\n\n\t// if hydrating (hydrate() or render() with replaceNode), find the matching child:\n\tif (flags & (MODE_HYDRATE | MODE_MUTATIVE_HYDRATE)) {\n\t\twhile (\n\t\t\tdom &&\n\t\t\t(nodeType ? dom.localName !== nodeType : dom.nodeType !== 3)\n\t\t) {\n\t\t\tdom = dom.nextSibling;\n\t\t}\n\t}\n\n\tlet isNew = dom == null;\n\n\tif (flags & TYPE_TEXT) {\n\t\tif (isNew) {\n\t\t\t// @ts-ignore createTextNode returns Text, we expect PreactElement\n\t\t\tdom = document.createTextNode(newProps);\n\t\t} else if (dom.data !== newProps) {\n\t\t\tdom.data = newProps;\n\t\t}\n\n\t\tinternal._dom = dom;\n\t} else {\n\t\t// Tracks entering and exiting SVG namespace when descending through the tree.\n\t\t// if (nodeType === 'svg') internal._flags |= MODE_SVG;\n\n\t\tif (isNew) {\n\t\t\tif (isSvg) {\n\t\t\t\tdom = document.createElementNS(\n\t\t\t\t\t'http://www.w3.org/2000/svg',\n\t\t\t\t\t// @ts-ignore We know `newVNode.type` is a string\n\t\t\t\t\tnodeType\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tdom = document.createElement(\n\t\t\t\t\t// @ts-ignore We know `newVNode.type` is a string\n\t\t\t\t\tnodeType,\n\t\t\t\t\tnewProps.is && newProps\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// we are creating a new node, so we can assume this is a new subtree (in case we are hydrating), this deopts the hydrate\n\t\t\tinternal._flags = flags &= RESET_MODE;\n\t\t\tisFullRender = 1;\n\t\t}\n\n\t\t// @TODO: Consider removing and instructing users to instead set the desired\n\t\t// prop for removal to undefined/null. During hydration, props are not\n\t\t// diffed at all (including dangerouslySetInnerHTML)\n\t\tif (flags & MODE_MUTATIVE_HYDRATE) {\n\t\t\t// But, if we are in a situation where we are using existing DOM (e.g. replaceNode)\n\t\t\t// we should read the existing DOM attributes to diff them\n\t\t\tfor (i = 0; i < dom.attributes.length; i++) {\n\t\t\t\tvalue = dom.attributes[i].name;\n\t\t\t\tif (!(value in newProps)) {\n\t\t\t\t\tdom.removeAttribute(value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet newHtml, newValue, newChildren;\n\t\tif (\n\t\t\t(internal.type === 'input' ||\n\t\t\t\tinternal.type === 'textarea' ||\n\t\t\t\tinternal.type === 'select') &&\n\t\t\t(newProps.onInput || newProps.onChange)\n\t\t) {\n\t\t\tif (newProps.value != null) {\n\t\t\t\tdom._isControlled = true;\n\t\t\t\tdom._prevValue = newProps.value;\n\t\t\t} else if (newProps.checked != null) {\n\t\t\t\tdom._isControlled = true;\n\t\t\t\tdom._prevValue = newProps.checked;\n\t\t\t}\n\t\t}\n\n\t\tfor (i in newProps) {\n\t\t\tvalue = newProps[i];\n\t\t\tif (i === 'key') {\n\t\t\t} else if (i === 'children') {\n\t\t\t\tnewChildren = value;\n\t\t\t} else if (i === 'dangerouslySetInnerHTML') {\n\t\t\t\tnewHtml = value;\n\t\t\t} else if (i === 'value') {\n\t\t\t\tnewValue = value;\n\t\t\t} else if (\n\t\t\t\tvalue != null &&\n\t\t\t\t(isFullRender || typeof value === 'function')\n\t\t\t) {\n\t\t\t\tsetProperty(dom, i, value, null, isSvg);\n\t\t\t}\n\t\t}\n\n\t\tinternal._dom = dom;\n\n\t\t// If the new vnode didn't have dangerouslySetInnerHTML, diff its children\n\t\tif (newHtml) {\n\t\t\tif (isFullRender && newHtml.__html) {\n\t\t\t\tdom.innerHTML = newHtml.__html;\n\t\t\t}\n\t\t\tinternal._children = null;\n\t\t} else if (newChildren != null) {\n\t\t\tmountChildren(\n\t\t\t\tdom,\n\t\t\t\tnewChildren && Array.isArray(newChildren) ? newChildren : [newChildren],\n\t\t\t\tinternal,\n\t\t\t\tglobalContext,\n\t\t\t\tcommitQueue,\n\t\t\t\tisNew ? null : dom.firstChild\n\t\t\t);\n\t\t}\n\n\t\t// (as above, don't diff props during hydration)\n\t\tif (isFullRender && newValue != null) {\n\t\t\tsetProperty(dom, 'value', newValue, null, 0);\n\t\t}\n\t}\n\n\t// @ts-ignore\n\treturn isNew ? null : dom.nextSibling;\n}\n\n/**\n * Diff the children of a virtual node\n * @param {import('../internal').PreactElement} parentDom The DOM element whose\n * children are being diffed\n * @param {import('../internal').ComponentChildren[]} renderResult\n * @param {import('../internal').Internal} parentInternal The parent Internal of the given children\n * @param {object} globalContext The current context object - modified by getChildContext\n * @param {import('../internal').CommitQueue} commitQueue List of components\n * which have callbacks to invoke in commitRoot\n * @param {import('../internal').PreactElement} startDom\n */\nexport function mountChildren(\n\tparentDom,\n\trenderResult,\n\tparentInternal,\n\tglobalContext,\n\tcommitQueue,\n\tstartDom\n) {\n\tlet internalChildren = (parentInternal._children = []),\n\t\ti,\n\t\tchildVNode,\n\t\tchildInternal,\n\t\tnewDom,\n\t\tmountedNextChild;\n\n\tfor (i = 0; i < renderResult.length; i++) {\n\t\tchildVNode = normalizeToVNode(renderResult[i]);\n\n\t\t// Terser removes the `continue` here and wraps the loop body\n\t\t// in a `if (childVNode) { ... } condition\n\t\tif (childVNode == null) {\n\t\t\tinternalChildren[i] = null;\n\t\t\tcontinue;\n\t\t}\n\n\t\tchildInternal = createInternal(childVNode, parentInternal);\n\t\tinternalChildren[i] = childInternal;\n\n\t\t// Morph the old element into the new one, but don't append it to the dom yet\n\t\tmountedNextChild = mount(\n\t\t\tparentDom,\n\t\t\tchildVNode,\n\t\t\tchildInternal,\n\t\t\tglobalContext,\n\t\t\tcommitQueue,\n\t\t\tstartDom\n\t\t);\n\n\t\tnewDom = childInternal._dom;\n\n\t\tif (childInternal._flags & TYPE_COMPONENT || newDom == startDom) {\n\t\t\t// If the child is a Fragment-like or if it is DOM VNode and its _dom\n\t\t\t// property matches the dom we are diffing (i.e. startDom), just\n\t\t\t// continue with the mountedNextChild\n\t\t\tstartDom = mountedNextChild;\n\t\t} else if (newDom != null) {\n\t\t\t// The DOM the diff should begin with is now startDom (since we inserted\n\t\t\t// newDom before startDom) so ignore mountedNextChild and continue with\n\t\t\t// startDom\n\t\t\tparentDom.insertBefore(newDom, startDom);\n\t\t}\n\n\t\tif (childInternal.ref) {\n\t\t\tapplyRef(\n\t\t\t\tnull,\n\t\t\t\tchildInternal.ref,\n\t\t\t\tchildInternal._component || newDom,\n\t\t\t\tchildInternal\n\t\t\t);\n\t\t}\n\t}\n\n\t// Remove children that are not part of any vnode.\n\tif (\n\t\tparentInternal._flags & (MODE_HYDRATE | MODE_MUTATIVE_HYDRATE) &&\n\t\tparentInternal._flags & TYPE_ELEMENT\n\t) {\n\t\t// TODO: Would it be simpler to just clear the pre-existing DOM in top-level\n\t\t// render if render is called with no oldVNode & existing children & no\n\t\t// replaceNode? Instead of patching the DOM to match the VNode tree? (remove\n\t\t// attributes & unused DOM)\n\t\twhile (startDom) {\n\t\t\ti = startDom;\n\t\t\tstartDom = startDom.nextSibling;\n\t\t\ti.remove();\n\t\t}\n\t}\n\n\treturn startDom;\n}\n","import {\n\tMODE_HYDRATE,\n\tMODE_MUTATIVE_HYDRATE,\n\tMODE_SVG,\n\tUNDEFINED\n} from './constants';\nimport { commitRoot } from './diff/commit';\nimport { createElement, Fragment } from './create-element';\nimport options from './options';\nimport { mount } from './diff/mount';\nimport { patch } from './diff/patch';\nimport { createInternal } from './tree';\n\n/**\n * Render a Preact virtual node into a DOM element\n * @param {import('./internal').ComponentChild} vnode The virtual node to render\n * @param {import('./internal').PreactElement} parentDom The DOM element to\n * render into\n */\nexport function render(vnode, parentDom) {\n\tif (options._root) options._root(vnode, parentDom);\n\n\t// List of effects that need to be called after diffing.\n\tconst commitQueue = [];\n\n\t// To be able to support calling `render()` multiple times on the same\n\t// DOM node, we need to obtain a reference to the previous tree. We do\n\t// this by assigning a new `_children` property to DOM nodes which points\n\t// to the last rendered tree. By default this property is not present, which\n\t// means that we are mounting a new tree for the first time.\n\tlet rootInternal = parentDom._children;\n\tvnode = createElement(Fragment, { _parentDom: parentDom }, [vnode]);\n\n\tif (rootInternal) {\n\t\tpatch(\n\t\t\tparentDom,\n\t\t\tvnode,\n\t\t\trootInternal,\n\t\t\t{},\n\t\t\tcommitQueue,\n\t\t\tparentDom.firstChild\n\t\t);\n\t} else {\n\t\t// Store the VDOM tree root on the DOM element in a (minified) property:\n\t\trootInternal = parentDom._children = createInternal(vnode, null);\n\n\t\tif (parentDom.ownerSVGElement !== UNDEFINED) {\n\t\t\trootInternal._flags |= MODE_SVG;\n\t\t}\n\n\t\t// Calling `render` on a container with existing DOM elements puts the diff into mutative hydrate mode:\n\t\tif (parentDom.firstChild) {\n\t\t\trootInternal._flags |= MODE_MUTATIVE_HYDRATE;\n\t\t}\n\n\t\tmount(\n\t\t\tparentDom,\n\t\t\tvnode,\n\t\t\trootInternal,\n\t\t\t{},\n\t\t\tcommitQueue,\n\t\t\t// Start the diff at the replaceNode or the parentDOM.firstChild if any.\n\t\t\t// Will be null if the parentDom is empty\n\t\t\tparentDom.firstChild\n\t\t);\n\t}\n\n\t// Flush all queued effects\n\tcommitRoot(commitQueue, rootInternal);\n}\n\n/**\n * Update an existing DOM element with data from a Preact virtual node\n * @param {import('./internal').ComponentChild} vnode The virtual node to render\n * @param {import('./internal').PreactElement} parentDom The DOM element to\n * update\n */\nexport function hydrate(vnode, parentDom) {\n\tif (options._root) options._root(vnode, parentDom);\n\n\tvnode = createElement(Fragment, { _parentDom: parentDom }, [vnode]);\n\tconst rootInternal = createInternal(vnode);\n\trootInternal._flags |= MODE_HYDRATE;\n\tparentDom._children = rootInternal;\n\n\tif (parentDom.ownerSVGElement !== UNDEFINED) {\n\t\trootInternal._flags |= MODE_SVG;\n\t}\n\n\tconst commitQueue = [];\n\tmount(parentDom, vnode, rootInternal, {}, commitQueue, parentDom.firstChild);\n\tcommitRoot(commitQueue, rootInternal);\n}\n","import {\n\tMODE_HYDRATE,\n\tMODE_MUTATIVE_HYDRATE,\n\tMODE_SVG,\n\tUNDEFINED\n} from './constants';\nimport { commitRoot } from './diff/commit';\nimport { createElement, Fragment } from './create-element';\nimport options from './options';\nimport { mount } from './diff/mount';\nimport { patch } from './diff/patch';\nimport { createInternal } from './tree';\n\n/**\n *\n * @param {import('./internal').PreactElement} parentDom The DOM element to\n */\nexport function createRoot(parentDom) {\n\tlet rootInternal = null;\n\n\tfunction render(vnode) {\n\t\tif (options._root) options._root(vnode, parentDom);\n\n\t\t// List of effects that need to be called after diffing.\n\t\tconst commitQueue = [];\n\n\t\tvnode = createElement(Fragment, { _parentDom: parentDom }, [vnode]);\n\n\t\tif (rootInternal) {\n\t\t\tpatch(\n\t\t\t\tparentDom,\n\t\t\t\tvnode,\n\t\t\t\trootInternal,\n\t\t\t\t{},\n\t\t\t\tcommitQueue,\n\t\t\t\tparentDom.firstChild\n\t\t\t);\n\t\t} else {\n\t\t\t// Store the VDOM tree root on the DOM element in a (minified) property:\n\t\t\trootInternal = parentDom._children = createInternal(vnode, null);\n\n\t\t\tif (parentDom.ownerSVGElement !== UNDEFINED) {\n\t\t\t\trootInternal._flags |= MODE_SVG;\n\t\t\t}\n\n\t\t\t// Calling `render` on a container with existing DOM elements puts the diff into mutative hydrate mode:\n\t\t\tif (parentDom.firstChild) {\n\t\t\t\trootInternal._flags |= MODE_MUTATIVE_HYDRATE;\n\t\t\t}\n\n\t\t\tmount(\n\t\t\t\tparentDom,\n\t\t\t\tvnode,\n\t\t\t\trootInternal,\n\t\t\t\t{},\n\t\t\t\tcommitQueue,\n\t\t\t\t// Start the diff at the replaceNode or the parentDOM.firstChild if any.\n\t\t\t\t// Will be null if the parentDom is empty\n\t\t\t\tparentDom.firstChild\n\t\t\t);\n\t\t}\n\n\t\t// Flush all queued effects\n\t\tcommitRoot(commitQueue, vnode);\n\t}\n\n\treturn {\n\t\thydrate(vnode) {\n\t\t\tif (options._root) options._root(vnode, parentDom);\n\n\t\t\tvnode = createElement(Fragment, { _parentDom: parentDom }, [vnode]);\n\t\t\trootInternal = createInternal(vnode);\n\t\t\trootInternal._flags |= MODE_HYDRATE;\n\t\t\tparentDom._children = rootInternal;\n\n\t\t\tif (parentDom.ownerSVGElement !== UNDEFINED) {\n\t\t\t\trootInternal._flags |= MODE_SVG;\n\t\t\t}\n\n\t\t\tconst commitQueue = [];\n\t\t\tmount(\n\t\t\t\tparentDom,\n\t\t\t\tvnode,\n\t\t\t\trootInternal,\n\t\t\t\t{},\n\t\t\t\tcommitQueue,\n\t\t\t\tparentDom.firstChild\n\t\t\t);\n\t\t\tcommitRoot(commitQueue, rootInternal);\n\t\t},\n\t\trender\n\t};\n}\n","import { createVNode } from './create-element';\n\n/**\n * Clones the given VNode, optionally adding attributes/props and replacing its children.\n * @param {import('./internal').VNode} vnode The virtual DOM element to clone\n * @param {object} props Attributes/props to add when cloning\n * @param {Array<import('./internal').ComponentChildren>} rest Any additional arguments will be used as replacement children.\n * @returns {import('./internal').VNode}\n */\nexport function cloneElement(vnode, props, children) {\n\tlet normalizedProps = Object.assign({}, vnode.props),\n\t\tkey,\n\t\tref,\n\t\ti;\n\n\tfor (i in props) {\n\t\tif (!(i === 'key' || (typeof vnode.type !== 'function' && i === 'ref'))) {\n\t\t\tnormalizedProps[i] = props[i];\n\t\t} else if (i === 'key') {\n\t\t\tkey = props[i];\n\t\t} else if (i === 'ref') {\n\t\t\tref = props[i];\n\t\t}\n\t}\n\n\tif (arguments.length > 3) {\n\t\tchildren = [children];\n\t\tfor (i = 3; i < arguments.length; i++) {\n\t\t\tchildren.push(arguments[i]);\n\t\t}\n\t}\n\tif (children != null) {\n\t\tnormalizedProps.children = children;\n\t}\n\n\treturn createVNode(\n\t\tvnode.type,\n\t\tnormalizedProps,\n\t\tkey || vnode.key,\n\t\tref || vnode.ref,\n\t\t0\n\t);\n}\n"],"names":["EMPTY_ARR","options","[object Object]","error","internal","TYPE_CLASS","type","getDerivedStateFromError","setState","componentDidCatch","e","addCommitCallback","callback","push","commitRoot","commitQueue","rootInternal","some","length","shift","call","vnodeId","createElement","props","children","key","ref","i","normalizedProps","arguments","defaultProps","undefined","createVNode","original","vnode","constructor","__v","normalizeToVNode","childVNode","Array","isArray","Fragment","createRef","current","isValidElement","applyRef","oldRef","value","setStyle","style","setProperty","dom","name","oldValue","isSvg","useCapture","o","cssText","replace","toLowerCase","slice","_listeners","addEventListener","eventProxyCapture","eventProxy","removeEventListener","setAttribute","removeAttribute","this","event","_isControlled","_prevValue","checked","nextContextId","providers","Set","createContext","defaultValue","contextId","context","__c","__","Consumer","contextValue","Provider","ctx","forEach","enqueueRender","getChildContext","contextType","unmount","parentInternal","skipRemove","r","delete","component","p","componentWillUnmount","TYPE_TEXT","remove","createInternal","flags","MODE_HYDRATE","NaN","prototype","__k","__e","__f","__b","shouldSearchComponent","getParentDom","getDomSibling","childIndex","indexOf","getChildDom","child","childDom","parentDom","parent","diffChildren","renderResult","globalContext","startDom","newDom","refs","childInternal","oldChildren","oldChildrenLength","newChildren","oldVNodeRef","nextDomSibling","findMatchingInternal","mount","patch","placeChild","parentNode","j","reorderChildren","tmp","nextSibling","toChildArray","out","insertBefore","sibDom","newVNode","data","patchDOMElement","diffed","prevStartDom","prevParentDom","renderComponent","then","newHtml","oldHtml","oldProps","newProps","innerHTML","firstChild","Component","rerenderComponent","update","s","state","Object","assign","forceUpdate","render","prevDebounce","rerenderQueue","defer","Promise","bind","resolve","c","process","debounceRendering","len","sort","a","b","isNew","oldState","snapshot","MODE_PENDING_ERROR","provider","componentContext","doRender","add","getDerivedStateFromProps","componentWillMount","componentDidMount","componentWillReceiveProps","shouldComponentUpdate","componentWillUpdate","getSnapshotBeforeUpdate","componentDidUpdate","mountChildren","mountDOMElement","nodeType","isFullRender","localName","document","createTextNode","createElementNS","is","attributes","newValue","onInput","onChange","mountedNextChild","internalChildren","__P","ownerSVGElement","hydrate","createRoot","cloneElement"],"mappings":"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"}