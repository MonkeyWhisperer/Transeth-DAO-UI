"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.parse=parse,exports.Parser=void 0;/**
 * @module radspec/parser
 */ /**
 * A token.
 * @typedef {Object} Token
 * @property {string} type The token type
 * @property {*?} value The value of the token
 */ /**
 * An AST node.
 * @typedef {Object} Node
 * @property {string} type The node type
 */ /**
 * An AST.
 * @typedef {Object} AST
 * @property {string} type
 * @property {Array<Node>} body The AST nodes
 */ /**
 * Enum for parser state.
 *
 * @readonly
 * @enum {string}
 */const PARSER_STATE={OK:"OK",ERROR:"ERROR"};/**
 * Parses a token list into an AST.
 *
 * @class Parser
 * @param {Array<Token>} tokens
 * @property {string} state The state of the parser (`OK` or `ERROR`)
 * @property {Array<Token>} tokens
 * @property {number} cursor
 */class Parser{constructor(tokens){this.state=PARSER_STATE.OK,this.tokens=tokens,this.cursor=0}/**
   * Get the current token and increase the cursor by 1
   *
   * @return {Token}
   */consume(){return this.cursor++,this.tokens[this.cursor-1]}/**
   * Get the previous token.
   *
   * @return {Token}
   */previous(){return this.tokens[this.cursor-1]}/**
   * Get the token under the cursor without consuming it.
   *
   * @return {Token}
   */peek(){return this.tokens[this.cursor]}/**
   * Checks if the type of the next token matches any of the expected types.
   *
   * Increases the cursor by 1 if the token matches.
   *
   * @param {...string} expected The expected types
   * @return {boolean} True if the next token matches, otherwise false
   */matches(...expected){if(this.eof())return!1;for(let type of expected)if(this.peek().type===type)return this.cursor++,!0;return!1}/**
   * Try to parse comparison operators.
   *
   * @param  {Array<Node>} astBody Subtree of AST being walked
   * @return {Node}
   */comparison(astBody){let node=this.addition(astBody);for(;this.matches("GREATER","GREATER_EQUAL","LESS","LESS_EQUAL","EQUAL_EQUAL","BANG_EQUAL");){let operator=this.previous().type,right=this.addition(astBody);node={type:"ComparisonExpression",operator,left:node,right}}return this.matches("QUESTION_MARK")&&(node={type:"TernaryExpression",predicate:node,left:this.comparison(astBody)},!this.matches("COLON")&&this.report("Half-baked ternary (expected colon)"),node.right=this.comparison(astBody)),this.matches("DOUBLE_VERTICAL_BAR")&&(node={left:node,right:this.comparison(),type:"DefaultExpression"}),node}/**
   * Try to parse arithmetic operators.
   *
   * @param  {Array<Node>} astBody Subtree of AST being walked
   * @return {Node}
   */addition(astBody){let node=this.multiplication(astBody);for(;this.matches("MINUS","PLUS");){let operator=this.previous().type,right=this.multiplication(astBody);node={type:"BinaryExpression",operator,left:node,right}}return node}/**
   * Try to parse binary operators.
   *
   * @param  {Array<Node>} astBody Subtree of AST being walked
   * @return {Node}
   */multiplication(astBody){let node=this.power(astBody);for(;this.matches("SLASH","STAR","MODULO");){let operator=this.previous().type,right=this.power(astBody);node={type:"BinaryExpression",operator,left:node,right}}return node}/**
   * Try to parse exponential operators.
   *
   * @param  {Array<Node>} astBody Subtree of AST being walked
   * @return {Node}
   */power(astBody){let node=this.unary(astBody);for(;this.matches("POWER");){let operator=this.previous().type,right=this.unary(astBody);node={type:"BinaryExpression",operator,left:node,right}}return node}/**
   * Try to parse unary operators.
   *
   * @param  {Array<Node>} astBody Subtree of AST being walked
   * @return {Node}
   */unary(astBody){if(this.matches("BANG","MINUS")){let operator=this.previous().type,right=this.unary(astBody);return{type:"UnaryExpression",operator,right:right}}return this.identifier(astBody)}/**
   * Try to parse identifiers and call expressions.
   *
   * @param  {Array<Node>} astBody Subtree of AST being walked
   * @return {Node}
   */identifier(astBody){let node;if(this.matches("IDENTIFIER")&&(node={type:"Identifier",value:this.previous().value}),!node){const previousNode=astBody.length&&astBody[astBody.length-1];previousNode&&("Identifier"===previousNode.type||"GroupedExpression"===previousNode.type||"CallExpression"===previousNode.type)&&(node=previousNode,astBody.pop())}if(node){for(;this.matches("DOT");){let property=this.consume().value;node={type:"PropertyAccessExpression",target:node,property}}return this.matches("LEFT_PAREN")&&(node={type:"CallExpression",target:node.target,callee:node.property,inputs:this.functionInputs(astBody),outputs:[]},this.eof()&&this.report("Unterminated call expression"),node.outputs=this.typeList()),node}return this.helper(astBody)}/**
   * Try to parse helper functions
   *
   * @param  {Array<Node>} astBody Subtree of AST being walked
   * @return {Node}
   */helper(astBody){if(this.matches("AT")){const identifier=this.consume(),name=identifier.value;"IDENTIFIER"!==identifier.type&&this.report(`Invalid helper function name '${name}' provided after @`);const node={type:"HelperFunction",name:name};return this.matches("LEFT_PAREN")?node.inputs=this.functionInputs(astBody):this.report(`Expected '(' for executing helper function`),node}return this.primary(astBody)}/**
   * Try to parse primaries (literals).
   *
   * @param  {Array<Node>} astBody Subtree of AST being walked
   * @return {Node}
   */primary(){if(this.matches("NUMBER","STRING","HEXADECIMAL","BOOLEAN")){let type={NUMBER:"NumberLiteral",STRING:"StringLiteral",HEXADECIMAL:"BytesLiteral",BOOLEAN:"BoolLiteral"}[this.previous().type];return{type,value:this.previous().value}}if(this.matches("LEFT_PAREN")){let expression;do// Keep munching expressions in the context of the current expression
expression=this.comparison(expression?[expression]:[]);while(!this.eof()&&!this.matches("RIGHT_PAREN"));return this.eof()&&this.report("Unterminated grouping"),{type:"GroupedExpression",body:expression}}this.report(`Unknown token "${this.consume().type}"`)}/**
   * Try to parse a type.
   *
   * @return {string} The type
   */type(){return this.matches("COLON")||"TYPE"===this.peek().type||this.report(`Expected a type, got "${this.peek().type}"`),this.consume().value}/**
   * Try to parse a type list.
   *
   * @return {Array<string>} The list of types
   */typeList(){// We just have a single type
if(this.matches("COLON")||"TYPE"===this.peek().type&&"LEFT_PAREN"===this.peek().type||this.report(`Expected a type or a list of types, got "${this.peek().type}"`),!this.matches("LEFT_PAREN"))return[{type:this.consume().value,selected:!0}];let typeList=[];for(;!this.eof()&&!this.matches("RIGHT_PAREN");){// Check if the type is preceded by a < to denote
// that this is the type of the return value we want.
let selected=this.matches("LESS");"TYPE"===!this.peek().type&&this.report(`Unexpected identifier in type list, expected type, got "${this.peek().type}"`),typeList.push({type:this.consume().value,selected}),selected&&!this.matches("GREATER")&&this.report(`Unclosed selected type`),this.matches("COMMA")||"RIGHT_PAREN"===this.peek().type||this.report("Undelimited parameter type (expected comma delimiter or closing brace)")}this.eof()&&this.report(`Unclosed type list`);// Verify that at least one type in the type list has been selected
// as the type of the return value.
//
// If no type has been selected, and the number of types in the type
// list is exactly 1, then we assume that that type should be
// marked as selected.
const hasSelectedTypeInList=!!typeList.find(item=>item.selected);return hasSelectedTypeInList||1!==typeList.length?!hasSelectedTypeInList&&this.report(`Type list has no selected type`):typeList[0].selected=!0,typeList}/**
   * Try to parse function arguments.
   *
   * @param  {Array<Node>} astBody Subtree of AST being walked
   * @return {Array<Node>}
   */functionInputs(astBody){const inputs=[];for(;!this.eof()&&!this.matches("RIGHT_PAREN");){const input=this.comparison(astBody);input.type?this.matches("COLON")&&this.report(`Unexpected type (already inferred type of parameter)`):input.type=this.type(),inputs.push(input),this.matches("COMMA")||"RIGHT_PAREN"===this.peek().type||this.report("Undelimited parameter type (expected comma delimiter or closing brace)")}return inputs}/**
   * Walk all possible paths and try to parse a single node
   * from the list of tokens.
   *
   * @param  {Array<Node>} astBody Subtree of AST being walked
   * @return {Node}
   */walk(astBody){let token=this.peek();if("MONOLOGUE"===token.type)return{type:"MonologueStatement",value:this.consume().value};if("TICK"===token.type){let node={type:"ExpressionStatement",body:[]};for(this.matches("TICK");!this.eof()&&"TICK"!==this.peek().type;)node.body.push(this.walk(node.body));return this.eof()&&this.report("Unterminated expression"),this.matches("TICK"),node}return this.comparison(astBody)}/**
   * Walks the token list and returns an AST.
   *
   * @return {AST} The AST
   */async parse(){let ast={type:"Program",body:[]};for(;!this.eof();)ast.body.push(this.walk(ast.body));return this.state===PARSER_STATE.ERROR?(console.error(`Errors encountered while parsing source`),ast):ast}/**
   * Returns true if we've reached the end of the token list, otherwise false.
   *
   * @return {boolean}
   */eof(){return this.cursor>=this.tokens.length}/**
   * Prints an error with location information to `stderr`
   * and sets the parser state to `PARSER_STATE.ERROR`
   *
   * @param {string} error
   * @return {void}
   */report(error){this.state=PARSER_STATE.ERROR,console.error(`Error (${this.cursor}): ${error}`)}}/**
 * Walks token list and returns an AST.
 *
 * @memberof radspec/parser
 * @param  {Array<Token>} tokens
 * @return {AST} The AST
 */exports.Parser=Parser;function parse(tokens){return new Parser(tokens).parse()}
//# sourceMappingURL=index.js.map