{"version":3,"sources":["../../../src/helpers/lib/methodRegistry.js"],"names":["REGISTRY_LOOKUP_ABI","REGISTRY_MAP","MethodRegistry","constructor","opts","eth","Eth","DEFAULT_ETH_NODE","network","initRegistry","net","getId","address","Error","registry","Contract","lookup","sigBytes","methods","entries","call","parse","signature","name","match","charAt","toUpperCase","slice","split","join","args","map","arg","type"],"mappings":"2QAAA;AAKA,wC,KACMA,CAAAA,mBAAmB,CAAG,CAC1B,CACE,WADF,CAEE,OAAU,CACR,CACE,KAAQ,EADV,CAEE,KAAQ,QAFV,CADQ,CAFZ,CAQE,KAAQ,SARV,CASE,QACA,CACE,CACE,KAAQ,EADV,CAEE,KAAQ,QAFV,CADF,CAVF,CAgBE,UAhBF,CAiBE,KAAQ,UAjBV,CAD0B,C,CAuBtBC,YAAY,CAAG,CACnB,EAAG,4CADgB,C,CADrB;AAKe,KAAMC,CAAAA,cAAe,CAClCC,WAAW,CAAEC,IAAI,CAAG,EAAT,CAAa,CACtB,KAAKC,GAAL,CAAWD,IAAI,CAACC,GAAL,EAAY,GAAIC,iBAAJ,CAAQC,0BAAR,CADD,CAEtB,KAAKC,OAAL,CAAeJ,IAAI,CAACI,OAAL,EAAgB,GAChC,CAED;AACA,KAAMC,CAAAA,YAAN,EAAsB,CACe,GAA/B,SAAM,MAAKJ,GAAL,CAASK,GAAT,CAAaC,KAAb,EAAN,CADgB,GAElB,KAAKN,GAAL,CAAW,GAAIC,iBAAJ,CAAQC,0BAAR,CAFO,EAKpB,KAAMK,CAAAA,OAAO,CAAGX,YAAY,CAAC,KAAKO,OAAN,CAA5B,CAEA,GAAI,CAACI,OAAL,CACE,KAAM,IAAIC,CAAAA,KAAJ,CAAU,oDAAV,CAAN,CAGF,KAAKC,QAAL,CAAgB,GAAI,MAAKT,GAAL,CAASU,QAAb,CAAsBf,mBAAtB,CAA2CY,OAA3C,CACjB,CAED,KAAMI,CAAAA,MAAN,CAAcC,QAAd,CAAwB,CAKtB,MAJK,MAAKH,QAIV,GAHE,KAAM,MAAKL,YAAL,EAGR,EAAO,KAAKK,QAAL,CAAcI,OAAd,CAAsBC,OAAtB,CAA8BF,QAA9B,EAAwCG,IAAxC,EACR,CAEDC,KAAK,CAAEC,SAAF,CAAa,CAChB;AACA,GAAIC,CAAAA,IAAI,CAAGD,SAAS,CAACE,KAAV,CAAgB,WAAhB,EAA6B,CAA7B,CAAX,CACAD,IAAI,CAAGA,IAAI,CAACE,MAAL,CAAY,CAAZ,EAAeC,WAAf,GAA+BH,IAAI,CAACI,KAAL,CAAW,CAAX,EACnCC,KADmC,CAC7B,WAD6B,EAChBC,IADgB,CACX,GADW,CAHtB,CAMhB,KAAMC,CAAAA,IAAI,CAAGR,SAAS,CAACE,KAAV,CAAgB,QAAhB,EAA0B,CAA1B,EAA6BG,KAA7B,CAAmC,CAAnC,CAAsC,CAAC,CAAvC,EAA0CC,KAA1C,CAAgD,GAAhD,CAAb,CAEA,MAAO,CACLL,IADK,CAELO,IAAI,CAAEA,IAAI,CAACC,GAAL,CAAUC,GAAD,GAAkB,CAAEC,IAAI,CAAED,GAAR,CAAlB,CAAT,CAFD,CAIR,CAzCiC,C","sourcesContent":["// From: https://github.com/danfinlay/eth-method-registry\n\nimport Eth from 'web3-eth'\nimport { DEFAULT_ETH_NODE } from '../../defaults'\n\n/* eslint-disable key-spacing, quotes */\nconst REGISTRY_LOOKUP_ABI = [\n  {\n    \"constant\": true,\n    \"inputs\": [\n      {\n        \"name\": \"\",\n        \"type\": \"bytes4\"\n      }\n    ],\n    \"name\": \"entries\",\n    \"outputs\":\n    [\n      {\n        \"name\": \"\",\n        \"type\": \"string\"\n      }\n    ],\n    \"payable\": false,\n    \"type\": \"function\"\n  }\n]\n\n// networkId -> registry address\nconst REGISTRY_MAP = {\n  1: '0x44691B39d1a75dC4E0A0346CBB15E310e6ED1E86'\n}\n\nexport default class MethodRegistry {\n  constructor (opts = {}) {\n    this.eth = opts.eth || new Eth(DEFAULT_ETH_NODE)\n    this.network = opts.network || '1'\n  }\n\n  // !!! This function can mutate `this.eth`\n  async initRegistry () {\n    if (await this.eth.net.getId() !== '1') {\n      this.eth = new Eth(DEFAULT_ETH_NODE)\n    }\n\n    const address = REGISTRY_MAP[this.network]\n\n    if (!address) {\n      throw new Error('No method registry found on the requested network.')\n    }\n\n    this.registry = new this.eth.Contract(REGISTRY_LOOKUP_ABI, address)\n  }\n\n  async lookup (sigBytes) {\n    if (!this.registry) {\n      await this.initRegistry()\n    }\n\n    return this.registry.methods.entries(sigBytes).call()\n  }\n\n  parse (signature) {\n    // TODO: Throw if there are unknown types in the signature or there if is any chars after the closing parenthesis\n    let name = signature.match(/^.+(?=\\()/)[0]\n    name = name.charAt(0).toUpperCase() + name.slice(1)\n      .split(/(?=[A-Z])/).join(' ')\n\n    const args = signature.match(/\\(.+\\)/)[0].slice(1, -1).split(',')\n\n    return {\n      name,\n      args: args.map((arg) => { return { type: arg } })\n    }\n  }\n}\n"],"file":"methodRegistry.js"}