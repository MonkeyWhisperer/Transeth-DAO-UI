{"version":3,"sources":["../src/TransportU2F.js"],"names":["wrapU2FTransportError","originalError","message","id","err","wrapApdu","apdu","key","result","Buffer","alloc","length","i","webSafe64","base64","replace","normal64","substring","attemptExchange","timeoutMillis","debug","scrambleKey","keyHandle","challenge","from","signRequest","version","toString","appId","location","origin","then","signatureData","response","data","slice","transportInstances","emitDisconnect","forEach","t","emit","isTimeoutU2FError","u2fError","metaData","code","TransportU2F","_","_openTimeout","push","exchangeTimeout","isU2FError","type","indexOf","Error","splice","resolve","isSupported","list","supported","listen","observer","unsubscribed","next","descriptor","complete","error","unsubscribe"],"mappings":"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","file":"TransportU2F.js","sourcesContent":["//@flow\n\nimport { sign, isSupported } from \"u2f-api\";\nimport Transport, { TransportError } from \"@ledgerhq/hw-transport\";\n\nfunction wrapU2FTransportError(originalError, message, id) {\n  const err = new TransportError(message, id);\n  // $FlowFixMe\n  err.originalError = originalError;\n  return err;\n}\n\nfunction wrapApdu(apdu: Buffer, key: Buffer) {\n  const result = Buffer.alloc(apdu.length);\n  for (let i = 0; i < apdu.length; i++) {\n    result[i] = apdu[i] ^ key[i % key.length];\n  }\n  return result;\n}\n\n// Convert from normal to web-safe, strip trailing \"=\"s\nconst webSafe64 = (base64: string) =>\n  base64\n    .replace(/\\+/g, \"-\")\n    .replace(/\\//g, \"_\")\n    .replace(/=+$/, \"\");\n\n// Convert from web-safe to normal, add trailing \"=\"s\nconst normal64 = (base64: string) =>\n  base64.replace(/-/g, \"+\").replace(/_/g, \"/\") +\n  \"==\".substring(0, (3 * base64.length) % 4);\n\nfunction attemptExchange(\n  apdu: Buffer,\n  timeoutMillis: number,\n  debug: *,\n  scrambleKey: Buffer\n): Promise<Buffer> {\n  const keyHandle = wrapApdu(apdu, scrambleKey);\n  const challenge = Buffer.from(\n    \"0000000000000000000000000000000000000000000000000000000000000000\",\n    \"hex\"\n  );\n  const signRequest = {\n    version: \"U2F_V2\",\n    keyHandle: webSafe64(keyHandle.toString(\"base64\")),\n    challenge: webSafe64(challenge.toString(\"base64\")),\n    appId: location.origin\n  };\n  if (debug) {\n    debug(\"=> \" + apdu.toString(\"hex\"));\n  }\n  return sign(signRequest, timeoutMillis / 1000).then(response => {\n    const { signatureData } = response;\n    if (typeof signatureData === \"string\") {\n      const data = Buffer.from(normal64(signatureData), \"base64\");\n      const result = data.slice(5);\n      if (debug) {\n        debug(\"<= \" + result.toString(\"hex\"));\n      }\n      return result;\n    } else {\n      throw response;\n    }\n  });\n}\n\nlet transportInstances = [];\n\nfunction emitDisconnect() {\n  transportInstances.forEach(t => t.emit(\"disconnect\"));\n  transportInstances = [];\n}\n\nfunction isTimeoutU2FError(u2fError) {\n  return u2fError.metaData.code === 5;\n}\n\n/**\n * U2F web Transport implementation\n * @example\n * import TransportU2F from \"@ledgerhq/hw-transport-u2f\";\n * ...\n * TransportU2F.create().then(transport => ...)\n */\nexport default class TransportU2F extends Transport<null> {\n  static isSupported = isSupported;\n\n  // this transport is not discoverable but we are going to guess if it is here with isSupported()\n  static list = (): * =>\n    isSupported().then(supported => (supported ? [null] : []));\n\n  static listen = (observer: *) => {\n    let unsubscribed = false;\n    isSupported().then(supported => {\n      if (unsubscribed) return;\n      if (supported) {\n        observer.next({ type: \"add\", descriptor: null });\n        observer.complete();\n      } else {\n        observer.error(\n          new TransportError(\n            \"U2F browser support is needed for Ledger. \" +\n              \"Please use Chrome, Opera or Firefox with a U2F extension. \" +\n              \"Also make sure you're on an HTTPS connection\",\n            \"U2FNotSupported\"\n          )\n        );\n      }\n    });\n    return {\n      unsubscribe: () => {\n        unsubscribed = true;\n      }\n    };\n  };\n\n  scrambleKey: Buffer;\n\n  /**\n   * static function to create a new Transport from a connected Ledger device discoverable via U2F (browser support)\n   */\n  static async open(_: *, _openTimeout?: number = 5000): Promise<TransportU2F> {\n    /*try {\n      // This is not a valid exchange at all, but this allows to have a way to know if there is a device.\n      // in case it reaches the timeout, we will throw timeout error, in other case, we will return the U2FTransport.\n      await attemptExchange(\n        Buffer.alloc(0),\n        openTimeout,\n        false,\n        Buffer.alloc(1)\n      );\n    } catch (e) {\n      const isU2FError = typeof e.metaData === \"object\";\n      if (isU2FError) {\n        if (isTimeoutU2FError(e)) {\n          emitDisconnect();\n          throw wrapU2FTransportError(\n            e,\n            \"Ledger device unreachable.\\n\" +\n              \"Make sure the device is plugged, unlocked and with the correct application opened.\" +\n              (location && location.protocol !== \"https:\"\n                ? \"\\nYou are not running on HTTPS. U2F is likely to not work in unsecure protocol.\"\n                : \"\"),\n            \"Timeout\"\n          );\n        } else {\n          // we don't throw if it's another u2f error\n        }\n      } else {\n        throw e;\n      }\n    }*/\n    return new TransportU2F();\n  }\n\n  constructor() {\n    super();\n    transportInstances.push(this);\n  }\n\n  async exchange(apdu: Buffer): Promise<Buffer> {\n    try {\n      return await attemptExchange(\n        apdu,\n        this.exchangeTimeout,\n        this.debug,\n        this.scrambleKey\n      );\n    } catch (e) {\n      const isU2FError = typeof e.metaData === \"object\";\n      if (isU2FError) {\n        if (isTimeoutU2FError(e)) {\n          emitDisconnect();\n        }\n        // the wrapping make error more usable and \"printable\" to the end user.\n        throw wrapU2FTransportError(\n          e,\n          \"Failed to sign with Ledger device: U2F \" + e.metaData.type,\n          \"U2F_\" + e.metaData.code\n        );\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  setScrambleKey(scrambleKey: string) {\n    this.scrambleKey = Buffer.from(scrambleKey, \"ascii\");\n  }\n\n  close(): Promise<void> {\n    const i = transportInstances.indexOf(this);\n    if (i === -1) {\n      throw new Error(\"invalid transport instance\");\n    }\n    transportInstances.splice(i, 1);\n    return Promise.resolve();\n  }\n}\n"]}