{"version":3,"sources":["../src/TransportNodeHid.js"],"names":["getDevices","filterInterface","includes","process","platform","device","usagePage","interface","devices","filter","isDisconnectedError","e","message","indexOf","TransportNodeHidNoEvents","path","Promise","resolve","then","HID","info","getDeviceInfo","deviceModel","product","exchangeBusyPromise","close","isSupported","list","map","d","listen","observer","forEach","productId","next","type","descriptor","complete","unsubscribe","channel","Math","floor","random","packetSize","disconnected","setDisconnected","emit","writeHID","content","data","i","length","push","write","reject","readHID","read","res","buffer","Buffer","from","exchange","apdu","exchangeAtomicImpl","toString","framing","blocks","makeBlocks","result","acc","getReducedResult","reduceResponse"],"mappings":"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","file":"TransportNodeHid.js","sourcesContent":["//@flow\n\nimport HID from \"node-hid\";\nimport Transport from \"@ledgerhq/hw-transport\";\nimport { log } from \"@ledgerhq/logs\";\nimport type {\n  Observer,\n  DescriptorEvent,\n  Subscription\n} from \"@ledgerhq/hw-transport\";\nimport { ledgerUSBVendorId } from \"@ledgerhq/devices\";\nimport hidFraming from \"@ledgerhq/devices/lib/hid-framing\";\nimport { identifyUSBProductId, identifyProductName } from \"@ledgerhq/devices\";\nimport type { DeviceModel } from \"@ledgerhq/devices\";\nimport { TransportError, DisconnectedDevice } from \"@ledgerhq/errors\";\n\nconst filterInterface = device =>\n  [\"win32\", \"darwin\"].includes(process.platform)\n    ? // $FlowFixMe\n      device.usagePage === 0xffa0\n    : device.interface === 0;\n\nexport function getDevices(): Array<*> {\n  // $FlowFixMe\n  return HID.devices(ledgerUSBVendorId, 0x0).filter(filterInterface);\n}\n\nconst isDisconnectedError = e =>\n  e && e.message && e.message.indexOf(\"HID\") >= 0;\n\n/**\n * node-hid Transport minimal implementation\n * @example\n * import TransportNodeHid from \"@ledgerhq/hw-transport-node-hid-noevents\";\n * ...\n * TransportNodeHid.create().then(transport => ...)\n */\nexport default class TransportNodeHidNoEvents extends Transport<?string> {\n  /**\n   *\n   */\n  static isSupported = (): Promise<boolean> =>\n    Promise.resolve(typeof HID.HID === \"function\");\n\n  /**\n   *\n   */\n  static list = (): Promise<(?string)[]> =>\n    Promise.resolve(getDevices().map(d => d.path));\n\n  /**\n   */\n  static listen = (\n    observer: Observer<DescriptorEvent<?string>>\n  ): Subscription => {\n    getDevices().forEach(device => {\n      const deviceModel = identifyUSBProductId(device.productId);\n      observer.next({\n        type: \"add\",\n        descriptor: device.path,\n        deviceModel,\n        device\n      });\n    });\n    observer.complete();\n    return { unsubscribe: () => {} };\n  };\n\n  /**\n   * if path=\"\" is not provided, the library will take the first device\n   */\n  static open(path: ?string) {\n    return Promise.resolve().then(() => {\n      if (path) {\n        return new TransportNodeHidNoEvents(new HID.HID(path));\n      }\n      const device = getDevices()[0];\n      if (!device) throw new TransportError(\"NoDevice\", \"NoDevice\");\n      return new TransportNodeHidNoEvents(new HID.HID(device.path));\n    });\n  }\n\n  device: HID.HID;\n  deviceModel: ?DeviceModel;\n\n  channel = Math.floor(Math.random() * 0xffff);\n  packetSize = 64;\n  disconnected = false;\n\n  constructor(device: HID.HID) {\n    super();\n    this.device = device;\n    // $FlowFixMe\n    const info = device.getDeviceInfo();\n    this.deviceModel =\n      info && info.product ? identifyProductName(info.product) : null;\n  }\n\n  setDisconnected = () => {\n    if (!this.disconnected) {\n      this.emit(\"disconnect\");\n      this.disconnected = true;\n    }\n  };\n\n  writeHID = (content: Buffer): Promise<void> => {\n    const data = [0x00];\n    for (let i = 0; i < content.length; i++) {\n      data.push(content[i]);\n    }\n    try {\n      this.device.write(data);\n      return Promise.resolve();\n    } catch (e) {\n      if (isDisconnectedError(e)) {\n        this.setDisconnected();\n        return Promise.reject(new DisconnectedDevice(e.message));\n      }\n      return Promise.reject(e);\n    }\n  };\n\n  readHID = (): Promise<Buffer> =>\n    new Promise((resolve, reject) =>\n      this.device.read((e, res) => {\n        if (!res) {\n          return reject(new DisconnectedDevice());\n        }\n        if (e) {\n          if (isDisconnectedError(e)) {\n            this.setDisconnected();\n            return reject(new DisconnectedDevice(e.message));\n          }\n          reject(e);\n        } else {\n          const buffer = Buffer.from(res);\n          resolve(buffer);\n        }\n      })\n    );\n\n  /**\n   * Exchange with the device using APDU protocol.\n   * @param apdu\n   * @returns a promise of apdu response\n   */\n  exchange = (apdu: Buffer): Promise<Buffer> =>\n    this.exchangeAtomicImpl(async () => {\n      const { channel, packetSize } = this;\n      log(\"apdu\", \"=> \" + apdu.toString(\"hex\"));\n\n      const framing = hidFraming(channel, packetSize);\n\n      // Write...\n      const blocks = framing.makeBlocks(apdu);\n      for (let i = 0; i < blocks.length; i++) {\n        log(\"hid-frame\", \"=> \" + blocks[i].toString(\"hex\"));\n        await this.writeHID(blocks[i]);\n      }\n\n      // Read...\n      let result;\n      let acc;\n      while (!(result = framing.getReducedResult(acc))) {\n        const buffer = await this.readHID();\n        log(\"hid-frame\", \"<= \" + buffer.toString(\"hex\"));\n        acc = framing.reduceResponse(acc, buffer);\n      }\n\n      log(\"apdu\", \"<= \" + result.toString(\"hex\"));\n      return result;\n    });\n\n  setScrambleKey() {}\n\n  /**\n   * release the USB device.\n   */\n  async close(): Promise<void> {\n    await this.exchangeBusyPromise;\n    this.device.close();\n  }\n}\n"]}