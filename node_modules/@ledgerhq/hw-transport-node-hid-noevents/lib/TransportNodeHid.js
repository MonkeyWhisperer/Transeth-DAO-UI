"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.getDevices = getDevices;

var _nodeHid = require("node-hid");

var _nodeHid2 = _interopRequireDefault(_nodeHid);

var _hwTransport = require("@ledgerhq/hw-transport");

var _hwTransport2 = _interopRequireDefault(_hwTransport);

var _logs = require("@ledgerhq/logs");

var _devices = require("@ledgerhq/devices");

var _hidFraming = require("@ledgerhq/devices/lib/hid-framing");

var _hidFraming2 = _interopRequireDefault(_hidFraming);

var _errors = require("@ledgerhq/errors");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var filterInterface = function filterInterface(device) {
  return ["win32", "darwin"].includes(process.platform) ? // $FlowFixMe
  device.usagePage === 0xffa0 : device.interface === 0;
};

function getDevices() {
  // $FlowFixMe
  return _nodeHid2.default.devices(_devices.ledgerUSBVendorId, 0x0).filter(filterInterface);
}

var isDisconnectedError = function isDisconnectedError(e) {
  return e && e.message && e.message.indexOf("HID") >= 0;
};

/**
 * node-hid Transport minimal implementation
 * @example
 * import TransportNodeHid from "@ledgerhq/hw-transport-node-hid-noevents";
 * ...
 * TransportNodeHid.create().then(transport => ...)
 */

var TransportNodeHidNoEvents = function (_Transport) {
  _inherits(TransportNodeHidNoEvents, _Transport);

  _createClass(TransportNodeHidNoEvents, null, [{
    key: "open",


    /**
     * if path="" is not provided, the library will take the first device
     */


    /**
     *
     */
    value: function open(path) {
      return Promise.resolve().then(function () {
        if (path) {
          return new TransportNodeHidNoEvents(new _nodeHid2.default.HID(path));
        }
        var device = getDevices()[0];
        if (!device) throw new _errors.TransportError("NoDevice", "NoDevice");
        return new TransportNodeHidNoEvents(new _nodeHid2.default.HID(device.path));
      });
    }

    /**
     */

    /**
     *
     */

  }]);

  function TransportNodeHidNoEvents(device) {
    _classCallCheck(this, TransportNodeHidNoEvents);

    var _this = _possibleConstructorReturn(this, (TransportNodeHidNoEvents.__proto__ || Object.getPrototypeOf(TransportNodeHidNoEvents)).call(this));

    _initialiseProps.call(_this);

    _this.device = device;
    // $FlowFixMe
    var info = device.getDeviceInfo();
    _this.deviceModel = info && info.product ? (0, _devices.identifyProductName)(info.product) : null;
    return _this;
  }

  /**
   * Exchange with the device using APDU protocol.
   * @param apdu
   * @returns a promise of apdu response
   */


  _createClass(TransportNodeHidNoEvents, [{
    key: "setScrambleKey",
    value: function setScrambleKey() {}

    /**
     * release the USB device.
     */

  }, {
    key: "close",
    value: function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.exchangeBusyPromise;

              case 2:
                this.device.close();

              case 3:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function close() {
        return _ref.apply(this, arguments);
      }

      return close;
    }()
  }]);

  return TransportNodeHidNoEvents;
}(_hwTransport2.default);

TransportNodeHidNoEvents.isSupported = function () {
  return Promise.resolve(typeof _nodeHid2.default.HID === "function");
};

TransportNodeHidNoEvents.list = function () {
  return Promise.resolve(getDevices().map(function (d) {
    return d.path;
  }));
};

TransportNodeHidNoEvents.listen = function (observer) {
  getDevices().forEach(function (device) {
    var deviceModel = (0, _devices.identifyUSBProductId)(device.productId);
    observer.next({
      type: "add",
      descriptor: device.path,
      deviceModel: deviceModel,
      device: device
    });
  });
  observer.complete();
  return { unsubscribe: function unsubscribe() {} };
};

var _initialiseProps = function _initialiseProps() {
  var _this2 = this;

  this.channel = Math.floor(Math.random() * 0xffff);
  this.packetSize = 64;
  this.disconnected = false;

  this.setDisconnected = function () {
    if (!_this2.disconnected) {
      _this2.emit("disconnect");
      _this2.disconnected = true;
    }
  };

  this.writeHID = function (content) {
    var data = [0x00];
    for (var i = 0; i < content.length; i++) {
      data.push(content[i]);
    }
    try {
      _this2.device.write(data);
      return Promise.resolve();
    } catch (e) {
      if (isDisconnectedError(e)) {
        _this2.setDisconnected();
        return Promise.reject(new _errors.DisconnectedDevice(e.message));
      }
      return Promise.reject(e);
    }
  };

  this.readHID = function () {
    return new Promise(function (resolve, reject) {
      return _this2.device.read(function (e, res) {
        if (!res) {
          return reject(new _errors.DisconnectedDevice());
        }
        if (e) {
          if (isDisconnectedError(e)) {
            _this2.setDisconnected();
            return reject(new _errors.DisconnectedDevice(e.message));
          }
          reject(e);
        } else {
          var buffer = Buffer.from(res);
          resolve(buffer);
        }
      });
    });
  };

  this.exchange = function (apdu) {
    return _this2.exchangeAtomicImpl(_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
      var channel, packetSize, framing, blocks, i, result, acc, buffer;
      return regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              channel = _this2.channel, packetSize = _this2.packetSize;

              (0, _logs.log)("apdu", "=> " + apdu.toString("hex"));

              framing = (0, _hidFraming2.default)(channel, packetSize);

              // Write...

              blocks = framing.makeBlocks(apdu);
              i = 0;

            case 5:
              if (!(i < blocks.length)) {
                _context2.next = 12;
                break;
              }

              (0, _logs.log)("hid-frame", "=> " + blocks[i].toString("hex"));
              _context2.next = 9;
              return _this2.writeHID(blocks[i]);

            case 9:
              i++;
              _context2.next = 5;
              break;

            case 12:

              // Read...
              result = void 0;
              acc = void 0;

            case 14:
              if (result = framing.getReducedResult(acc)) {
                _context2.next = 22;
                break;
              }

              _context2.next = 17;
              return _this2.readHID();

            case 17:
              buffer = _context2.sent;

              (0, _logs.log)("hid-frame", "<= " + buffer.toString("hex"));
              acc = framing.reduceResponse(acc, buffer);
              _context2.next = 14;
              break;

            case 22:

              (0, _logs.log)("apdu", "<= " + result.toString("hex"));
              return _context2.abrupt("return", result);

            case 24:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, _this2);
    })));
  };
};

exports.default = TransportNodeHidNoEvents;
//# sourceMappingURL=TransportNodeHid.js.map