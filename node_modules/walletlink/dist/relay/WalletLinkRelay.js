"use strict";
// Copyright (c) 2018-2020 WalletLink.org <https://www.walletlink.org/>
// Copyright (c) 2018-2020 Coinbase, Inc. <https://www.coinbase.com/>
// Licensed under the Apache License, version 2.0
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WalletLinkRelay = void 0;
const bind_decorator_1 = __importDefault(require("bind-decorator"));
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const WalletLinkConnection_1 = require("../connection/WalletLinkConnection");
const util_1 = require("../util");
const aes256gcm = __importStar(require("./aes256gcm"));
const Session_1 = require("./Session");
const Web3Method_1 = require("./Web3Method");
const Web3RequestCanceledMessage_1 = require("./Web3RequestCanceledMessage");
const Web3RequestMessage_1 = require("./Web3RequestMessage");
const Web3Response_1 = require("./Web3Response");
const Web3ResponseMessage_1 = require("./Web3ResponseMessage");
const WalletLinkRelayAbstract_1 = require("./WalletLinkRelayAbstract");
class WalletLinkRelay {
    constructor(options) {
        this.accountsCallback = null;
        this.chainIdCallback = null;
        this.jsonRpcUrlCallback = null;
        this.appName = "";
        this.appLogoUrl = null;
        this.walletLinkUrl = options.walletLinkUrl;
        this.storage = options.storage;
        this.session =
            Session_1.Session.load(options.storage) || new Session_1.Session(options.storage).save();
        this.relayEventManager = options.relayEventManager;
        this.connection = new WalletLinkConnection_1.WalletLinkConnection(this.session.id, this.session.key, this.walletLinkUrl);
        this.connection.incomingEvent$
            .pipe(operators_1.filter(m => m.event === "Web3Response"))
            .subscribe({ next: this.handleIncomingEvent });
        // if session is marked destroyed, reset and reload
        this.connection.sessionConfig$
            .pipe(operators_1.filter(c => !!c.metadata && c.metadata.__destroyed === "1"))
            .subscribe({ next: this.resetAndReload });
        this.connection.sessionConfig$
            .pipe(operators_1.filter(c => c.metadata && c.metadata.WalletUsername !== undefined))
            .pipe(operators_1.mergeMap(c => aes256gcm.decrypt(c.metadata.WalletUsername, this.session.secret)))
            .subscribe({
            next: walletUsername => {
                this.storage.setItem(WalletLinkRelayAbstract_1.WALLET_USER_NAME_KEY, walletUsername);
            }
        });
        this.connection.sessionConfig$
            .pipe(operators_1.filter(c => c.metadata && c.metadata.ChainId !== undefined))
            .pipe(operators_1.mergeMap(c => aes256gcm.decrypt(c.metadata.ChainId, this.session.secret)))
            .pipe(operators_1.distinctUntilChanged())
            .subscribe({ next: chainId => {
                if (this.chainIdCallback) {
                    this.chainIdCallback(chainId);
                }
            }
        });
        this.connection.sessionConfig$
            .pipe(operators_1.filter(c => c.metadata && c.metadata.JsonRpcUrl !== undefined))
            .pipe(operators_1.mergeMap(c => aes256gcm.decrypt(c.metadata.JsonRpcUrl, this.session.secret)))
            .pipe(operators_1.distinctUntilChanged())
            .subscribe({
            next: jsonRpcURl => {
                if (this.jsonRpcUrlCallback) {
                    this.jsonRpcUrlCallback(jsonRpcURl);
                }
            },
        });
        this.connection.sessionConfig$
            .pipe(operators_1.filter(c => c.metadata && c.metadata.EthereumAddress !== undefined))
            .pipe(operators_1.mergeMap(c => aes256gcm.decrypt(c.metadata.EthereumAddress, this.session.secret)))
            .subscribe({
            next: selectedAddress => {
                if (this.accountsCallback) {
                    this.accountsCallback([selectedAddress]);
                }
                if (WalletLinkRelay.accountRequestCallbackIds.size > 0) {
                    // We get the ethereum address from the metadata.  If for whatever
                    // reason we don't get a response via an explicit web3 message
                    // we can still fulfill the eip1102 request.
                    Array.from(WalletLinkRelay.accountRequestCallbackIds.values()).forEach(id => {
                        const message = Web3ResponseMessage_1.Web3ResponseMessage({
                            id,
                            response: Web3Response_1.RequestEthereumAccountsResponse([selectedAddress])
                        });
                        this.invokeCallback(Object.assign(Object.assign({}, message), { id }));
                    });
                    WalletLinkRelay.accountRequestCallbackIds.clear();
                }
            }
        });
        this.ui = options.walletLinkUIConstructor({
            walletLinkUrl: options.walletLinkUrl,
            version: options.version,
            darkMode: options.darkMode,
            session: this.session,
            connected$: this.connection.connected$
        });
        this.connection.connect();
    }
    attachUI() {
        this.ui.attach();
    }
    resetAndReload() {
        this.connection
            .setSessionMetadata("__destroyed", "1")
            .pipe(operators_1.timeout(1000), operators_1.catchError(_ => rxjs_1.of(null)))
            .subscribe(_ => {
            this.connection.destroy();
            this.storage.clear();
            this.ui.reloadUI();
        });
    }
    setAppInfo(appName, appLogoUrl) {
        this.appName = appName;
        this.appLogoUrl = appLogoUrl;
    }
    getStorageItem(key) {
        return this.storage.getItem(key);
    }
    setStorageItem(key, value) {
        this.storage.setItem(key, value);
    }
    childRequestEthereumAccounts(childSessionId, childSessionSecret, dappName, dappLogoURL, dappURL) {
        return this.sendChildRequest({
            method: Web3Method_1.Web3Method.childRequestEthereumAccounts,
            params: {
                sessionId: childSessionId,
                sessionSecret: childSessionSecret,
                appName: dappName,
                appLogoURL: dappLogoURL,
                appURL: dappURL
            }
        });
    }
    requestEthereumAccounts() {
        return this.sendRequest({
            method: Web3Method_1.Web3Method.requestEthereumAccounts,
            params: {
                appName: this.appName,
                appLogoUrl: this.appLogoUrl || null
            }
        });
    }
    signEthereumMessage(message, address, addPrefix, typedDataJson) {
        return this.sendRequest({
            method: Web3Method_1.Web3Method.signEthereumMessage,
            params: {
                message: util_1.hexStringFromBuffer(message, true),
                address,
                addPrefix,
                typedDataJson: typedDataJson || null
            }
        });
    }
    ethereumAddressFromSignedMessage(message, signature, addPrefix) {
        return this.sendRequest({
            method: Web3Method_1.Web3Method.ethereumAddressFromSignedMessage,
            params: {
                message: util_1.hexStringFromBuffer(message, true),
                signature: util_1.hexStringFromBuffer(signature, true),
                addPrefix
            }
        });
    }
    signEthereumTransaction(params) {
        return this.sendRequest({
            method: Web3Method_1.Web3Method.signEthereumTransaction,
            params: {
                fromAddress: params.fromAddress,
                toAddress: params.toAddress,
                weiValue: util_1.bigIntStringFromBN(params.weiValue),
                data: util_1.hexStringFromBuffer(params.data, true),
                nonce: params.nonce,
                gasPriceInWei: params.gasPriceInWei
                    ? util_1.bigIntStringFromBN(params.gasPriceInWei)
                    : null,
                maxFeePerGas: params.gasPriceInWei
                    ? util_1.bigIntStringFromBN(params.gasPriceInWei)
                    : null,
                maxPriorityFeePerGas: params.gasPriceInWei
                    ? util_1.bigIntStringFromBN(params.gasPriceInWei)
                    : null,
                gasLimit: params.gasLimit ? util_1.bigIntStringFromBN(params.gasLimit) : null,
                chainId: params.chainId,
                shouldSubmit: false
            }
        });
    }
    signAndSubmitEthereumTransaction(params) {
        return this.sendRequest({
            method: Web3Method_1.Web3Method.signEthereumTransaction,
            params: {
                fromAddress: params.fromAddress,
                toAddress: params.toAddress,
                weiValue: util_1.bigIntStringFromBN(params.weiValue),
                data: util_1.hexStringFromBuffer(params.data, true),
                nonce: params.nonce,
                gasPriceInWei: params.gasPriceInWei
                    ? util_1.bigIntStringFromBN(params.gasPriceInWei)
                    : null,
                maxFeePerGas: params.maxFeePerGas
                    ? util_1.bigIntStringFromBN(params.maxFeePerGas)
                    : null,
                maxPriorityFeePerGas: params.maxPriorityFeePerGas
                    ? util_1.bigIntStringFromBN(params.maxPriorityFeePerGas)
                    : null,
                gasLimit: params.gasLimit ? util_1.bigIntStringFromBN(params.gasLimit) : null,
                chainId: params.chainId,
                shouldSubmit: true
            }
        });
    }
    submitEthereumTransaction(signedTransaction, chainId) {
        return this.sendRequest({
            method: Web3Method_1.Web3Method.submitEthereumTransaction,
            params: {
                signedTransaction: util_1.hexStringFromBuffer(signedTransaction, true),
                chainId
            }
        });
    }
    scanQRCode(regExp) {
        return this.sendRequest({
            method: Web3Method_1.Web3Method.scanQRCode,
            params: { regExp }
        });
    }
    arbitraryRequest(data) {
        return this.sendRequest({
            method: Web3Method_1.Web3Method.arbitrary,
            params: { data }
        });
    }
    addEthereumChain(chainId, blockExplorerUrls, chainName, iconUrls, nativeCurrency) {
        return this.sendRequest({
            method: Web3Method_1.Web3Method.addEthereumChain,
            params: {
                chainId,
                blockExplorerUrls,
                chainName,
                iconUrls,
                nativeCurrency
            }
        });
    }
    /**
     *
     * @param request a request to connect the child session using a parent session's connection
     *
     * A note on why we're not using the sendRequest method.  The sendRequest function doesn't have
     * any way to tell when a message has been sent - it either times out after 60 seconds, or
     * waits until it gets a response from the mobile client.  In the case of sending a child request,
     * we don't wait for a response from the mobile client, we continue as soon as we know the server
     * has received the message.  Hence why we have a separate method here.
     */
    sendChildRequest(request) {
        return new Promise((resolve, reject) => {
            const id = util_1.randomBytesHex(8);
            const message = Web3RequestMessage_1.Web3RequestMessage({ id, request });
            this.publishEvent("Web3Request", message, true)
                .subscribe({
                next: ret => {
                    resolve(Web3Response_1.ChildRequestEthereumAccountsResponse(ret));
                },
                error: err => {
                    reject(new Error(err.message));
                }
            });
        });
    }
    sendRequest(request) {
        return new Promise((resolve, reject) => {
            var _a;
            let hideSnackbarItem = null;
            const id = util_1.randomBytesHex(8);
            const isRequestAccounts = request.method === Web3Method_1.Web3Method.requestEthereumAccounts;
            const isSwitchEthereumChain = request.method === Web3Method_1.Web3Method.switchEthereumChain;
            const cancel = () => {
                this.publishWeb3RequestCanceledEvent(id);
                this.handleWeb3ResponseMessage(Web3ResponseMessage_1.Web3ResponseMessage({
                    id,
                    response: Web3Response_1.ErrorResponse(request.method, "User rejected request")
                }));
                hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
            };
            if (isRequestAccounts) {
                const userAgent = ((_a = window === null || window === void 0 ? void 0 : window.navigator) === null || _a === void 0 ? void 0 : _a.userAgent) || null;
                if (userAgent &&
                    /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(userAgent)) {
                    window.location.href = `https://go.cb-w.com/xoXnYwQimhb?cb_url=${window.location.href}`;
                    return;
                }
                if (this.ui.inlineAccountsResponse()) {
                    const onAccounts = (accounts) => {
                        this.handleWeb3ResponseMessage(Web3ResponseMessage_1.Web3ResponseMessage({
                            id,
                            response: Web3Response_1.RequestEthereumAccountsResponse(accounts)
                        }));
                    };
                    this.ui.requestEthereumAccounts({
                        onCancel: cancel,
                        onAccounts
                    });
                }
                else {
                    this.ui.requestEthereumAccounts({
                        onCancel: cancel
                    });
                }
                WalletLinkRelay.accountRequestCallbackIds.add(id);
            }
            else if (request.method === Web3Method_1.Web3Method.switchEthereumChain || request.method === Web3Method_1.Web3Method.addEthereumChain) {
                const cancel = () => {
                    this.handleWeb3ResponseMessage(Web3ResponseMessage_1.Web3ResponseMessage({
                        id,
                        response: Web3Response_1.SwitchEthereumChainResponse(false),
                    }));
                };
                const approve = () => {
                    this.handleWeb3ResponseMessage(Web3ResponseMessage_1.Web3ResponseMessage({
                        id,
                        response: Web3Response_1.SwitchEthereumChainResponse(true),
                    }));
                };
                this.ui.switchEthereumChain({
                    onCancel: cancel,
                    onApprove: approve,
                    chainId: request.params.chainId,
                });
                if (!this.ui.inlineSwitchEthereumChain()) {
                    hideSnackbarItem = this.ui.showConnecting({
                        onCancel: cancel,
                        onResetConnection: this.resetAndReload,
                    });
                }
            }
            else {
                hideSnackbarItem = this.ui.showConnecting({
                    onCancel: cancel,
                    onResetConnection: this.resetAndReload
                });
            }
            this.relayEventManager.callbacks.set(id, response => {
                this.ui.hideRequestEthereumAccounts();
                hideSnackbarItem === null || hideSnackbarItem === void 0 ? void 0 : hideSnackbarItem();
                if (response.errorMessage) {
                    return reject(new Error(response.errorMessage));
                }
                resolve(response);
            });
            if ((isRequestAccounts && this.ui.inlineAccountsResponse()) ||
                (isSwitchEthereumChain && this.ui.inlineSwitchEthereumChain())) {
                return;
            }
            this.publishWeb3RequestEvent(id, request);
        });
    }
    setConnectDisabled(disabled) {
        this.ui.setConnectDisabled(disabled);
    }
    setAccountsCallback(accountsCallback) {
        this.accountsCallback = accountsCallback;
    }
    setChainIdCallback(chainIdCallback) {
        this.chainIdCallback = chainIdCallback;
    }
    setJsonRpcUrlCallback(jsonRpcUrlCallback) {
        this.jsonRpcUrlCallback = jsonRpcUrlCallback;
    }
    publishWeb3RequestEvent(id, request) {
        const message = Web3RequestMessage_1.Web3RequestMessage({ id, request });
        this.publishEvent("Web3Request", message, true).subscribe({
            error: err => {
                this.handleWeb3ResponseMessage(Web3ResponseMessage_1.Web3ResponseMessage({
                    id: message.id,
                    response: {
                        method: message.request.method,
                        errorMessage: err.message
                    }
                }));
            }
        });
    }
    publishWeb3RequestCanceledEvent(id) {
        const message = Web3RequestCanceledMessage_1.Web3RequestCanceledMessage(id);
        this.publishEvent("Web3RequestCanceled", message, false).subscribe();
    }
    publishEvent(event, message, callWebhook) {
        const secret = this.session.secret;
        return new rxjs_1.Observable((subscriber) => {
            aes256gcm.encrypt(JSON.stringify(Object.assign(Object.assign({}, message), { origin: location.origin })), secret).then((encrypted) => {
                subscriber.next(encrypted);
                subscriber.complete();
            });
        }).pipe(operators_1.mergeMap((encrypted) => {
            return this.connection.publishEvent(event, encrypted, callWebhook);
        }));
    }
    handleIncomingEvent(event) {
        try {
            aes256gcm.decrypt(event.data, this.session.secret)
                .pipe(operators_1.map(c => JSON.parse(c)))
                .subscribe({
                next: json => {
                    const message = Web3ResponseMessage_1.isWeb3ResponseMessage(json) ? json : null;
                    if (!message) {
                        return;
                    }
                    this.handleWeb3ResponseMessage(message);
                }
            });
        }
        catch (_a) {
            return;
        }
    }
    handleWeb3ResponseMessage(message) {
        const { response } = message;
        if (Web3Response_1.isRequestEthereumAccountsResponse(response)) {
            Array.from(WalletLinkRelay.accountRequestCallbackIds.values()).forEach(id => this.invokeCallback(Object.assign(Object.assign({}, message), { id })));
            WalletLinkRelay.accountRequestCallbackIds.clear();
            return;
        }
        this.invokeCallback(message);
    }
    invokeCallback(message) {
        const callback = this.relayEventManager.callbacks.get(message.id);
        if (callback) {
            callback(message.response);
            this.relayEventManager.callbacks.delete(message.id);
        }
    }
    switchEthereumChain(chainId) {
        return this.sendRequest({
            method: Web3Method_1.Web3Method.switchEthereumChain,
            params: {
                chainId
            }
        });
    }
}
WalletLinkRelay.accountRequestCallbackIds = new Set();
__decorate([
    bind_decorator_1.default
], WalletLinkRelay.prototype, "resetAndReload", null);
__decorate([
    bind_decorator_1.default
], WalletLinkRelay.prototype, "handleIncomingEvent", null);
exports.WalletLinkRelay = WalletLinkRelay;
