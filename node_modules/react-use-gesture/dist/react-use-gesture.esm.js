import React from 'react';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

var GestureFlag;

(function (GestureFlag) {
  GestureFlag["OnStart"] = "start";
  GestureFlag["OnChange"] = "change";
  GestureFlag["OnEnd"] = "end";
})(GestureFlag || (GestureFlag = {}));

// blank function
var noop = function noop() {}; // returns a function that chains all functions given as parameters

var chainFns = function chainFns() {
  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {
    fns[_key] = arguments[_key];
  }

  return function () {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return fns.forEach(function (fn) {
      return fn.apply(void 0, args);
    });
  };
}; // vector add

var addV = function addV(v1, v2) {
  return v1.map(function (v, i) {
    return v + v2[i];
  });
}; // vector substract

var subV = function subV(v1, v2) {
  return v1.map(function (v, i) {
    return v - v2[i];
  });
};

var setListeners = function setListeners(add) {
  return function (el, listeners, options) {
    var action = add ? 'addEventListener' : 'removeEventListener';
    listeners.forEach(function (_ref) {
      var type = _ref[0],
          fn = _ref[1];
      return el[action](type, fn, options);
    });
  };
};

var addListeners =
/*#__PURE__*/
setListeners(true);
var removeListeners =
/*#__PURE__*/
setListeners(false);
/**
 * Gets modifier keys from event
 * @param event
 * @returns modifier keys
 */

function getModifierKeys(event) {
  var shiftKey = event.shiftKey,
      altKey = event.altKey,
      metaKey = event.metaKey,
      ctrlKey = event.ctrlKey;
  return {
    shiftKey: shiftKey,
    altKey: altKey,
    metaKey: metaKey,
    ctrlKey: ctrlKey
  };
}
/**
 * Gets scroll event data
 * @param event
 * @returns scroll event data
 */

function getScrollEventData(event) {
  // If the currentTarget is the window then we return the scrollX/Y position.
  // If not (ie the currentTarget is a DOM element), then we return scrollLeft/Top
  var _event$currentTarget = event.currentTarget,
      scrollX = _event$currentTarget.scrollX,
      scrollY = _event$currentTarget.scrollY,
      scrollLeft = _event$currentTarget.scrollLeft,
      scrollTop = _event$currentTarget.scrollTop;
  return _extends({
    values: [scrollX || scrollLeft || 0, scrollY || scrollTop || 0]
  }, getModifierKeys(event));
}
/**
 * Gets wheel event data
 * @param event
 * @returns wheel event data
 */

function getWheelEventData(event) {
  var deltaX = event.deltaX,
      deltaY = event.deltaY; //TODO implement polyfill ?
  // https://developer.mozilla.org/en-US/docs/Web/Events/wheel#Polyfill

  return _extends({
    values: [deltaX, deltaY]
  }, getModifierKeys(event));
}
/**
 * Gets pointer event data
 * @param event
 * @returns pointer event data
 */

function getPointerEventData(event) {
  var touches = event.touches,
      buttons = event.buttons,
      changedTouches = event.changedTouches;
  var touchEvents = touches && touches.length > 0 ? touches : changedTouches && changedTouches.length > 0 ? changedTouches : null;

  var _ref2 = touchEvents ? touchEvents[0] : event,
      clientX = _ref2.clientX,
      clientY = _ref2.clientY;

  var down = touchEvents && touchEvents.length > 0 || buttons > 0;
  return _extends({
    values: [clientX, clientY],
    touches: touchEvents && touchEvents.length || 0,
    down: down,
    buttons: buttons
  }, getModifierKeys(event));
}
/**
 * Gets two touches event data
 * @param event
 * @returns two touches event data
 */

function getTwoTouchesEventData(event) {
  var touches = event.touches;
  var dx = touches[1].clientX - touches[0].clientX;
  var dy = touches[1].clientY - touches[0].clientY;
  var da = [Math.hypot(dx, dy), -(Math.atan2(dx, dy) * 180) / Math.PI];
  var origin = [(touches[1].clientX + touches[0].clientX) / 2, (touches[1].clientY + touches[0].clientY) / 2];
  return _extends({
    values: da,
    origin: origin,
    touches: 2,
    down: touches.length > 0
  }, getModifierKeys(event));
}
/**
 * Calculates velocity
 * @param diff the difference between current and previous vectors
 * @param delta_t the time delta
 * @param len the length of the diff vector
 * @returns velocity
 */

function calculateVelocity(diff, delta_t, len) {
  len = len || Math.hypot.apply(Math, diff);
  return delta_t ? len / delta_t : 0;
}
/**
 * Calculates velocities vector
 * @template T the expected vector type
 * @param diff the previous value
 * @param delta_t the time delta
 * @returns velocities vector
 */

function calculateVelocities(diff, delta_t) {
  return delta_t ? diff.map(function (v) {
    return v / delta_t;
  }) : Array(diff.length).fill(0);
}
/**
 * Calculates distance
 * @param delta the difference between current and initial vectors
 * @returns distance
 */

function calculateDistance(delta) {
  return Math.hypot.apply(Math, delta);
}
/**
 * Calculates direction
 * @template T the expected vector type
 * @param diff
 * @param len
 * @returns direction
 */

function calculateDirection(diff, len) {
  len = len || Math.hypot.apply(Math, diff) || 1;
  return diff.map(function (v) {
    return v / len;
  });
}
/**
 * Calculates all kinematics
 * @template T the expected vector type
 * @param delta the difference between current and initial vectors
 * @param diff the difference between current and previous vectors
 * @param delta_t the time delta between current and previous timestamps
 * @returns all kinematics
 */

function calculateAllKinematics(delta, diff, delta_t) {
  var len = Math.hypot.apply(Math, diff);
  return {
    velocities: calculateVelocities(diff, delta_t),
    velocity: calculateVelocity(diff, delta_t, len),
    distance: calculateDistance(delta),
    direction: calculateDirection(diff, len)
  };
}
/**
 * Whether the browser supports GestureEvent (ie Safari)
 * @returns true if the browser supports gesture event
 */

function supportsGestureEvent() {
  try {
    // TODO [TS] possibly find GestureEvent definitions?
    // @ts-ignore: Unreachable code error
    return 'constructor' in GestureEvent;
  } catch (e) {
    return false;
  }
}

/**
 * Some gestures might use the state key from another gesture (i.e. hover)
 * so mappedKeys is a commodity object to get the state key and handler key
 * for every gesture
 */

var mappedKeys = {
  drag: {
    stateKey: 'drag',
    handlerKey: 'onDrag'
  },
  pinch: {
    stateKey: 'pinch',
    handlerKey: 'onPinch'
  },
  move: {
    stateKey: 'move',
    handlerKey: 'onMove'
  },
  scroll: {
    stateKey: 'scroll',
    handlerKey: 'onScroll'
  },
  wheel: {
    stateKey: 'wheel',
    handlerKey: 'onWheel'
  },
  hover: {
    stateKey: 'move',
    handlerKey: 'onHover'
  }
}; // default config (will extend user config)

var defaultConfig = {
  domTarget: undefined,
  event: {
    passive: true,
    capture: false
  },
  pointerEvents: false,
  window: typeof window !== 'undefined' ? window : undefined,
  transform: {
    x: function x(_x) {
      return _x;
    },
    y: function y(_y) {
      return _y;
    }
  },
  enabled: true,
  drag: true,
  pinch: true,
  scroll: true,
  wheel: true,
  hover: true,
  move: true
}; // common initial state for all gestures

var initialCommon = {
  event: undefined,
  currentTarget: undefined,
  pointerId: undefined,
  values: [0, 0],
  velocities: [0, 0],
  delta: [0, 0],
  initial: [0, 0],
  previous: [0, 0],
  transform: undefined,
  local: [0, 0],
  lastLocal: [0, 0],
  first: false,
  last: false,
  active: false,
  time: undefined,
  cancel: noop,
  canceled: false,
  memo: undefined,
  args: undefined
}; // initial state for coordinates-based gestures

var initialCoordinates = {
  xy: [0, 0],
  vxvy: [0, 0],
  velocity: 0,
  distance: 0,
  direction: [0, 0]
}; // xy coordinates
// initial state for distance and angle-based gestures (pinch)

var initialDistanceAngle = {
  da: [0, 0],
  vdva: [0, 0],
  origin: [0, 0],
  turns: 0
}; // distance and angle
// initial state object (used by the gesture controller)

var initialState = {
  shared: {
    hovering: false,
    scrolling: false,
    wheeling: false,
    dragging: false,
    moving: false,
    pinching: false,
    touches: 0,
    buttons: 0,
    down: false,
    shiftKey: false,
    altKey: false,
    metaKey: false,
    ctrlKey: false
  },
  move: _extends({}, initialCommon, {}, initialCoordinates),
  drag: _extends({}, initialCommon, {}, initialCoordinates),
  scroll: _extends({}, initialCommon, {}, initialCoordinates),
  wheel: _extends({}, initialCommon, {}, initialCoordinates),
  pinch: _extends({}, initialCommon, {}, initialDistanceAngle)
}; // generic end state for all gestures

var genericEndState = {
  first: false,
  last: true,
  active: false
};

/**
 * Recognizer abstract class
 * @template GestureType whether the Recognizer should deal with coordinates or distance / angle
 */

var Recognizer =
/**
 * Creates an instance of a gesture recognizer.
 * @param gestureKey drag, move, hover, pinch, etc.
 * @param controller the controller attached to the gesture
 * @param [args] the args that should be passed to the gesture handler
 */
function Recognizer(gestureKey, controller, args) {
  var _this = this;

  if (args === void 0) {
    args = [];
  }

  this.gestureKey = gestureKey;
  this.controller = controller;
  this.args = args;

  this.isEnabled = function () {
    return _this.controller.config.enabled && _this.controller.config[_this.gestureKey];
  }; // convenience method to set a timeout for a given gesture


  this.setTimeout = function (callback, ms) {
    var _window;

    if (ms === void 0) {
      ms = 140;
    }

    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    _this.controller.timeouts[_this.stateKey] = (_window = window).setTimeout.apply(_window, [callback, ms].concat(args));
  }; // convenience method to clear a timeout for a given gesture


  this.clearTimeout = function () {
    clearTimeout(_this.controller.timeouts[_this.stateKey]);
  }; // get the controller state for a given gesture


  this.getState = function () {
    return _this.controller.state[_this.stateKey];
  }; // get the controller shared state


  this.getSharedState = function () {
    return _this.controller.state.shared;
  }; // does the controller config has pointer events enabled


  this.pointerEventsEnabled = function () {
    return _this.controller.config.pointerEvents;
  }; // gets the transform config of the controller


  this.getTransformConfig = function () {
    return _this.controller.config.transform;
  }; // convenience method to add window listeners for a given gesture


  this.addWindowListeners = function (listeners) {
    _this.controller.addWindowListeners(_this.stateKey, listeners);
  }; // convenience method to remove window listeners for a given gesture


  this.removeWindowListeners = function () {
    _this.controller.removeWindowListeners(_this.stateKey);
  };
  /**
   * convenience method to update the controller state for a given gesture
   * @param sharedState shared partial state object
   * @param gestureState partial state object for the gesture handled by the recognizer
   * @param [gestureFlag] if set, will also fire the gesture handler set by the user
   */


  this.updateState = function (sharedState, gestureState, gestureFlag) {
    _this.controller.updateState(sharedState, gestureState, _this.gestureKey, gestureFlag);
  };
  /**
   * returns the start state for a given gesture
   * @param values the values of the start state
   * @param event the event that triggers the gesture start
   */


  this.getStartState = function (values, event) {
    var state = _this.getState();

    var initial = initialState[_this.stateKey];

    var transform = state.transform || event.transform || _this.getTransformConfig();

    var lastLocal = state.local || initial.local;
    return _extends({}, initial, {
      event: event,
      values: values,
      initial: values,
      previous: values,
      local: lastLocal,
      lastLocal: lastLocal,
      first: true,
      active: true,
      transform: transform,
      time: event.timeStamp,
      args: _this.args
    });
  }; // mapping this.stateKey to the state key the gesture handles
  // (ie hover actually deals with the move gesture state)


  this.stateKey = mappedKeys[gestureKey].stateKey;
};

/**
 * Abstract class for coordinates-based gesture recongizers
 */

var CoordinatesRecognizer =
/*#__PURE__*/
function (_Recognizer) {
  _inheritsLoose(CoordinatesRecognizer, _Recognizer);

  function CoordinatesRecognizer() {
    var _this;

    _this = _Recognizer.apply(this, arguments) || this;
    /**
     * Utility function to get kinematics of the gesture
     * @values values we want to calculate the kinematics from
     * @event
     * @returns set of values including delta, velocity, velocities, distance and direction
     */

    _this.getKinematics = function (values, event) {
      // we get the gesture specific state
      var state = _this.getState();

      var xy = state.values,
          initial = state.initial,
          lastLocal = state.lastLocal,
          _state$time = state.time,
          time = _state$time === void 0 ? 0 : _state$time;

      var transform = state.transform || event.transform || _this.getTransformConfig(); // delta is the difference between the current and initial value vectors


      var delta = subV(values, initial).map(function (v, i) {
        return Object.values(transform)[i](v);
      }); // diff is the difference between the current and previous value vectors

      var diff = subV(values, xy).map(function (v, i) {
        return Object.values(transform)[i](v);
      });
      var delta_t = event.timeStamp - time;

      var _calculateAllKinemati = calculateAllKinematics(delta, diff, delta_t),
          velocity = _calculateAllKinemati.velocity,
          velocities = _calculateAllKinemati.velocities,
          distance = _calculateAllKinemati.distance,
          direction = _calculateAllKinemati.direction;

      return {
        event: event,
        values: values,
        delta: delta,
        velocity: velocity,
        velocities: velocities,
        distance: distance,
        direction: direction,
        local: addV(lastLocal, delta),
        previous: xy,
        transform: transform,
        time: event.timeStamp
      };
    };

    return _this;
  }

  return CoordinatesRecognizer;
}(Recognizer);

var DragRecognizer =
/*#__PURE__*/
function (_CoordinatesRecognize) {
  _inheritsLoose(DragRecognizer, _CoordinatesRecognize);

  function DragRecognizer(controller, args) {
    var _this;

    _this = _CoordinatesRecognize.call(this, 'drag', controller, args) || this;

    _this.onStart = function (event) {
      if (!_this.isEnabled()) return;

      var _getPointerEventData = getPointerEventData(event),
          values = _getPointerEventData.values,
          rest = _objectWithoutPropertiesLoose(_getPointerEventData, ["values"]); // making sure we're not dragging the element when more than one finger press the screen


      if (rest.touches > 1) return;
      var currentTarget = event.currentTarget,
          pointerId = event.pointerId;

      if (_this.pointerEventsEnabled()) {
        // if pointers events
        currentTarget && currentTarget.setPointerCapture(pointerId);
      } else {
        _this.removeWindowListeners();

        var dragListeners = [['mousemove', _this.onChange], ['mouseup', _this.onEnd], ['touchmove', _this.onChange], ['touchend', _this.onEnd], ['touchcancel', _this.onEnd]];

        _this.addWindowListeners(dragListeners);
      }

      var startState = _this.getStartState(values, event);

      _this.updateState(_extends({}, rest, {
        dragging: true,
        down: true
      }), _extends({}, startState, {
        currentTarget: currentTarget,
        pointerId: pointerId,
        cancel: function cancel() {
          return _this.onCancel(event);
        }
      }), GestureFlag.OnStart);
    };

    _this.onChange = function (event) {
      var _this$getState = _this.getState(),
          canceled = _this$getState.canceled,
          active = _this$getState.active;

      if (canceled || !active) return;

      var _getPointerEventData2 = getPointerEventData(event),
          values = _getPointerEventData2.values,
          rest = _objectWithoutPropertiesLoose(_getPointerEventData2, ["values"]);

      if (rest.buttons === 0 && rest.touches === 0) {
        _this.onEnd(event);

        return;
      }

      var kinematics = _this.getKinematics(values, event);

      var cancel = function cancel() {
        return _this.onCancel(event);
      };

      _this.updateState(rest, _extends({}, kinematics, {
        first: false,
        cancel: cancel
      }), GestureFlag.OnChange);
    };

    _this.onEnd = function (event) {
      var state = _this.getState();

      if (!state.active) return;
      var currentTarget = state.currentTarget,
          pointerId = state.pointerId;
      if (currentTarget && _this.pointerEventsEnabled()) currentTarget.releasePointerCapture(pointerId);else _this.removeWindowListeners();

      _this.updateState({
        dragging: false,
        down: false,
        buttons: 0,
        touches: 0
      }, _extends({}, genericEndState, {
        event: event
      }), GestureFlag.OnEnd);
    };

    _this.onCancel = function (event) {
      _this.updateState(null, {
        canceled: true,
        cancel: noop
      });

      requestAnimationFrame(function () {
        return _this.onEnd(event);
      });
    };

    return _this;
  }

  var _proto = DragRecognizer.prototype;

  _proto.getEventBindings = function getEventBindings() {
    if (this.pointerEventsEnabled()) {
      return [['onPointerDown', this.onStart], ['onPointerMove', this.onChange], [['onPointerUp', 'onPointerCancel'], this.onEnd]];
    }

    return [[['onMouseDown', 'onTouchStart'], this.onStart]];
  };

  return DragRecognizer;
}(CoordinatesRecognizer);

var ScrollRecognizer =
/*#__PURE__*/
function (_CoordinatesRecognize) {
  _inheritsLoose(ScrollRecognizer, _CoordinatesRecognize);

  function ScrollRecognizer(controller, args) {
    var _this;

    _this = _CoordinatesRecognize.call(this, 'scroll', controller, args) || this;

    _this.onChange = function (event) {
      if (!_this.isEnabled()) return;

      _this.clearTimeout();

      _this.setTimeout(_this.onEnd);

      var _getScrollEventData = getScrollEventData(event),
          values = _getScrollEventData.values,
          rest = _objectWithoutPropertiesLoose(_getScrollEventData, ["values"]);

      if (!_this.getState().active) {
        var startState = _this.getStartState(values, event);

        _this.updateState(_extends({
          scrolling: true
        }, rest), startState, GestureFlag.OnStart);
      } else {
        var kinematics = _this.getKinematics(values, event);

        _this.updateState(rest, _extends({}, kinematics, {
          first: false
        }), GestureFlag.OnChange);
      }
    };

    _this.onEnd = function () {
      if (!_this.getState().active) return;

      _this.updateState({
        scrolling: false
      }, _extends({}, genericEndState, {
        velocity: 0,
        velocities: [0, 0]
      }), GestureFlag.OnEnd);
    };

    return _this;
  }

  var _proto = ScrollRecognizer.prototype;

  _proto.getEventBindings = function getEventBindings() {
    return [['onScroll', this.onChange]];
  };

  return ScrollRecognizer;
}(CoordinatesRecognizer);

var WheelRecognizer =
/*#__PURE__*/
function (_CoordinatesRecognize) {
  _inheritsLoose(WheelRecognizer, _CoordinatesRecognize);

  function WheelRecognizer(controller, args) {
    var _this;

    _this = _CoordinatesRecognize.call(this, 'wheel', controller, args) || this;

    _this.onChange = function (event) {
      if (!_this.isEnabled()) return;

      _this.clearTimeout();

      _this.setTimeout(_this.onEnd);

      var _getWheelEventData = getWheelEventData(event),
          eventValues = _getWheelEventData.values,
          rest = _objectWithoutPropertiesLoose(_getWheelEventData, ["values"]);

      var values = addV(eventValues, _this.getState().values);

      if (!_this.getState().active) {
        var startState = _this.getStartState(values, event);

        _this.updateState(_extends({
          wheeling: true
        }, rest), startState, GestureFlag.OnStart);
      } else {
        var kinematics = _this.getKinematics(values, event);

        _this.updateState(rest, _extends({}, kinematics, {
          first: false
        }), GestureFlag.OnChange);
      }
    };

    _this.onEnd = function () {
      if (!_this.getState().active) return;

      _this.updateState({
        wheeling: false
      }, _extends({}, genericEndState, {
        velocity: 0,
        velocities: [0, 0]
      }), GestureFlag.OnEnd);
    };

    return _this;
  }

  var _proto = WheelRecognizer.prototype;

  _proto.getEventBindings = function getEventBindings() {
    return [['onWheel', this.onChange]];
  };

  return WheelRecognizer;
}(CoordinatesRecognizer);

var MoveRecognizer =
/*#__PURE__*/
function (_CoordinatesRecognize) {
  _inheritsLoose(MoveRecognizer, _CoordinatesRecognize);

  function MoveRecognizer(controller, args) {
    var _this;

    _this = _CoordinatesRecognize.call(this, 'move', controller, args) || this;

    _this.onChange = function (event) {
      if (!_this.isEnabled()) return;

      _this.clearTimeout();

      _this.setTimeout(_this.onEnd);

      var _getPointerEventData = getPointerEventData(event),
          values = _getPointerEventData.values,
          rest = _objectWithoutPropertiesLoose(_getPointerEventData, ["values"]);

      if (!_this.getState().active) {
        var startState = _this.getStartState(values, event);

        _this.updateState(_extends({
          moving: true
        }, rest), startState, GestureFlag.OnStart);
      } else {
        var kinematics = _this.getKinematics(values, event);

        _this.updateState(rest, _extends({}, kinematics, {
          first: false
        }), GestureFlag.OnChange);
      }
    };

    _this.onEnd = function () {
      if (!_this.getState().active) return;

      _this.updateState({
        moving: false
      }, _extends({}, genericEndState, {
        velocity: 0,
        velocities: [0, 0]
      }), GestureFlag.OnEnd);
    };

    return _this;
  }

  var _proto = MoveRecognizer.prototype;

  _proto.getEventBindings = function getEventBindings() {
    if (this.pointerEventsEnabled()) {
      return [['onPointerMove', this.onChange]];
    }

    return [['onMouseMove', this.onChange]];
  };

  return MoveRecognizer;
}(CoordinatesRecognizer);

var HoverRecognizer =
/*#__PURE__*/
function (_CoordinatesRecognize) {
  _inheritsLoose(HoverRecognizer, _CoordinatesRecognize);

  function HoverRecognizer(controller, args) {
    var _this;

    _this = _CoordinatesRecognize.call(this, 'hover', controller, args) || this;

    _this.onStart = function (event) {
      if (!_this.isEnabled()) return;

      var _getPointerEventData = getPointerEventData(event),
          values = _getPointerEventData.values,
          rest = _objectWithoutPropertiesLoose(_getPointerEventData, ["values"]);

      _this.updateState(_extends({
        hovering: true
      }, rest), {
        values: values,
        event: event,
        args: _this.args
      }, GestureFlag.OnChange);
    };

    _this.onEnd = function (event) {
      if (!_this.isEnabled()) return;

      var _getPointerEventData2 = getPointerEventData(event),
          values = _getPointerEventData2.values,
          rest = _objectWithoutPropertiesLoose(_getPointerEventData2, ["values"]);

      var kinematics = _this.getKinematics(values, event);

      _this.updateState(_extends({
        hovering: false,
        moving: false
      }, rest), _extends({}, kinematics, {}, genericEndState, {
        velocity: 0,
        velocities: [0, 0]
      })); // when the mouse leaves the element, we also fire the move handler
      // without waiting for move to end with debounce


      _this.controller.fireGestureHandler('move', GestureFlag.OnEnd);

      _this.controller.fireGestureHandler('hover', GestureFlag.OnChange);
    };

    return _this;
  }

  var _proto = HoverRecognizer.prototype;

  _proto.getEventBindings = function getEventBindings() {
    if (this.pointerEventsEnabled()) {
      return [['onPointerEnter', this.onStart], ['onPointerLeave', this.onEnd]];
    }

    return [['onMouseEnter', this.onStart], ['onMouseLeave', this.onEnd]];
  };

  return HoverRecognizer;
}(CoordinatesRecognizer);

/**
 * Abstract class for distance/angle-based gesture recongizers
 */

var DistanceAngleRecognizer =
/*#__PURE__*/
function (_Recognizer) {
  _inheritsLoose(DistanceAngleRecognizer, _Recognizer);

  function DistanceAngleRecognizer() {
    var _this;

    _this = _Recognizer.apply(this, arguments) || this;
    /**
     * Utility function to get kinematics of the gesture
     * @d distance
     * @a angle
     * @event
     * @returns set of values including delta, velocities, turns
     */

    _this.getKinematics = function (_ref, event) {
      var d = _ref[0],
          a = _ref[1];

      var state = _this.getState();

      var da = state.values,
          turns = state.turns,
          initial = state.initial,
          lastLocal = state.lastLocal,
          _state$time = state.time,
          time = _state$time === void 0 ? 0 : _state$time; // angle might not be defined when ctrl wheel is used for zoom only
      // in that case we set it to the previous angle value

      a = a === undefined ? da[1] : a;
      var diff_d = d - da[0];
      var diff_a = a - da[1];
      /**
       * The angle value might jump from 179deg to -179deg when we actually want to
       * read 181deg to ensure continuity. To make that happen, we detect when the jump
       * is supsiciously high (ie > 300deg) and increase the `turns` value
       */

      var newTurns = Math.abs(diff_a) > 300 ? turns + Math.sign(diff_a) : turns; // we update the angle difference to its corrected value

      diff_a -= 360 * newTurns;
      var delta_d = d - initial[0];
      var delta_a = a - 360 * newTurns - initial[1];
      var delta = [delta_d, delta_a];
      var delta_t = event.timeStamp - time;
      var velocities = calculateVelocities([diff_d, diff_a], delta_t);
      return {
        event: event,
        values: [d, a],
        delta: delta,
        velocities: velocities,
        turns: newTurns,
        local: addV(lastLocal, delta),
        previous: da,
        time: event.timeStamp
      };
    };

    return _this;
  }

  return DistanceAngleRecognizer;
}(Recognizer);

var PinchRecognizer =
/*#__PURE__*/
function (_DistanceAngleRecogni) {
  _inheritsLoose(PinchRecognizer, _DistanceAngleRecogni);

  function PinchRecognizer(controller, args) {
    var _this;

    _this = _DistanceAngleRecogni.call(this, 'pinch', controller, args) || this;

    _this.onStart = function (event) {
      if (!_this.isEnabled() || event.touches.length !== 2) return;

      var _getTwoTouchesEventDa = getTwoTouchesEventData(event),
          values = _getTwoTouchesEventDa.values,
          origin = _getTwoTouchesEventDa.origin,
          rest = _objectWithoutPropertiesLoose(_getTwoTouchesEventDa, ["values", "origin"]);

      var startState = _this.getStartState(values, event);

      _this.updateState(_extends({}, rest, {
        pinching: true,
        down: true
      }), _extends({}, startState, {
        origin: origin,
        cancel: function cancel() {
          return _this.onCancel(event);
        }
      }), GestureFlag.OnStart);
    };

    _this.onChange = function (event) {
      var _this$getState = _this.getState(),
          canceled = _this$getState.canceled,
          active = _this$getState.active;

      if (canceled || !active || event.touches.length !== 2) return;

      var _getTwoTouchesEventDa2 = getTwoTouchesEventData(event),
          values = _getTwoTouchesEventDa2.values,
          origin = _getTwoTouchesEventDa2.origin,
          rest = _objectWithoutPropertiesLoose(_getTwoTouchesEventDa2, ["values", "origin"]);

      var kinematics = _this.getKinematics(values, event);

      var cancel = function cancel() {
        return _this.onCancel(event);
      };

      _this.updateState(rest, _extends({}, kinematics, {
        origin: origin,
        first: false,
        cancel: cancel
      }), GestureFlag.OnChange);
    };

    _this.onEnd = function (event) {
      if (!_this.getState().active) return;

      _this.updateState({
        pinching: false,
        down: false,
        touches: 0
      }, _extends({}, genericEndState, {
        event: event
      }), GestureFlag.OnEnd);
    };

    _this.onCancel = function (event) {
      _this.updateState(null, {
        canceled: true,
        cancel: noop
      });

      requestAnimationFrame(function () {
        return _this.onEnd(event);
      });
    };

    return _this;
  }

  var _proto = PinchRecognizer.prototype;

  _proto.getEventBindings = function getEventBindings() {
    return [['onTouchStart', this.onStart], ['onTouchMove', this.onChange], [['onTouchEnd', 'onTouchCancel'], this.onEnd]];
  };

  return PinchRecognizer;
}(DistanceAngleRecognizer);

var PinchWheelRecognizer =
/*#__PURE__*/
function (_DistanceAngleRecogni) {
  _inheritsLoose(PinchWheelRecognizer, _DistanceAngleRecogni);

  function PinchWheelRecognizer(controller, args) {
    var _this;

    _this = _DistanceAngleRecogni.call(this, 'pinch', controller, args) || this;

    _this.onChange = function (event) {
      if (!_this.isEnabled() || !event.ctrlKey) return;
      event.preventDefault();

      _this.clearTimeout();

      _this.setTimeout(_this.onEnd);

      var _getWheelEventData = getWheelEventData(event),
          values = _getWheelEventData.values,
          rest = _objectWithoutPropertiesLoose(_getWheelEventData, ["values"]);

      var d = _this.getState().values[0] - values[1];

      if (!_this.getState().active) {
        var startState = _this.getStartState([d, 0], event);

        _this.updateState(_extends({
          pinching: true
        }, rest), startState, GestureFlag.OnStart);
      } else {
        var kinematics = _this.getKinematics([d, undefined], event);

        _this.updateState(rest, _extends({}, kinematics, {
          first: false
        }), GestureFlag.OnChange);
      }
    };

    _this.onEnd = function () {
      if (!_this.getState().active) return;

      _this.updateState({
        pinching: false,
        down: false,
        touches: 0
      }, _extends({}, genericEndState), GestureFlag.OnEnd);
    };

    return _this;
  }

  var _proto = PinchWheelRecognizer.prototype;

  _proto.getEventBindings = function getEventBindings() {
    return [['onWheel', this.onChange]];
  };

  return PinchWheelRecognizer;
}(DistanceAngleRecognizer);

var SCALE_FACTOR = 260;

var PinchWebKitGestureRecognizer =
/*#__PURE__*/
function (_DistanceAngleRecogni) {
  _inheritsLoose(PinchWebKitGestureRecognizer, _DistanceAngleRecogni);

  function PinchWebKitGestureRecognizer(controller, args) {
    var _this;

    _this = _DistanceAngleRecogni.call(this, 'pinch', controller, args) || this;

    _this.onStart = function (event) {
      if (!_this.isEnabled()) return;
      event.preventDefault();
      var da = [event.scale * SCALE_FACTOR, event.rotation];

      var startState = _this.getStartState(da, event);

      _this.updateState({
        pinching: true,
        down: true,
        touches: 2
      }, _extends({}, startState, {
        cancel: function cancel() {
          return _this.onCancel(event);
        }
      }), GestureFlag.OnStart);
    };

    _this.onChange = function (event) {
      var _this$getState = _this.getState(),
          canceled = _this$getState.canceled,
          active = _this$getState.active;

      if (canceled || !active) return;
      event.preventDefault();
      var da = [event.scale * SCALE_FACTOR, event.rotation];

      var kinematics = _this.getKinematics(da, event);

      var cancel = function cancel() {
        return _this.onCancel(event);
      };

      _this.updateState(null, _extends({}, kinematics, {
        first: false,
        cancel: cancel
      }), GestureFlag.OnChange);
    };

    _this.onEnd = function (event) {
      if (!_this.getState().active) return;
      event.preventDefault();

      _this.updateState({
        pinching: false,
        down: false,
        touches: 0
      }, _extends({}, genericEndState, {
        event: event
      }), GestureFlag.OnEnd);
    };

    _this.onCancel = function (event) {
      _this.updateState(null, {
        canceled: true,
        cancel: noop
      });

      requestAnimationFrame(function () {
        return _this.onEnd(event);
      });
    };

    _this.updateTouchData = function (event) {
      if (!_this.isEnabled() || event.touches.length !== 2) return;

      var _getTwoTouchesEventDa = getTwoTouchesEventData(event),
          origin = _getTwoTouchesEventDa.origin;

      _this.updateState(null, {
        origin: origin
      });
    };

    return _this;
  }

  var _proto = PinchWebKitGestureRecognizer.prototype;

  _proto.getEventBindings = function getEventBindings() {
    return [['onGestureStart', this.onStart], ['onGestureChange', this.onChange], [['onGestureEnd', 'onTouchCancel'], this.onEnd], [['onTouchStart', 'onTouchMove'], this.updateTouchData]];
  };

  return PinchWebKitGestureRecognizer;
}(DistanceAngleRecognizer);

/**
 * Gesture controller will create gesture recognizers (which handle the gesture logic)
 * and keep track of the state for all gestures
 *
 * @template BinderType the type the bind function should return
 */

var GestureController = function GestureController(handlers, config) {
  var _this = this;

  this.handlers = handlers;
  this.config = config;
  this.state = initialState; // state for all gestures

  this.timeouts = {}; // keeping track of timeouts for debounced gestures (such as move, scroll, wheel)

  this.bindings = {}; // an object holding the handlers associated to the gestures

  this.domListeners = []; // when config.domTarget is set, we attach events directly to the dom

  this.windowListeners = {}; // keeps track of window listeners added by gestures (drag only at the moment)

  /**
   * Function run on component unmount
   * Cleans timeouts and removes dom listeners set by the bind function
   */

  this.clean = function () {
    _this.cleanOnBind();

    Object.values(_this.timeouts).forEach(clearTimeout);
    Object.keys(_this.windowListeners).forEach(function (stateKey) {
      return _this.removeWindowListeners(stateKey);
    });
  };
  /**
   * Function run every time the bind function is run (ie on every render)
   * Reset the binding object and remove dom listeners attached to config.domTarget
   */


  this.cleanOnBind = function () {
    _this.bindings = {};
    var domTarget = _this.config.domTarget;

    if (domTarget) {
      removeListeners(domTarget, _this.domListeners, _this.config.event);
      _this.domListeners = [];
    }
  };
  /**
   * Commodity function to let gesture recognizer update global state
   * @param sharedState shared partial state object
   * @param gestureState partial gesture specific state object
   * @param gestureKey the gesture key ('drag', 'move'...)
   * @param [gestureFlag] if set, will also fire the gesture handler set by the user
   */


  this.updateState = function (sharedState, gestureState, gestureKey, gestureFlag) {
    var _extends2;

    var stateKey = mappedKeys[gestureKey].stateKey;
    _this.state = _extends({}, _this.state, (_extends2 = {
      shared: _extends({}, _this.state.shared, {}, sharedState)
    }, _extends2[stateKey] = _extends({}, _this.state[stateKey], {}, gestureState), _extends2));

    if (gestureFlag) {
      _this.fireGestureHandler(gestureKey, gestureFlag);
    }
  }; // fire the gesture handler defined by the user


  this.fireGestureHandler = function (gestureKey, gestureFlag) {
    // gets the state key and handler key from the gesture key
    // gestureKey: 'hover' -> stateKey: 'move', handlerKey: 'onHover'
    var _mappedKeys$gestureKe = mappedKeys[gestureKey],
        stateKey = _mappedKeys$gestureKe.stateKey,
        handlerKey = _mappedKeys$gestureKe.handlerKey;

    var state = _extends({}, _this.state.shared, {}, _this.state[stateKey]);

    if (gestureKey === 'pinch') {
      var pinchState = state;
      pinchState.da = state.values; // legacy state attribute for pinch gestures

      pinchState.vdva = state.velocities; // legacy state attribute for pinch gestures
    } else {
      var coordinatesState = state;
      coordinatesState.xy = state.values; // legacy state attribute for xy gestures

      coordinatesState.vxvy = state.velocities; // legacy state attribute for xy gestures
    } // TODO to be removed in future versions


    state.temp = state.memo; // legacy temp attribute

    if (gestureFlag === GestureFlag.OnStart) {
      var handlerStart = handlerKey + "Start";
      var _handler = _this.handlers[handlerStart];
      _handler && _handler(state);
    } // whenever a flag is set, we run the default on[Gesture] function
    // i.e. GestureFlag.OnStart would trigger both onDragStart and onDrag


    var handler = _this.handlers[handlerKey];

    if (handler) {
      var newMemo = handler(state);
      _this.state[stateKey].memo = newMemo !== undefined ? newMemo : _this.state[stateKey].memo;
    }

    if (gestureFlag === GestureFlag.OnEnd) {
      var handlerEnd = handlerKey + "End";
      var _handler2 = _this.handlers[handlerEnd];
      _handler2 && _handler2(state);
    }
  };
  /**
   * Commodity function to let recognizers simply add listeners to config.window
   * @param stateKey
   * @param listeners
   */


  this.addWindowListeners = function (stateKey, listeners) {
    if (!_this.config.window) return; // we use this.windowListeners to keep track of the listeners we add

    _this.windowListeners[stateKey] = listeners;
    addListeners(_this.config.window, listeners, _this.config.event);
  }; // commodity function to let recognizers simply remove listeners from config.window


  this.removeWindowListeners = function (stateKey) {
    if (!_this.config.window) return;
    var listeners = _this.windowListeners[stateKey];

    if (listeners) {
      removeListeners(_this.config.window, listeners, _this.config.event);
      delete _this.windowListeners[stateKey];
    }
  };
  /**
   * Adds a recognizer to this.bindings
   * @param recognizer
   */


  this.addRecognizer = function (recognizer) {
    recognizer.getEventBindings().map(_this.addEventBindings);
  };
  /**
   * this.bindings is an object which keys match ReactEventHandlerKeys (onMouseMove, onTouchStart...).
   * Since a recognizer might want to bind a handler function to an event key already used by a previously
   * added recognizer, we need to make sure that each event key is an array of all the functions mapped for
   * that key.
   */


  this.addEventBindings = function (_ref) {
    var eventNames = _ref[0],
        fn = _ref[1];
    var eventNamesArray = !Array.isArray(eventNames) ? [eventNames] : eventNames;
    eventNamesArray.forEach(function (eventName) {
      _this.bindings[eventName] = _this.bindings[eventName] ? [].concat(_this.bindings[eventName], [fn]) : [fn];
    });
  };
  /**
   * When config.domTarget is set, this function will add dom listeners to it
   */


  this.addDomTargetListeners = function () {
    var domTarget = _this.config.domTarget; // we iterate on the entries of this.binding
    // for each event, we chain the array of functions mapped to it
    // and push it to this.domListeners

    Object.entries(_this.bindings).forEach(function (_ref2) {
      var event = _ref2[0],
          fns = _ref2[1];

      _this.domListeners.push([event.substr(2).toLowerCase(), chainFns.apply(void 0, fns)]);
    });
    addListeners(domTarget, _this.domListeners, _this.config.event);
  };
  /**
   * getBindings will return an object that will be bound by users
   * to the react component they want to interact with
   */


  this.getBindings = function () {
    var output = {};
    var captureString = _this.config.event.capture ? 'Capture' : '';
    Object.entries(_this.bindings).forEach(function (_ref3) {
      var event = _ref3[0],
          fns = _ref3[1];
      var fnsArray = Array.isArray(fns) ? fns : [fns];
      var key = event + captureString;
      output[key] = chainFns.apply(void 0, fnsArray);
    });
    return output;
  };

  this.bind = function () {
    // if handlers contains {onDragStart, onDrag, onDragEnd, onMoveStart, onMove}
    // actions will skip on[Gesture]["Start"|"End"] functions and include
    // ['onDrag', 'onMove']
    var actions = new Set(Object.keys(_this.handlers).filter(function (k) {
      return k.indexOf('on') === 0;
    }).map(function (k) {
      var match = k.match(/(on[A-Z][a-z]+)/);
      return match ? match[1] : undefined;
    }));
    var domTarget = _this.config.domTarget;

    var genuineHandlers = _extends({}, _this.handlers); // cleaning before adding


    _this.cleanOnBind();

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    if (actions.has('onDrag')) {
      _this.addRecognizer(new DragRecognizer(_this, args));

      delete genuineHandlers.onDrag;
      delete genuineHandlers.onDragStart;
      delete genuineHandlers.onDragEnd;
    }

    if (actions.has('onScroll')) {
      _this.addRecognizer(new ScrollRecognizer(_this, args));

      delete genuineHandlers.onScroll;
      delete genuineHandlers.onScrollStart;
      delete genuineHandlers.onScrollEnd;
    }

    if (actions.has('onWheel')) {
      _this.addRecognizer(new WheelRecognizer(_this, args));

      delete genuineHandlers.onWheel;
      delete genuineHandlers.onWheelStart;
      delete genuineHandlers.onWheelEnd;
    }

    if (actions.has('onMove')) {
      _this.addRecognizer(new MoveRecognizer(_this, args));

      delete genuineHandlers.onMove;
      delete genuineHandlers.onMoveStart;
      delete genuineHandlers.onMoveEnd;
    }

    if (actions.has('onHover')) {
      _this.addRecognizer(new HoverRecognizer(_this, args));

      delete genuineHandlers.onHover;
    }

    if (actions.has('onPinch')) {
      // since react doesn't have handlers for gesture events we can only use them
      // domTarget is set (and when the browser supprots them).
      if (domTarget && supportsGestureEvent()) {
        _this.addRecognizer(new PinchWebKitGestureRecognizer(_this, args));
      } else {
        _this.addRecognizer(new PinchRecognizer(_this, args));

        _this.addRecognizer(new PinchWheelRecognizer(_this, args));
      }

      delete genuineHandlers.onPinch;
      delete genuineHandlers.onPinchStart;
      delete genuineHandlers.onPinchEnd;
    } // we also add event bindings for genuine handlers


    Object.entries(genuineHandlers).map(function (_ref4) {
      var event = _ref4[0],
          fn = _ref4[1];

      // we're cheating when it comes to event type :(
      _this.addEventBindings([event, fn]);
    }); // if config.domTarget is set we add event listeners to it and return the clean function

    if (domTarget) {
      _this.addDomTargetListeners();

      return _this.clean;
    } // if not, we return an object that contains gesture handlers mapped to react handler event keys


    return _this.getBindings();
  };
};

function useGesture(handlers, config) {
  // the gesture controller will keep track of all gesture states
  var gestureController = React.useRef();

  if (!gestureController.current) {
    // we initialize the gesture controller once
    gestureController.current = new GestureController(getDerivedHandlers(handlers), getDerivedConfig(config));
  }

  React.useEffect(function () {
    // every time handlers or config change, we let the gesture controller compute
    // them so that the gesture handlers functions are aware of the changes
    gestureController.current.config = getDerivedConfig(config);
    gestureController.current.handlers = getDerivedHandlers(handlers);
  }, [handlers, config]); // when the user component unmounts, we run our gesture controller clean function

  React.useEffect(function () {
    return gestureController.current.clean;
  }, []); // we return the bind function of our controller, which returns an binding object or
  // a cleaning function depending on whether config.domTarget is set

  return gestureController.current.bind;
}
/* SHORTHAND HANDLERS */

var useDrag = function useDrag(handler, config) {
  return useGesture({
    onDrag: handler
  }, config);
};
var useMove = function useMove(handler, config) {
  return useGesture({
    onMove: handler
  }, config);
};
var useHover = function useHover(handler, config) {
  return useGesture({
    onHover: handler
  }, config);
};
var useScroll = function useScroll(handler, config) {
  return useGesture({
    onScroll: handler
  }, config);
};
var useWheel = function useWheel(handler, config) {
  return useGesture({
    onWheel: handler
  }, config);
};
var usePinch = function usePinch(handler, config) {
  return useGesture({
    onPinch: handler
  }, config);
};

function getDerivedHandlers(handlers) {
  if (typeof handlers === 'function') return {
    onDrag: handlers
  };

  var onAction = handlers.onAction,
      rest = _objectWithoutPropertiesLoose(handlers, ["onAction"]);

  var derivedHandlers = rest;
  if (onAction) derivedHandlers.onDrag = onAction;
  return derivedHandlers;
}

function getDerivedConfig(config) {
  var derivedConfig = _extends({}, defaultConfig, {}, config);

  var domTarget = derivedConfig.domTarget;
  var realDomTarget = domTarget && 'current' in domTarget ? domTarget.current : domTarget;
  derivedConfig.domTarget = realDomTarget;
  return derivedConfig;
}

export { useDrag, useGesture, useHover, useMove, usePinch, useScroll, useWheel };
//# sourceMappingURL=react-use-gesture.esm.js.map
